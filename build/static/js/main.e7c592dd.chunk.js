(this.webpackJsonpworldsty = this.webpackJsonpworldsty || []).push([[0], { 140: function (t, e, a) { "use strict"; var i = a(4), n = (a(141), a(335)), s = a(0), o = a.n(s), r = (a(8), a(13)), l = a(170), h = a.n(l); e.a = Object(r.b)((function (t) { return Object(i.a)({}, t.articleList, { tags: t.home.tags, token: t.common.token }) }), (function (t) { return {} }))(Object(n.a)((function (t) { return o.a.createElement("div", { className: "event_list_wrapper" }, o.a.createElement("table", { className: "table table-striped table-hover" }, o.a.createElement("thead", null, o.a.createElement("tr", null, o.a.createElement("th", { className: "event_title" }, "Title"), o.a.createElement(h.a, { minDeviceWidth: 543 }, o.a.createElement("th", { className: "event_desc" }, "Description")), o.a.createElement("th", { className: "event_datetime" }, "DateTime of Event"), o.a.createElement("th", { className: "event_info" }, o.a.createElement(h.a, { minDeviceWidth: 543 }, "Detail")))), o.a.createElement("tbody", null, t.articles.map((function (e) { return o.a.createElement("tr", null, o.a.createElement("td", null, e.title), o.a.createElement(h.a, { minDeviceWidth: 543 }, o.a.createElement("td", null, e.description)), o.a.createElement("td", null, e.eventDate, " ", e.eventTimeFrom, " to ", e.eventTimeTo), o.a.createElement("td", { className: "p__info", onClick: function () { return t.history.push("/settings/event/".concat(e.slug)) } }, o.a.createElement("i", { className: "fa fa-info-circle", "aria-hidden": "true" }))) }))))) }))) }, 141: function (t, e, a) { "use strict"; var i = a(69), n = a(0), s = a.n(n), o = a(8), r = a(13), l = a(3); Object(r.b)((function () { return {} }), (function (t) { return { onSetPage: function (e, a) { return t({ type: l.N, page: e, payload: a }) } } }))((function (t) { if (t.articlesCount <= 10) return null; for (var e = [], a = 0; a < Math.ceil(t.articlesCount / 10); ++a)e.push(a); return s.a.createElement("nav", null, s.a.createElement("ul", { className: "pagination" }, e.map((function (e) { var a = e === t.currentPage; return s.a.createElement("li", { className: a ? "page-item active" : "page-item", onClick: function (a) { var i; a.preventDefault(), i = e, t.pager ? t.onSetPage(i, t.pager(i)) : t.onSetPage(i, o.a.Articles.all(i)) }, key: e.toString() }, s.a.createElement("a", { className: "page-link", href: "" }, e + 1)) })))) })), e.a = function (t) { return t.articles ? 0 === t.articles.length ? s.a.createElement("div", { className: "article-preview" }, s.a.createElement("h5", null, "No events.")) : s.a.createElement("div", { className: "row" }, t.articles.map((function (t) { return s.a.createElement(i.a, { article: t, key: t.slug }) }))) : s.a.createElement("div", { className: "article-preview" }, "No results.") } }, 151: function (t, e, a) { "use strict"; var i = a(0), n = a.n(i), s = a(753), o = a(754), r = a(755), l = a(756), h = a(757), c = a(758), d = a(759), p = a(760), u = a(761), m = a(762); e.a = function (t) { var e = t.shareLink, a = t.title; return n.a.createElement("div", { className: "share-socials" }, n.a.createElement("div", { className: "social-item" }, n.a.createElement(s.a, { url: e, title: a, windowWidth: 660, windowHeight: 460 }, n.a.createElement(o.a, { size: 32, round: !0 }))), n.a.createElement("div", { className: "social-item" }, n.a.createElement(r.a, { url: e, quote: "Facebook", windowWidth: 660, windowHeight: 460 }, n.a.createElement(l.a, { size: 32, round: !0 }))), n.a.createElement("div", { className: "social-item" }, n.a.createElement(h.a, { url: e, windowWidth: 660, windowHeight: 460 }, n.a.createElement(c.a, { size: 32, round: !0 }))), n.a.createElement("div", { className: "social-item" }, n.a.createElement(d.a, { url: e, title: a, windowWidth: 660, windowHeight: 460 }, n.a.createElement(p.a, { size: 32, round: !0 }))), n.a.createElement("div", { className: "social-item" }, n.a.createElement(u.a, { url: e, title: a, windowWidth: 660, windowHeight: 460 }, n.a.createElement(m.a, { size: 32, round: !0 })))) } }, 161: function (t, e, a) { "use strict"; var i = a(11), n = a(12), s = a(15), o = a(14), r = a(0), l = a(745); l = l.Chart ? l : window.CanvasJS; var h = function (t) { Object(s.a)(a, t); var e = Object(o.a)(a); function a(t) { var n; return Object(i.a)(this, a), (n = e.call(this, t)).options = t.options ? t.options : {}, n.containerProps = t.containerProps ? t.containerProps : { width: "100%", position: "relative" }, n.containerProps.height = t.containerProps && t.containerProps.height ? t.containerProps.height : n.options.height ? n.options.height + "px" : "400px", n.chartContainerId = "canvasjs-react-chart-container-" + a._cjsContainerId++, n } return Object(n.a)(a, [{ key: "componentDidMount", value: function () { this.chart = new l.Chart(this.chartContainerId, this.options), this.chart.render(), this.props.onRef && this.props.onRef(this.chart) } }, { key: "shouldComponentUpdate", value: function (t, e) { return !(t.options === this.options) } }, { key: "componentDidUpdate", value: function () { this.chart.options = this.props.options, this.chart.render() } }, { key: "componentWillUnmount", value: function () { this.chart.destroy(), this.props.onRef && this.props.onRef(void 0) } }, { key: "render", value: function () { return r.createElement("div", { id: this.chartContainerId, style: this.containerProps }) } }]), a }(r.Component); h._cjsContainerId = 0; var c = { CanvasJSChart: h, CanvasJS: l }; e.a = c }, 222: function (t, e, a) { "use strict"; (function (t) { var i = a(11), n = a(12), s = a(15), o = a(14), r = a(4), l = a(140), h = a(0), c = a.n(h), d = a(8), p = a(13), u = a(3), m = (a(30), a(27)), x = a.n(m), g = (a(16), t.Promise), b = (window.google, function (t) { Object(s.a)(a, t); var e = Object(o.a)(a); function a() { return Object(i.a)(this, a), e.call(this) } return Object(n.a)(a, [{ key: "componentWillMount", value: function () { var t = d.a.Articles.byAuthor; this.props.currentUser && this.props.onLoad("myPost", t, g.all([d.a.Articles.getAllCategories(), t(this.props.currentUser.username)])), x()("html, body").animate({ scrollTop: 0 }, 0) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "componentWillReceiveProps", value: function (t) { } }, { key: "render", value: function () { var t = this; return c.a.createElement("div", { className: "company-home-page" }, c.a.createElement("div", { className: "c__h__header" }, c.a.createElement("h4", null, "All Events"), c.a.createElement("button", { className: "btn", onClick: function () { return t.props.history.push("/settings/event") } }, c.a.createElement("i", { className: "fa fa-plus-circle", "aria-hidden": "true" }), "New event")), c.a.createElement("div", { className: "c__h__content container page" }, this.props.articleListLoaded && c.a.createElement(l.a, { params: this.props.match.params, local: "local" }))) } }]), a }(c.a.Component)); e.a = Object(p.b)((function (t) { return Object(r.a)({}, t.home, { articleListLoaded: t.articleList.articleListLoaded, currentUser: t.common.currentUser, appName: t.common.appName, token: t.common.token, categories: t.common.categories }) }), (function (t) { return { onClickCategory: function (e, a, i) { return t({ type: u.c, tag: e, pager: a, payload: i }) }, onLoad: function (e, a, i) { return t({ type: u.t, tab: e, pager: a, payload: i }) }, onUnload: function () { return t({ type: u.u }) } } }))(b) }).call(this, a(31)) }, 3: function (t, e, a) { "use strict"; a.d(e, "d", (function () { return i })), a.d(e, "F", (function () { return n })), a.d(e, "i", (function () { return s })), a.d(e, "M", (function () { return o })), a.d(e, "o", (function () { return r })), a.d(e, "L", (function () { return l })), a.d(e, "t", (function () { return h })), a.d(e, "u", (function () { return c })), a.d(e, "g", (function () { return d })), a.d(e, "h", (function () { return p })), a.d(e, "a", (function () { return u })), a.d(e, "p", (function () { return m })), a.d(e, "e", (function () { return x })), a.d(e, "j", (function () { return g })), a.d(e, "f", (function () { return b })), a.d(e, "k", (function () { return y })), a.d(e, "N", (function () { return f })), a.d(e, "c", (function () { return v })), a.d(e, "n", (function () { return k })), a.d(e, "A", (function () { return M })), a.d(e, "B", (function () { return T })), a.d(e, "v", (function () { return w })), a.d(e, "x", (function () { return P })), a.d(e, "G", (function () { return C })), a.d(e, "w", (function () { return S })), a.d(e, "I", (function () { return A })), a.d(e, "H", (function () { return E })), a.d(e, "m", (function () { return _ })), a.d(e, "l", (function () { return F })), a.d(e, "q", (function () { return B })), a.d(e, "r", (function () { return L })), a.d(e, "b", (function () { return I })), a.d(e, "J", (function () { return D })), a.d(e, "P", (function () { return N })), a.d(e, "Q", (function () { return V })), a.d(e, "s", (function () { return W })), a.d(e, "O", (function () { return z })), a.d(e, "z", (function () { return O })), a.d(e, "y", (function () { return X })), a.d(e, "K", (function () { return Y })), a.d(e, "R", (function () { return R })), a.d(e, "E", (function () { return j })), a.d(e, "C", (function () { return U })), a.d(e, "D", (function () { return H })); var i = "APP_LOAD", n = "REDIRECT", s = "ARTICLE_SUBMITTED", o = "SETTINGS_SAVED", r = "DELETE_ARTICLE", l = "SETTINGS_PAGE_UNLOADED", h = "HOME_PAGE_LOADED", c = "HOME_PAGE_UNLOADED", d = "ARTICLE_PAGE_LOADED", p = "ARTICLE_PAGE_UNLOADED", u = "ADD_COMMENT", m = "DELETE_COMMENT", x = "ARTICLE_FAVORITED", g = "ARTICLE_UNFAVORITED", b = "ARTICLE_FAVORITED_EACH", y = "ARTICLE_UNFAVORITED_EACH", f = "SET_PAGE", v = "APPLY_TAG_FILTER", k = "CHANGE_TAB", M = "PROFILE_PAGE_LOADED", T = "PROFILE_PAGE_UNLOADED", w = "LOGIN", P = "LOGOUT", C = "REGISTER", S = "LOGIN_PAGE_UNLOADED", A = "REGISTER_PAGE_UNLOADED", E = "REGISTER_PAGE_LOADED", _ = "ASYNC_START", F = "ASYNC_END", B = "EDITOR_PAGE_LOADED", L = "EDITOR_PAGE_UNLOADED", I = "ADD_TAG", D = "REMOVE_TAG", N = "UPDATE_FIELD_AUTH", V = "UPDATE_FIELD_EDITOR", W = "FOLLOW_USER", z = "UNFOLLOW_USER", O = "PROFILE_FAVORITES_PAGE_UNLOADED", X = "PROFILE_FAVORITES_PAGE_LOADED", Y = "RESET_PASSWORD", R = "UPDATE_FIELD_TICKET", j = "PURCHASE_TICKET", U = "PURCHASE_PAGE_LOADED", H = "PURCHASE_PAGE_UNLOADED" }, 320: function (t, e, a) { t.exports = a.p + "static/media/logo.c720c543.png" }, 324: function (t, e, a) { "use strict"; var i = a(4), n = (a(141), a(0)), s = a.n(n), o = (a(8), a(13)), r = a(3), l = a(210), h = a.n(l), c = a(69); e.a = Object(o.b)((function (t) { return Object(i.a)({}, t.articleList, { tags: t.home.tags, token: t.common.token }) }), (function (t) { return { onTabClick: function (e, a, i) { return t({ type: r.n, tab: e, pager: a, payload: i }) } } }))((function (t) { var e = "Events", i = "near you", n = t.params.search && t.params.search.split("&") || []; n && n.length > 0 && ("" == (e = n[2].split("=")[1]) && (e = "Events"), "location=" != n[0] && (i = "in " + n[0].replace("location=", "").split("-")[0])); var o = { arrows: !1, infinite: !0, speed: 500, slidesToShow: 3, slidesToScroll: 1, responsive: [{ breakpoint: 1024, settings: { slidesToShow: 2, slidesToScroll: 1, infinite: !0 } }, { breakpoint: 768, settings: { slidesToShow: 1, slidesToScroll: 1, infinite: !0 } }] }, r = t.deviceType, l = t.articles, d = 0 == n.length && !t.params.tag && !t.params.askey && t.local; return s.a.createElement(s.a.Fragment, null, d ? s.a.createElement(s.a.Fragment, null, s.a.createElement("div", { className: "popular-events-container" }, s.a.createElement("div", { className: "location-label" }, 0 == n.length && !t.params.tag && t.local && s.a.createElement(s.a.Fragment, null, "Popular events in", s.a.createElement("div", { className: "location-value" }, t.curCountry && "in " + t.curCountry)), n.length > 0 && s.a.createElement(s.a.Fragment, null, "Popular ", e, s.a.createElement("div", { className: "location-value" }, i))), s.a.createElement(h.a, o, "tablet" !== r && "mobile" !== r && s.a.createElement("div", { className: "slider-one" }, l && l.slice(0, 2).map((function (t, e) { return s.a.createElement(c.a, { key: e, article: t }) }))), ("tablet" === r || "mobile" === r) && s.a.createElement(c.a, { article: l.slice(0, 1) }), ("tablet" === r || "mobile" === r) && s.a.createElement(c.a, { article: l.slice(1, 2) }), s.a.createElement(c.a, { className: "slider-two", article: l.slice(2, 3) }), s.a.createElement(c.a, { className: "slider-three", article: l.slice(3, 4) }))), s.a.createElement("div", { className: "mobile-download-container" }, s.a.createElement("div", { className: "mobile-img" }, s.a.createElement("img", { src: a(662), alt: "iPhone-X" })), s.a.createElement("div", { className: "download-section" }, s.a.createElement("div", { className: "download-header" }, s.a.createElement("div", null, "Lorem lpsum"), s.a.createElement("div", null, "is simply dummy text of the printing and typesetting industry.")), s.a.createElement("div", { className: "download-btns" }, s.a.createElement("div", { className: "download-btn-googleplay" }, s.a.createElement("img", { src: a(663), alt: "Google Play" })), s.a.createElement("div", { className: "download-btn-appstore" }, s.a.createElement("img", { src: a(664), alt: "App Store" }))))), s.a.createElement("div", { className: "featured-events-container" }, s.a.createElement("div", { className: "featured-events-title" }, "Featured events"), s.a.createElement("div", { className: "events-content" }, t.featuredArticles.map((function (t, e) { return s.a.createElement(c.a, { key: e, article: t }) }))))) : s.a.createElement(s.a.Fragment, null, s.a.createElement("div", { className: "popular-events-container" }, s.a.createElement("div", { className: "location-label" }, 0 == n.length && !t.params.tag && t.local && s.a.createElement(s.a.Fragment, null, "Popular events in", s.a.createElement("div", { className: "location-value" }, t.curCountry && "in " + t.curCountry)), n.length > 0 && s.a.createElement(s.a.Fragment, null, "Popular ", e, s.a.createElement("div", { className: "location-value" }, i)))), s.a.createElement("div", { className: "featured-events-container" }, s.a.createElement("div", { className: "events-content" }, t.articles.map((function (t, e) { return s.a.createElement(c.a, { key: e, article: t }) })))))) })) }, 328: function (t, e, a) { "use strict"; (function (t) { var i = a(11), n = a(12), s = a(15), o = a(14), r = a(4), l = (a(140), a(0)), h = a.n(l), c = (a(8), a(13)), d = a(3), p = (a(30), a(27), a(16), a(161).a.CanvasJSChart, t.Promise, window.google, function (t) { Object(s.a)(a, t); var e = Object(o.a)(a); function a() { return Object(i.a)(this, a), e.call(this) } return Object(n.a)(a, [{ key: "componentWillMount", value: function () { } }, { key: "componentWillUnmount", value: function () { } }, { key: "componentWillReceiveProps", value: function (t) { } }, { key: "render", value: function () { return h.a.createElement("div", { className: "company-home-page" }, h.a.createElement("div", { className: "c__h__header" }, h.a.createElement("h4", null, "Overview")), h.a.createElement("div", { className: "c__h__content container page" })) } }]), a }(h.a.Component)); e.a = Object(c.b)((function (t) { return Object(r.a)({}, t.home, { articleListLoaded: t.articleList.articleListLoaded, appName: t.common.appName, token: t.common.token, categories: t.common.categories }) }), (function (t) { return { onClickCategory: function (e, a, i) { return t({ type: d.c, tag: e, pager: a, payload: i }) }, onLoad: function (e, a, i) { return t({ type: d.t, tab: e, pager: a, payload: i }) }, onUnload: function () { return t({ type: d.u }) } } }))(p) }).call(this, a(31)) }, 329: function (t, e, a) { "use strict"; (function (t) { a(332); var i = a(11), n = a(12), s = a(15), o = a(14), r = (a(140), a(0)), l = a.n(r), h = a(171), c = a(8), d = a(13), p = a(3), u = a(30), m = (a(27), a(16), a(161)), x = (a(747), m.a.CanvasJSChart, t.Promise, window.google, Object(h.c)(u)), g = function (t) { Object(s.a)(a, t); var e = Object(o.a)(a); function a() { var t; return Object(i.a)(this, a), (t = e.call(this)).state = { events: [] }, t.handleSelect = function (t) { t.start, t.end }, t } return Object(n.a)(a, [{ key: "componentWillMount", value: function () { var t = this; this.props.currentUser && c.a.Articles.byAuthor(this.props.currentUser.username).then((function (e) { var a = e.articles.map((function (t) { return { title: t.title, start: new Date(t.eventDate + " " + t.eventTimeFrom), end: new Date(t.eventDate + " " + t.eventTimeTo), link: "/settings/event/" + t.slug } })); t.setState({ events: a }) })) } }, { key: "componentWillUnmount", value: function () { } }, { key: "componentWillReceiveProps", value: function (t) { } }, { key: "render", value: function () { var t = this; return l.a.createElement("div", { className: "company-home-page" }, l.a.createElement("div", { className: "" }, l.a.createElement("div", { className: "c__h__header" }, l.a.createElement("h4", null, "Calendar")), l.a.createElement("div", { className: "c__h__content container page" }, l.a.createElement(h.a, { selectable: !0, localizer: x, events: this.state.events, defaultView: h.b.MONTH, scrollToTime: new Date(1970, 1, 1, 6), defaultDate: new Date, onSelectEvent: function (e) { return t.props.history.push(e.link) }, onSelectSlot: this.handleSelect })))) } }]), a }(l.a.Component); e.a = Object(d.b)((function (t) { return { currentUser: t.common.currentUser } }), (function (t) { return { onClickCategory: function (e, a, i) { return t({ type: p.c, tag: e, pager: a, payload: i }) }, onLoad: function (e, a, i) { return t({ type: p.t, tab: e, pager: a, payload: i }) }, onUnload: function () { return t({ type: p.u }) } } }))(g) }).call(this, a(31)) }, 337: function (t, e, a) { t.exports = a(749) }, 373: function (t, e, a) { }, 396: function (t, e, a) { t.exports = a.p + "static/media/english.fdd87d18.png" }, 397: function (t, e) { t.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAHCAYAAAA4R3wZAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAAFBJREFUGJWVzjEOQEAURdEj1L9VsAZrsDNjZ5amMglmZNzqNSd53TwtCZt/7X3EeKDD2oqQ+ogRWvGOBBdswRk94Re+oRIs4ReCoXIrVXbuBKKPDgOLuvB1AAAAAElFTkSuQmCC" }, 398: function (t, e, a) { t.exports = a.p + "static/media/festivals.fc3eb041.png" }, 399: function (t, e, a) { t.exports = a.p + "static/media/bars.01f070e3.png" }, 400: function (t, e, a) { t.exports = a.p + "static/media/beachclub.8fc4b172.png" }, 401: function (t, e, a) { t.exports = a.p + "static/media/concerts.1a2241d3.png" }, 402: function (t, e, a) { t.exports = a.p + "static/media/livemusic.6a785c98.png" }, 403: function (t, e, a) { t.exports = a.p + "static/media/nightclub.3edee428.png" }, 404: function (t, e, a) { t.exports = a.p + "static/media/pubs.2ac03d2a.png" }, 405: function (t, e) { t.exports = "data:image/png;base64,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" }, 406: function (t, e) { t.exports = "data:image/png;base64,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" }, 407: function (t, e) { t.exports = "data:image/png;base64,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" }, 61: function (t, e, a) { "use strict"; (function (t) { var i = a(11), n = a(12), s = a(15), o = a(14), r = a(4), l = (a(646), a(334)), h = a(324), c = a(0), d = a.n(c), p = (a(665), a(8)), u = a(13), m = (a(22), a(210), a(3)), x = a(67), g = a(30), b = a(27), y = a.n(b), f = a(16), v = a.n(f), k = (a(666), a(326)), M = a.n(k), T = (a(697), a(698), a(162)), w = t.Promise, P = window.google, C = function (t) { Object(s.a)(c, t); var e = Object(o.a)(c); function c() { var t; return Object(i.a)(this, c), (t = e.call(this)).state = { curCountry: "", scope: "nearby", sKey: "", date: "", curDate: new Date, category: "", selectedDay: null, priceRange: { min: 0, max: 240 }, tagInput: "", tags: [], author: "", pickupDate: !1, yourEmail: "", deviceType: "", customStylesForSelect: {} }, t.onSearchKeyDown = function (t) { }, t.searchKeyChange = function (e) { t.setState({ sKey: e }) }, t.searchCompanies = function (e) { var a = "", i = "", n = "", s = ""; p.a.Articles.all; if (void 0 != e) { for (var o = 0; o < e.gmaps.address_components.length; o++) { var r = e.gmaps.address_components[o]; switch (r.types[0]) { case "locality": a = r.long_name; break; case "administrative_area_level_1": i = r.long_name; break; case "country": n = r.long_name } } s = a + ", " + i + ", " + n, t.setState({ sKey: s }) } }, t.search = function () { var e = "location="; t.state.sKey && "" !== t.state.sKey && (e += t.state.sKey.replace(/\, /g, "-")), e += "&date=", t.state.date && "" !== t.state.date && (e += t.state.date), e += "&category=", t.state.category && "" !== t.state.category && (e += t.state.category), "&date=&category=" !== e ? t.props.history.push("/s/" + e) : t.props.history.push("/") }, t.filterSearch = function () { var e = "location="; t.state.sKey && "" !== t.state.sKey && (e += t.state.sKey.replace(/\, /g, "-")), e += "&date=", t.state.date && "" !== t.state.date && (e += t.state.date), e += "&category=", t.state.category && "" !== t.state.category && (e += t.state.category), e += "&priceRange=", t.state.priceRange && "" !== t.state.priceRange && (e += t.state.priceRange.min + "-" + t.state.priceRange.max), e += "&tags=", t.state.tags && "" !== t.state.tags && (e += t.state.tags.join("-")), e += "&author=", t.state.author && "" !== t.state.author && (e += t.state.author), "&date=&category=&priceRange=0-0&tags=&author" !== e ? t.props.history.push("/s/" + e) : t.props.history.push("/") }, t.onChangeDate = function (e) { t.setState({ date: e }) }, t.onChange = function (e) { return t.setState({ curDate: e, pickupDate: !1, date: g(e).format("YYYY-MM-DD"), dateType: "picked date" }) }, t.handleDayChange = function (e) { t.setState({ selectedDay: e }) }, t.changeTags = function (e) { t.setState({ tagInput: e.target.value }) }, t.watchForEnter = function (e) { if (13 === e.keyCode && "" !== e.target.value) { e.preventDefault(); var a = t.state.tags.concat([t.state.tagInput]); t.setState({ tags: a, tagInput: "" }) } }, t.removeTagHandler = function (e) { return function () { var a = t.state.tags.filter((function (t) { return t !== e })); t.setState({ tags: a }) } }, t.onChangeDateType = function (e) { var a = e.target.value; t.setState({ dateType: a }), "pick up date" == a ? t.setState({ pickupDate: !0 }) : t.setState({ date: a }) }, t } return Object(n.a)(c, [{ key: "componentWillMount", value: function () { if (this.props.match.params.category) { var t = this.props.match.params.category, e = p.a.Articles.byCategory; this.props.onLoad(null, e, w.all([p.a.Articles.getAllCategories(), e(t)])) } else if (this.props.match.params.search) { var a = (x = this.props.match.params.search).split("&"), i = a[1].replace("date=", ""), n = ""; switch (i) { case "today": n = g().format("YYYY-MM-DD"); break; case "this week": n = g().day(1).format("YYYY-MM-DD") + "+" + g().day(7).format("YYYY-MM-DD"); break; case "next week": n = g().day(8).format("YYYY-MM-DD") + "+" + g().day(14).format("YYYY-MM-DD"); break; default: n = i }var s = x.replace(i, n); e = p.a.Articles.bySearch; this.props.onLoad("feed", e, w.all([p.a.Articles.getAllCategories(), e(s)])); var o = a[0].replace("location=", "").replace(/\-/g, ", "); if (a.length > 2) t = a[2].replace("category=", ""); var r = a[3].replace("priceRange=", "").split("-"), l = a[4].replace("tags=", ""); l = "" === l ? [] : l.split("-"); var h = new Date; i.indexOf("-") > -1 && (h = new Date(i)), this.setState({ sKey: o, date: i, curDate: h, category: t, priceRange: { min: r[0], max: r[1] }, tags: l, author: a[5].replace("author=", ""), dateType: i }) } else if (this.props.match.params.tag) { var c = this.props.match.params.tag; e = p.a.Articles.byTag; this.props.onLoad(null, e, w.all([p.a.Articles.getAllCategories(), e(c)])) } else if (this.props.match.params.askey) { c = this.props.match.params.askey, e = p.a.Articles.advancedSearch; this.props.onLoad(null, e, w.all([p.a.Articles.getAllCategories(), e(c)])) } else { var d = "", u = "", m = "", x = "mylocation=", b = this; navigator.geolocation.getCurrentPosition((function (t) { var e = t.coords.latitude, a = t.coords.longitude, i = new P.maps.Geocoder, n = new P.maps.LatLng(e, a); new w((function (t) { i.geocode({ latLng: n }, (function (e, a) { a == P.maps.GeocoderStatus.OK && e[0] && t(e) })) })).then((function (t) { for (var e = 0; e < t[0].address_components.length; e++) { var a = t[0].address_components[e]; switch (a.types[0]) { case "locality": d = a.long_name; break; case "administrative_area_level_1": u = a.long_name; break; case "country": m = a.long_name } } x += d + "-" + u + "-" + m; var i = "all", n = p.a.Articles.all; "||" !== x && (i = "feed", n = p.a.Articles.bySearch, b.setState({ scope: "nearby", curCountry: m })), b.props.onLoad(i, n, w.all([p.a.Articles.getAllCategories(), n(x)])) })) }), (function (t) { t.code == t.PERMISSION_DENIED && alert("we can't access to your geolocation, allow it please."); var e = p.a.Articles.all; b.props.onLoad("all", e, w.all([p.a.Articles.getAllCategories(), e()])) })) } y()("html, body").animate({ scrollTop: 0 }, 0), window.addEventListener("resize", this.handleResize.bind(this)), this.handleResize() } }, { key: "componentWillUnmount", value: function () { this.props.onUnload(), window.removeEventListener("resize", this.handleResize.bind(this)) } }, { key: "componentWillReceiveProps", value: function (t) { if (this.props.match.params.category !== t.match.params.category) { var e = t.match.params.category, a = p.a.Articles.byCategory; this.props.onLoad(null, a, w.all([p.a.Articles.getAllCategories(), a(e)])) } if (this.props.match.params.tag !== t.match.params.tag) { var i = t.match.params.tag; a = p.a.Articles.byTag; this.props.onLoad(null, a, w.all([p.a.Articles.getAllCategories(), a(i)])) } if (this.props.match.params.askey !== t.match.params.askey) { i = t.match.params.askey, a = p.a.Articles.advancedSearch; this.props.onLoad(null, a, w.all([p.a.Articles.getAllCategories(), a(i)])) } if (this.props.match.params.search !== t.match.params.search) { var n = t.match.params.search, s = n.split("&"), o = s[1].replace("date=", ""), r = ""; switch (o) { case "today": r = g().format("YYYY-MM-DD"); break; case "this week": r = g().day(1).format("YYYY-MM-DD") + "+" + g().day(7).format("YYYY-MM-DD"); break; case "next week": r = g().day(8).format("YYYY-MM-DD") + "+" + g().day(14).format("YYYY-MM-DD"); break; default: r = o }var l = n.replace(o, r); a = p.a.Articles.bySearch; this.props.onLoad("feed", a, w.all([p.a.Articles.getAllCategories(), a(l)])); var h = s[0].replace("location=", "").replace(/\-/g, ", "); if (s.length > 2) e = s[2].replace("category=", ""); var c = s[3].replace("priceRange=", "").split("-"), d = s[4].replace("tags=", ""); d = "" === d ? [] : d.split("-"); var u = new Date; o.indexOf("-") > -1 && (u = new Date(o)), this.setState({ sKey: h, date: o, curDate: u, category: e, priceRange: { min: c[0], max: c[1] }, tags: d, author: s[5].replace("author=", ""), dateType: o }) } } }, { key: "handleResize", value: function () { var t = this.state.deviceType; window.innerWidth > 1440 ? "desktop-l" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(r.a)({}, t, { borderBottom: "solid 1px #000000" }) }, control: function (t, e) { return Object(r.a)({}, t, { border: "none", outline: "none", minHeight: 20 }) }, group: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) }, indicatorSeparator: function (t, e) { return Object(r.a)({}, t, { display: "none" }) }, placeholder: function (t, e) { return Object(r.a)({}, t, { fontSize: "0.94vw" }) }, valueContainer: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) } } }), this.setState({ deviceType: "desktop-l" })) : window.innerWidth > 1023 ? "desktop-s" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(r.a)({}, t, { borderBottom: "solid 1px #000000" }) }, control: function (t, e) { return Object(r.a)({}, t, { border: "none", outline: "none", minHeight: 20 }) }, group: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) }, indicatorSeparator: function (t, e) { return Object(r.a)({}, t, { display: "none" }) }, placeholder: function (t, e) { return Object(r.a)({}, t, { fontSize: "1.2vw" }) }, valueContainer: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) } } }), this.setState({ deviceType: "desktop-s" })) : window.innerWidth > 767 ? "tablet" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(r.a)({}, t, { borderBottom: "solid 1px #000000" }) }, control: function (t, e) { return Object(r.a)({}, t, { border: "none", outline: "none", minHeight: 20 }) }, group: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) }, indicatorSeparator: function (t, e) { return Object(r.a)({}, t, { display: "none" }) }, input: function (t, e) { return Object(r.a)({}, t, { padding: 0, margin: 0 }) }, option: function (t, e) { return Object(r.a)({}, t, { fontSize: "14px" }) }, placeholder: function (t, e) { return Object(r.a)({}, t, { fontSize: "14px" }) }, valueContainer: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) } } }), this.setState({ deviceType: "tablet" })) : window.innerWidth > 320 && "mobile" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(r.a)({}, t, { borderBottom: "solid 1px #000000" }) }, control: function (t, e) { return Object(r.a)({}, t, { border: "none", outline: "none", backgroundColor: "transparent", minHeight: 20 }) }, group: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) }, indicatorSeparator: function (t, e) { return Object(r.a)({}, t, { display: "none" }) }, input: function (t, e) { return Object(r.a)({}, t, { padding: 0, margin: 0 }) }, option: function (t, e) { return Object(r.a)({}, t, { fontSize: "14px" }) }, placeholder: function (t, e) { return Object(r.a)({}, t, { fontSize: "14px" }) }, valueContainer: function (t, e) { return Object(r.a)({}, t, { padding: 0 }) } } }), this.setState({ deviceType: "mobile" })) } }, { key: "onYourEmailChanged", value: function (t) { this.setState({ yourEmail: t.target.value }) } }, { key: "getFeaturedEvents", value: function (t) { return t.map((function (t, e) { return d.a.createElement("div", { key: e, className: "event-item" }, d.a.createElement("img", { src: t.photos[0] }), d.a.createElement("div", { className: "event-item-content" }, d.a.createElement("div", { className: "item-header" }, d.a.createElement("div", { className: "control-btns" }, d.a.createElement("div", { className: "control-share-btn" }), d.a.createElement("div", { className: "control-like-btn" }))), d.a.createElement("div", { className: "event-infos" }, d.a.createElement("div", { className: "event-title" }, t.title), d.a.createElement("div", { className: "event-date" }, t.eventDate), d.a.createElement("div", { className: "event-time" }, t.eventTimeFrom, " + ", t.eventTimeTo)))) })) } }, { key: "render", value: function () { var t = this, e = this.state, i = e.yourEmail; e.deviceType, e.customStylesForSelect, this.props.match.params.search && this.props.match.params.search.split("&"), this.props.featuredArticles; return d.a.createElement("div", { className: "home-page" }, d.a.createElement("div", { className: "search-field" }, d.a.createElement("img", { src: a(700), alt: "banner" }), d.a.createElement("div", { className: "search-field-container" }, d.a.createElement("div", { className: "join-glosfy" }, d.a.createElement("div", { className: "left-side" }, d.a.createElement(T.a, { i18nKey: "title" }), d.a.createElement("span", null, "Discover exatic places, meet new people"), d.a.createElement("span", null, "Create new expereinces, enjoy with your people"), d.a.createElement("span", null, "Browse by your favourite music")), d.a.createElement("div", { className: "right-side" }, "Search events in your favourite city")), d.a.createElement("div", { className: "search-input-section" }, d.a.createElement(l.a, { to: "/register/user", className: "join-btn" }, " Join now"), d.a.createElement("ul", { className: "search-input" }, d.a.createElement("li", null, d.a.createElement(x.a, { placeholder: "Where to?", inputClassName: "form-control form-control-lg", initialValue: this.state.sKey, onChange: function (e) { return t.searchKeyChange(e) }, onKeyDown: function (e) { return t.onSearchKeyDown(e) }, skipSuggest: function (t) { return t.types.indexOf("locality") < 0 || t.types.indexOf("political") < 0 }, onSuggestSelect: function (e) { return t.searchCompanies(e) } })), d.a.createElement("li", null, d.a.createElement("select", { className: "form-control form-control-lg", onChange: function (e) { return t.onChangeDateType(e) } }, this.state.date.indexOf("-") > -1 && d.a.createElement("option", { value: this.state.date, selected: "picked date" == this.state.dateType }, this.state.date), [{ value: "today", label: "Today" }, { value: "this week", label: "This week" }, { value: "next week", label: "Next week" }, { value: "pick up date", label: "Pick up date" }].map((function (e) { return d.a.createElement("option", { value: e.value, key: "dateType" + e.value, selected: t.state.dateType === e.value }, e.label) }))), d.a.createElement("div", { className: v()("w__modal__wrapper", this.state.pickupDate && "opened") }, d.a.createElement("div", { className: "w__modal date__block" }, d.a.createElement("div", { className: "w__modal__header" }, d.a.createElement("h3", null, "Pick up date")), d.a.createElement("div", { className: "w__modal__content" }, d.a.createElement(M.a, { onChange: this.onChange, value: this.state.curDate })), d.a.createElement("div", { className: "w__modal__footer" })))), d.a.createElement("li", null, d.a.createElement("select", { className: "form-control form-control-lg", onChange: function (e) { return t.setState({ category: e.target.value }) } }, d.a.createElement("option", { value: "" }, "Category"), this.props.categories && this.props.categories.map((function (e) { return d.a.createElement("option", { value: e.name, key: "category" + e.name, selected: t.state.category === e.name }, e.name) })))), d.a.createElement("div", { className: "search-btn", onClick: function (e) { return t.filterSearch() } }, d.a.createElement("img", { src: a(701), alt: "arrow_right" })))))), this.props.articleListLoaded && d.a.createElement(h.a, { params: this.props.match.params, local: "local", curCountry: this.state.curCountry, deviceType: this.state.deviceType }), d.a.createElement("div", { className: "subscribe-form" }, d.a.createElement("p", null, "Join Worldsty community!"), d.a.createElement("div", { className: "form-content" }, d.a.createElement("div", { className: "input-content" }, d.a.createElement("input", { placeholder: "Enter your email", value: i, onChange: function (e) { return t.onYourEmailChanged(e) } })), d.a.createElement("div", { className: "subscribe-btn" }, "Subscribe")))) } }]), c }(d.a.Component); e.a = Object(u.b)((function (t) { return Object(r.a)({}, t.home, { articleListLoaded: t.articleList.articleListLoaded, appName: t.common.appName, token: t.common.token, categories: t.common.categories, currentUser: t.common.currentUser }) }), (function (t) { return { onClickCategory: function (e, a, i) { return t({ type: m.c, tag: e, pager: a, payload: i }) }, onLoad: function (e, a, i) { return t({ type: m.t, tab: e, pager: a, payload: i }) }, onUnload: function () { return t({ type: m.u }) } } }))(C) }).call(this, a(31)) }, 646: function (t, e, a) { "use strict"; a(0) }, 648: function (t, e, a) { t.exports = a.p + "static/media/event-img1.9bd6a0b2.png" }, 662: function (t, e, a) { t.exports = a.p + "static/media/iPhone-X.fe429502.png" }, 663: function (t, e, a) { t.exports = a.p + "static/media/googleplay.8dfa4870.png" }, 664: function (t, e) { t.exports = "data:image/png;base64,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" }, 665: function (t, e, a) { "use strict"; a(0), a(8) }, 69: function (t, e, a) { "use strict"; var i = a(11), n = a(12), s = a(15), o = a(14), r = a(0), l = a.n(r), h = a(334), c = a(335), d = a(8), p = a(13), u = a(3), m = a(151), x = a(16), g = a.n(x), b = a(325), y = a.n(b), f = (a(30), function (t) { Object(s.a)(r, t); var e = Object(o.a)(r); function r() { var t; return Object(i.a)(this, r), (t = e.call(this)).state = { share: !1 }, t.handleClick = function (e) { var a = t.props.article; e.preventDefault(), t.props.currentUser ? a.favorited ? t.props.unfavorite(a.slug) : t.props.favorite(a.slug) : t.props.history.push("/login") }, t.wrapTitle = function (t) { return t && t.length > 30 ? t.substring(0, 30) : t }, t.wrapDesc = function (t) { return t && t.length > 65 ? t.substring(0, 65) + "..." : t }, t } return Object(n.a)(r, [{ key: "render", value: function () { var t = this, e = this.props.article, i = e.favorited ? "control-like-btn liked" : "control-like-btn", n = (e.photos && e.photos.length > 0 && e.photos[0], "https://worldsty.com/event/" + e.slug), s = (this.props.event, e.photos && e.photos.length > 0 ? e.photos[0] : ""); return e && "" != s ? l.a.createElement("div", { className: g()("event-item", this.props.className) }, l.a.createElement("img", { src: s }), l.a.createElement("div", { className: "event-item-content" }, l.a.createElement("div", { className: "item-header" }, l.a.createElement("div", { className: "control-btns" }, l.a.createElement("div", { className: "control-share-btn", onClick: function () { return t.setState({ share: !0 }) } }), l.a.createElement("div", { className: i, onClick: this.handleClick }))), l.a.createElement("div", { className: "event-infos" }, l.a.createElement(h.a, { to: "/event/".concat(e.slug), className: "event-title" }, e.title), l.a.createElement("div", { className: "event-date" }, e.eventDate), l.a.createElement("div", { className: "event-time" }, e.eventTimeFrom, " + ", e.eventTimeTo))), l.a.createElement("div", { className: g()("w__modal__wrapper", this.state.share && "opened") }, l.a.createElement("div", { className: "w__modal share__block" }, l.a.createElement("div", { className: "w__modal__header" }, l.a.createElement("h3", null, "Share with friends"), l.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.setState({ share: !1 }) } })), l.a.createElement("div", { className: "w__modal__content" }, l.a.createElement(m.a, { title: e.title, shareLink: n }), l.a.createElement("p", { className: "share__text" }, l.a.createElement("span", null, n), l.a.createElement(y.a, { "data-clipboard-text": n, "button-title": "Copy" }, l.a.createElement("i", { className: "fa fa-clone", "aria-hidden": "true" })))), l.a.createElement("div", { className: "w__modal__footer" })))) : l.a.createElement("div", { className: g()("event-item", this.props.className) }, l.a.createElement("img", { src: a(648) }), l.a.createElement("div", { className: "event-item-content" }, l.a.createElement("div", { className: "item-header" }, l.a.createElement("div", { className: "control-btns" }, l.a.createElement("div", { className: "control-share-btn" }), l.a.createElement("div", { className: "control-like-btn" }))), l.a.createElement("div", { className: "event-infos" }, l.a.createElement("div", { className: "event-title" }, "Cyber Expo Ireland 2019"), l.a.createElement("div", { className: "event-date" }, "Thu, 16 Jan"), l.a.createElement("div", { className: "event-time" }, "10:12 - 12:30"), l.a.createElement("div", { className: "event-description" }, "Our carvery is open Monday- Friday from 12pm- 2.30pm and we offer a \u20ac5 lunch for students (\u20ac7 regular price).")))) } }]), r }(l.a.Component)); e.a = Object(p.b)((function (t) { return { currentUser: t.common.currentUser } }), (function (t) { return { favorite: function (e) { return t({ type: u.e, payload: d.a.Articles.favorite(e) }) }, unfavorite: function (e) { return t({ type: u.j, payload: d.a.Articles.unfavorite(e) }) } } }))(Object(c.a)(f)) }, 699: function (t, e) { t.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAATFJREFUOI2t1b1KA0EUhuEna8g1+Fepd6AWghcRQe211kILxcrYCJpWW72A+HsfimAdOyXXoCBazCxuwiRGNx8sDGfOeXdn58w3lS/LEqqhHp8lTOIDr3jCLe5jrEuVBHAFp5hLvamgNvZxUwxmhfEYTmLCbzAx5zrWjOXBaiHhGHtDgHqV1+zzs+RVtP4BK2oNV5UvyzW8YLok8A0zWSSXhcEU1jOhNUalehWLXaHGJocbw5UfXdK4KEYWMox3Ay9C4t9hMJFJdPuv0DQMobE7yZl+0AEwdDI89/2SXuhgGDxUcSc0dn9oapzW3agbezbflN2SMNjBe+42LTRLwJqR0WVfBzj7B+w81uoFfmJb2KD2EKC24ANbsRZpxyZcAWuCe88LB5/w4x+FK6AlcSi+AYl6TS+bogCNAAAAAElFTkSuQmCC" }, 700: function (t, e, a) { t.exports = a.p + "static/media/home_banner.af64dc10.png" }, 701: function (t, e) { t.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAfCAYAAACPvW/2AAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAAdtJREFUWIXF1r1rFEEYgPHnLmfQLhHPGK1OYiHYWWtjoyFYiB8gKiIWKvhRW9jb+B/YaaExBLTxI0iCEBSs1FqxFCFnFBJiSB6LmyXjcae5Y3fnhReWnZl3f8y8yy4qOeZ+9b56uN8aeWIa6jtbMaMO91OnSn4xCAyF6yPAJFDvuUrOR9ZQX7kRb9SRVEeW5U51LkLNqjtSglDr6osINaPuTgnCVlNPt6HGUoKynYpRL9V9KUGou9RnEeq5OpoSlKGeRqjXdnn7ygKhblefRKi3dmj0MkGoQ/7dU+9tO76yQRnqUYSaV/ekBGV5p22nxlRqwF1gFFgABnL6rnWLanjGJ6AZchg4CDwEblfUVaBWMKRTrANr4dmVcO9DDZgH9gJL0UBRUQ35FVgGDgFbwtgyMFVRG8DWAMrzd6RTDNDalS/ABPAY2AasAJeBB6ka+oT6OTT0b/V8yrfsgroeYc7F42VjrqgrAfNLPdU+p2zMasAsqqc7zSsLcy3amaZ6ttvcMjBX1aWAWVDP/Gt+0Zib0TE11ZP/W1Mk5rq6FmGOb2ZdUZgbbsRPdXyza4vA3Iowi+pEL+vzhNTVexHmu3q01zp5gg6oPwLmm3qsnzp5ggbVi+pH9VK/df4AVAdilkDJVPwAAAAASUVORK5CYII=" }, 745: function (t, e, a) { "use strict"; a.r(e), function (t) { var e = a(48); !function () { function i(t, e) { t.prototype = function (t) { function e() { } return e.prototype = t, new e }(e.prototype), t.prototype.constructor = t, t.base = e.prototype } function n(t, e, a) { return "millisecond" === a ? t.setMilliseconds(t.getMilliseconds() + 1 * e) : "second" === a ? t.setSeconds(t.getSeconds() + 1 * e) : "minute" === a ? t.setMinutes(t.getMinutes() + 1 * e) : "hour" === a ? t.setHours(t.getHours() + 1 * e) : "day" === a ? t.setDate(t.getDate() + 1 * e) : "week" === a ? t.setDate(t.getDate() + 7 * e) : "month" === a ? t.setMonth(t.getMonth() + 1 * e) : "year" === a && t.setFullYear(t.getFullYear() + 1 * e), t } function s(t, e) { var a = !1; for (0 > t && (a = !0, t *= -1), t = "" + t, e = e || 1; t.length < e;)t = "0" + t; return a ? "-" + t : t } function o(t) { if (!t) return t; for (var e = /\s/, a = (t = t.replace(/^\s\s*/, "")).length; e.test(t.charAt(--a));); return t.slice(0, a + 1) } function r(t) { t.roundRect = function (t, e, a, i, n, s, o, r) { o && (this.fillStyle = o), r && (this.strokeStyle = r), "undefined" === typeof n && (n = 5), this.lineWidth = s, this.beginPath(), this.moveTo(t + n, e), this.lineTo(t + a - n, e), this.quadraticCurveTo(t + a, e, t + a, e + n), this.lineTo(t + a, e + i - n), this.quadraticCurveTo(t + a, e + i, t + a - n, e + i), this.lineTo(t + n, e + i), this.quadraticCurveTo(t, e + i, t, e + i - n), this.lineTo(t, e + n), this.quadraticCurveTo(t, e, t + n, e), this.closePath(), o && this.fill(), r && 0 < s && this.stroke() } } function l(t, e) { return t - e } function h(t, e, a) { if (t && e && a) { a = a + "." + e; var i = "image/" + e; t = t.toDataURL(i); var n = !1, s = document.createElement("a"); if (s.download = a, s.href = t, "undefined" !== typeof Blob && new Blob) { for (var o = t.replace(/^data:[a-z\/]*;base64,/, ""), r = (o = atob(o), new ArrayBuffer(o.length)), l = (r = new Uint8Array(r), 0); l < o.length; l++)r[l] = o.charCodeAt(l); e = new Blob([r.buffer], { type: "image/" + e }); try { window.navigator.msSaveBlob(e, a), n = !0 } catch (h) { s.dataset.downloadurl = [i, s.download, s.href].join(":"), s.href = window.URL.createObjectURL(e) } } if (!n) try { event = document.createEvent("MouseEvents"), event.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), s.dispatchEvent ? s.dispatchEvent(event) : s.fireEvent && s.fireEvent("onclick") } catch (K) { (e = window.open()).document.write("<img src='" + t + "'></img><div>Please right click on the image and save it to your device</div>"), e.document.close() } } } function c(t) { var e = ((16711680 & t) >> 16).toString(16), a = ((65280 & t) >> 8).toString(16); return t = ((255 & t) >> 0).toString(16), "#" + (e = 2 > e.length ? "0" + e : e) + (a = 2 > a.length ? "0" + a : a) + (t = 2 > t.length ? "0" + t : t) } function d(t, e) { var a, i = this.length >>> 0; for (0 > (a = 0 > (a = Number(e) || 0) ? Math.ceil(a) : Math.floor(a)) && (a += i); a < i; a++)if (a in this && this[a] === t) return a; return -1 } function p(t) { return null === t || "undefined" === typeof t } function u(t) { return t.indexOf || (t.indexOf = d), t } function m(t) { X.fSDec && t[pt("`eeDwdouMhrudods")](pt("e`u`@ohl`uhnoHuds`uhnoDoe"), (function () { X._fTWm && X._fTWm(t) })) } function x(t, e, a) { var i = t + "_" + e + "_" + (a = a || "normal"), n = tt[i]; if (isNaN(n)) { try { if (t = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + t + "; font-size:" + e + "px; font-weight:" + a + ";", !et) { var s = document.body; (et = document.createElement("span")).innerHTML = ""; var o = document.createTextNode("Mpgyi"); et.appendChild(o), s.appendChild(et) } et.style.display = "", et.setAttribute("style", t), n = Math.round(et.offsetHeight), et.style.display = "none" } catch (r) { n = Math.ceil(1.1 * e) } n = Math.max(n, e), tt[i] = n } return n } function g(t, e) { var a = []; if (a = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[t || "solid"]) for (var i = 0; i < a.length; i++)a[i] *= e; else a = []; return a } function b(t, e, a, i, n) { return n = n || !1, (i = i || []).push([t, e, a, n]), t.addEventListener ? (t.addEventListener(e, a, n), a) : !!t.attachEvent && (i = function (e) { (e = e || window.event).preventDefault = e.preventDefault || function () { e.returnValue = !1 }, e.stopPropagation = e.stopPropagation || function () { e.cancelBubble = !0 }, a.call(t, e) }, t.attachEvent("on" + e, i), i) } function y(t, e, a) { for (t *= ct, e *= ct, t = a.getImageData(t, e, 2, 2).data, e = !0, a = 0; 4 > a; a++)if (t[a] !== t[a + 4] | t[a] !== t[a + 8] | t[a] !== t[a + 12]) { e = !1; break } return e ? t[0] << 16 | t[1] << 8 | t[2] : 0 } function f(t, e, a) { return t in e ? e[t] : a[t] } function v(t, e, a) { if (Y && rt) { var i = t.getContext("2d"); ht = i.webkitBackingStorePixelRatio || i.mozBackingStorePixelRatio || i.msBackingStorePixelRatio || i.oBackingStorePixelRatio || i.backingStorePixelRatio || 1, ct = lt / ht, t.width = e * ct, t.height = a * ct, lt !== ht && (t.style.width = e + "px", t.style.height = a + "px", i.scale(ct, ct)) } else t.width = e, t.height = a } function k(t) { if (!mt) { var e = !1, a = !1; "undefined" === typeof R.Chart.creditHref ? (t.creditHref = pt("iuuqr;..b`ow`rkr/bnl."), t.creditText = pt("B`ow`rKR/bnl")) : (e = t.updateOption("creditText"), a = t.updateOption("creditHref")), t.creditHref && t.creditText && (t._creditLink || (t._creditLink = document.createElement("a"), t._creditLink.setAttribute("class", "canvasjs-chart-credit"), t._creditLink.setAttribute("title", "JavaScript Charts"), t._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (t.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"), t._creditLink.setAttribute("tabIndex", -1), t._creditLink.setAttribute("target", "_blank")), (0 === t.renderCount || e || a) && (t._creditLink.setAttribute("href", t.creditHref), t._creditLink.innerHTML = t.creditText), t._creditLink && t.creditHref && t.creditText ? (t._creditLink.parentElement || t._canvasJSContainer.appendChild(t._creditLink), t._creditLink.style.top = t.height - 14 + "px") : t._creditLink.parentElement && t._canvasJSContainer.removeChild(t._creditLink)) } } function M(t, e) { O && (this.canvasCount |= 0, window.console.log(++this.canvasCount)); var a = document.createElement("canvas"); return a.setAttribute("class", "canvasjs-chart-canvas"), v(a, t, e), Y || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(a), a } function T(t, e, a) { for (var i in a) e.style[i] = a[i] } function w(t, e, a) { e.getAttribute("state") || (e.style.backgroundColor = t.toolbar.backgroundColor, e.style.color = t.toolbar.fontColor, e.style.border = "none", T(0, e, { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" })), e.getAttribute("state") !== a && (e.setAttribute("state", a), e.setAttribute("type", "button"), T(0, e, { padding: "5px 12px", cursor: "pointer", float: "left", width: "40px", height: "25px", outline: "0px", verticalAlign: "baseline", lineHeight: "0" }), e.setAttribute("title", t._cultureInfo[a + "Text"]), e.innerHTML = "<img style='height:95%; pointer-events: none;' src='" + xt[a].image + "' alt='" + t._cultureInfo[a + "Text"] + "' />") } function P() { for (var t = null, e = 0; e < arguments.length; e++)(t = arguments[e]).style && (t.style.display = "inline") } function C() { for (var t = null, e = 0; e < arguments.length; e++)(t = arguments[e]) && t.style && (t.style.display = "none") } function S(t, e, a, i, n) { this._defaultsKey = t, this._themeOptionsKey = e, this._index = i, this.parent = n, this._eventListeners = [], t = {}, this.theme && p(e) && p(i) ? t = p(Q[this.theme]) ? Q.light1 : Q[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[e] && (null === i ? t = this.parent.themeOptions[e] : 0 < this.parent.themeOptions[e].length && (i = Math.min(this.parent.themeOptions[e].length - 1, i), t = this.parent.themeOptions[e][i])), this.themeOptions = t, this.options = a || { _isPlaceholder: !0 }, this.setOptions(this.options, t) } function A(t, e, a, i, n) { "undefined" === typeof n && (n = 0), this._padding = n, this._x1 = t, this._y1 = e, this._x2 = a, this._y2 = i, this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding } function E(t, e) { E.base.constructor.call(this, "TextBlock", null, e, null, null), this.ctx = t, this._isDirty = !0, this._wrappedText = null, this._initialize() } function _(t, e) { _.base.constructor.call(this, "Toolbar", "toolbar", e, null, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.optionsName = "toolbar" } function F(t, e) { if (F.base.constructor.call(this, "Title", "title", e, null, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.optionsName = "title", p(this.options.margin) && t.options.subtitles) for (var a = t.options.subtitles, i = 0; i < a.length; i++)if ((p(a[i].horizontalAlign) && "center" === this.horizontalAlign || a[i].horizontalAlign === this.horizontalAlign) && (p(a[i].verticalAlign) && "top" === this.verticalAlign || a[i].verticalAlign === this.verticalAlign) && !a[i].dockInsidePlotArea === !this.dockInsidePlotArea) { this.margin = 0; break } "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = { x1: null, y1: null, x2: null, y2: null } } function B(t, e, a) { B.base.constructor.call(this, "Subtitle", "subtitles", e, a, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.optionsName = "subtitles", this.isOptionsInArray = !0, "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = { x1: null, y1: null, x2: null, y2: null } } function L() { this.pool = [] } function I(t) { var e; t && j[t] && (e = j[t]), I.base.constructor.call(this, "CultureInfo", null, e, null, null) } var D, N, V, W, z, O = !1, X = {}, Y = !!document.createElement("canvas").getContext, R = { Chart: { width: 500, height: 400, zoomEnabled: !1, zoomType: "x", backgroundColor: "white", theme: "light1", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: "colorSet1", culture: "en", creditHref: "", creditText: "CanvasJS", interactivityEnabled: !0, exportEnabled: !1, exportFileName: "Chart", rangeChanging: null, rangeChanged: null, publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly" } }, Title: { padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 20, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: Y ? "transparent" : null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" } }, Subtitle: { padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 14, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" } }, Toolbar: { backgroundColor: "white", backgroundColorOnHover: "#2196f3", borderColor: "#2196f3", borderThickness: 1, fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" } }, Legend: { name: null, verticalAlign: "center", horizontalAlign: "right", fontSize: 14, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", cursor: null, itemmouseover: null, itemmouseout: null, itemmousemove: null, itemclick: null, dockInsidePlotArea: !1, reversed: !1, backgroundColor: Y ? "transparent" : null, borderColor: Y ? "transparent" : null, borderThickness: 0, cornerRadius: 0, maxWidth: null, maxHeight: null, markerMargin: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" } }, ToolTip: { enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: Y ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", borderColor: null, borderThickness: 2, cornerRadius: 5, fontSize: 14, fontColor: "black", fontFamily: "Calibri, Arial, Georgia, serif;", fontWeight: "normal", fontStyle: "italic", publicProperties: { options: "readWrite", chart: "readOnly" } }, Axis: { minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: "black", titleFontSize: 20, titleFontFamily: "arial", titleFontWeight: "normal", titleFontStyle: "normal", titleWrap: !0, titleMaxWidth: null, titleBackgroundColor: Y ? "transparent" : null, titleBorderColor: Y ? "transparent" : null, titleBorderThickness: 0, titleCornerRadius: 0, labelAngle: 0, labelFontFamily: "arial", labelFontColor: "black", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, labelBackgroundColor: Y ? "transparent" : null, labelBorderColor: Y ? "transparent" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelPlacement: "outside", prefix: "", suffix: "", includeZero: !0, tickLength: 5, tickColor: "black", tickThickness: 1, lineColor: "black", lineThickness: 1, lineDashType: "solid", gridColor: "A0A0A0", gridThickness: 0, gridDashType: "solid", interlacedColor: Y ? "transparent" : null, valueFormatString: null, margin: 2, publicProperties: { options: "readWrite", stripLines: "readWrite", scaleBreaks: "readWrite", crosshair: "readWrite", bounds: "readOnly", chart: "readOnly" } }, StripLine: { value: null, startValue: null, endValue: null, color: "orange", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelPlacement: "inside", labelAlign: "far", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: Y ? "transparent" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: "arial", labelFontColor: "orange", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, showOnTop: !1, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" } }, ScaleBreaks: { autoCalculate: !1, collapsibleThreshold: "25%", maxNumberOfAutoBreaks: 2, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: .9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", customBreaks: "readWrite", axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Break: { startValue: null, endValue: null, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: .9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Crosshair: { enabled: !1, snapToDataPoint: !1, color: "grey", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: Y ? "grey" : null, labelBorderColor: Y ? "grey" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: Y ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 12, labelFontColor: "#fff", labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, valueFormatString: null, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" } }, DataSeries: { name: null, dataPoints: null, label: "", bevelEnabled: !1, highlightEnabled: !0, cursor: "default", indexLabel: "", indexLabelPlacement: "auto", indexLabelOrientation: "horizontal", indexLabelFontColor: "black", indexLabelFontSize: 12, indexLabelFontStyle: "normal", indexLabelFontFamily: "Arial", indexLabelFontWeight: "normal", indexLabelBackgroundColor: null, indexLabelLineColor: "gray", indexLabelLineThickness: 1, indexLabelLineDashType: "solid", indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null, lineThickness: 2, lineDashType: "solid", connectNullData: !1, nullDataLineDashType: "dash", color: null, lineColor: null, risingColor: "white", fallingColor: "red", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, neckHeight: null, neckWidth: null, reversed: !1, valueRepresents: null, linkedDataSeriesIndex: null, whiskerThickness: 2, whiskerDashType: "solid", whiskerColor: null, whiskerLength: null, stemThickness: 2, stemColor: null, stemDashType: "solid", upperBoxColor: "white", lowerBoxColor: "white", type: "column", xValueType: "number", axisXType: "primary", axisYType: "primary", axisXIndex: 0, axisYIndex: 0, xValueFormatString: null, yValueFormatString: null, zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: Y ? "transparent" : null, legendMarkerBorderThickness: 0, markerType: "circle", markerColor: null, markerSize: null, markerBorderColor: Y ? "transparent" : null, markerBorderThickness: 0, mouseover: null, mouseout: null, mousemove: null, click: null, toolTipContent: null, visible: !0, publicProperties: { options: "readWrite", axisX: "readWrite", axisY: "readWrite", chart: "readOnly" } }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: "", horizontalAlign: "center", fontSize: 12, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, textBaseline: "top" }, CultureInfo: { decimalSeparator: ".", digitGroupSeparator: ",", zoomText: "Zoom", panText: "Pan", resetText: "Reset", menuText: "More Options", saveJPGText: "Save as JPEG", savePNGText: "Save as PNG", printText: "Print", days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "), months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ") } }, j = { en: {} }, U = Y ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", H = Y ? "Impact, Charcoal, sans-serif" : "Arial", q = { colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "), colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "), colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ") }, G = { colorSet: "colorSet1", backgroundColor: "#FFFFFF", title: { fontFamily: H, fontSize: 32, fontColor: N = "#333333", fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: H, fontSize: K = 14, fontColor: N, fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: U, indexLabelFontSize: K, indexLabelFontColor: N, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: U, titleFontSize: J = 20, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V = "#000000", labelFontWeight: "normal", lineThickness: 1, lineColor: D = "#666666", tickThickness: 1, tickColor: D, gridThickness: 0, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: z = W = "#000000", color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisX2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 0, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 1, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 1, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], legend: { fontFamily: U, fontSize: 14, fontColor: N, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: U, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 } }; V = N = "#F5F5F5", D = "#FFFFFF", W = "#40BAF1", z = "#F5F5F5"; var Z = { colorSet: "colorSet2", title: { fontFamily: U, fontSize: 33, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: U, fontSize: K = 14, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: U, indexLabelFontSize: K, indexLabelFontColor: "#666666", indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: U, titleFontSize: J = 20, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickThickness: 1, tickColor: "#BBBBBB", gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisX2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], legend: { fontFamily: U, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: U, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 } }; V = N = "#F5F5F5", H = { colorSet: "colorSet12", backgroundColor: "#2A2A2A", title: { fontFamily: H, fontSize: 32, fontColor: N, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: H, fontSize: K = 14, fontColor: N, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{ indexLabelFontFamily: U, indexLabelFontSize: K, indexLabelFontColor: V, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: U, titleFontSize: J = 20, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D = "#FFFFFF", tickThickness: 1, tickColor: D, gridThickness: 0, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z = "#F5F5F5", color: W = "#40BAF1", thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisX2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 0, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 1, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 1, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], legend: { fontFamily: U, fontSize: 14, fontColor: N, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: U, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: V, backgroundColor: "rgba(0, 0, 0, .7)" } }, V = N = "#FAFAFA"; var J, K, Q = { light1: G, light2: Z, dark1: H, dark2: { colorSet: "colorSet2", backgroundColor: "#32373A", title: { fontFamily: U, fontSize: 32, fontColor: N, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: U, fontSize: K = 14, fontColor: N, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{ indexLabelFontFamily: U, indexLabelFontSize: K, indexLabelFontColor: V, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: U, titleFontSize: J = 20, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D = "#FFFFFF", tickThickness: 1, tickColor: D, gridThickness: 0, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z = "#F5F5F5", color: W = "#40BAF1", thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisX2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 0, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 0, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 1, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY2: [{ titleFontFamily: U, titleFontSize: J, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: U, labelFontSize: K, labelFontColor: V, labelFontWeight: "normal", lineThickness: 0, lineColor: D, tickThickness: 1, tickColor: D, gridThickness: 1, gridColor: D, stripLines: [{ labelFontFamily: U, labelFontSize: K, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: U, labelFontSize: K, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: z, color: W, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], legend: { fontFamily: U, fontSize: 14, fontColor: N, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: U, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: V, backgroundColor: "rgba(0, 0, 0, .7)" } }, theme1: G, theme2: Z, theme3: G }, $ = { numberDuration: 1, yearDuration: 314496e5, monthDuration: 2592e6, weekDuration: 6048e5, dayDuration: 864e5, hourDuration: 36e5, minuteDuration: 6e4, secondDuration: 1e3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") }; X.fSDec = function (t) { for (var e = "", a = 0; a < t.length; a++)e += String.fromCharCode(Math.ceil(t.length / 57 / 5) ^ t.charCodeAt(a)); return e }, X.obj = { trVs: "Ush`m!Wdsrhno", fntStr: "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg", txtBl: "udyuC`rdmhod", fnt: "gnou", fSy: "ghmmRuxmd", fTx: "ghmmUdyu", grClr: "fsdx", cntx: "buy", tp: "unq" }, delete R[X.fSDec("Bi`su")][X.fSDec("bsdehuIsdg")], X.pro = { sCH: R[X.fSDec("Bi`su")][X.fSDec("bsdehuIsdg")] }, X._fTWm = function (t) { if ("undefined" === typeof X.pro.sCH && !ut) try { var e = t[X.fSDec(X.obj.cntx)]; e[X.fSDec(X.obj.txtBl)] = X.fSDec(X.obj.tp), e[X.fSDec(X.obj.fnt)] = 11 + X.fSDec(X.obj.fntStr), e[X.fSDec(X.obj.fSy)] = X.fSDec(X.obj.grClr), e[X.fSDec(X.obj.fTx)](X.fSDec(X.obj.trVs), 2, t.height - 11 - 2) } catch (Y) { } }; var tt = {}, et = null, at = function () { this.ctx.clearRect(0, 0, this.width, this.height), this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height)) }, it = function (t, e, a) { return e = Math.min(this.width, this.height), Math.max("theme4" === this.theme ? 0 : 300 <= e ? 12 : 10, Math.round(e * (t / 400))) }, nt = function () { var t = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, e = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), a = "Sun Mon Tue Wed Thu Fri Sat".split(" "), i = "January February March April May June July August September October November December".split(" "), n = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), o = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, r = /[^-+\dA-Z]/g; return function (l, h, c) { var d = c ? c.days : e, p = c ? c.months : i, u = c ? c.shortDays : a, m = c ? c.shortMonths : n; c = ""; var x = !1; if (l = l && l.getTime ? l : l ? new Date(l) : new Date, isNaN(l)) throw SyntaxError("invalid date"); "UTC:" === h.slice(0, 4) && (h = h.slice(4), x = !0); var g = l[(c = x ? "getUTC" : "get") + "Date"](), b = l[c + "Day"](), y = l[c + "Month"](), f = l[c + "FullYear"](), v = l[c + "Hours"](), k = l[c + "Minutes"](), M = l[c + "Seconds"](), T = l[c + "Milliseconds"](), w = x ? 0 : l.getTimezoneOffset(); return h.replace(t, (function (t) { switch (t) { case "D": return g; case "DD": return s(g, 2); case "DDD": return u[b]; case "DDDD": return d[b]; case "M": return y + 1; case "MM": return s(y + 1, 2); case "MMM": return m[y]; case "MMMM": return p[y]; case "Y": return parseInt(String(f).slice(-2)); case "YY": return s(String(f).slice(-2), 2); case "YYY": return s(String(f).slice(-3), 3); case "YYYY": return s(f, 4); case "h": return v % 12 || 12; case "hh": return s(v % 12 || 12, 2); case "H": return v; case "HH": return s(v, 2); case "m": return k; case "mm": return s(k, 2); case "s": return M; case "ss": return s(M, 2); case "f": return String(T).slice(0, 1); case "ff": return s(String(T).slice(0, 2), 2); case "fff": return s(String(T).slice(0, 3), 3); case "t": return 12 > v ? "a" : "p"; case "tt": return 12 > v ? "am" : "pm"; case "T": return 12 > v ? "A" : "P"; case "TT": return 12 > v ? "AM" : "PM"; case "K": return x ? "UTC" : (String(l).match(o) || [""]).pop().replace(r, ""); case "z": return (0 < w ? "-" : "+") + Math.floor(Math.abs(w) / 60); case "zz": return (0 < w ? "-" : "+") + s(Math.floor(Math.abs(w) / 60), 2); case "zzz": return (0 < w ? "-" : "+") + s(Math.floor(Math.abs(w) / 60), 2) + s(Math.abs(w) % 60, 2); default: return t.slice(1, t.length - 1) } })) } }(), st = function (t, e, a) { if (null === t) return ""; if (!isFinite(t)) return t; var i = 0 > (t = Number(t)); i && (t *= -1); var n = a ? a.decimalSeparator : ".", o = a ? a.digitGroupSeparator : ",", r = ""; e = String(e); r = 1; var l = a = "", h = -1, c = [], d = [], p = 0, u = 0, m = 0, x = !1, g = 0; l = e.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g); e = null; for (var b = 0; l && b < l.length; b++)if ("." === (e = l[b]) && 0 > h) h = b; else { if ("%" === e) r *= 100; else { if ("\u2030" === e) { r *= 1e3; continue } if ("," === e[0] && "." === e[e.length - 1]) { r /= Math.pow(1e3, e.length - 1), h = b + e.length - 1; continue } "E" !== e[0] && "e" !== e[0] || "0" !== e[e.length - 1] || (x = !0) } 0 > h ? (c.push(e), "#" === e || "0" === e ? p++ : "," === e && m++) : (d.push(e), "#" !== e && "0" !== e || u++) } for (x && (e = Math.floor(t), l = -Math.floor(Math.log(t) / Math.LN10 + 1), g = 0 === t ? 0 : 0 === e ? -(p + l) : String(e).length - p, r /= Math.pow(10, g)), 0 > h && (h = b), e = (r = (t * r).toFixed(u)).split("."), r = (e[0] + "").split(""), t = (e[1] + "").split(""), r && "0" === r[0] && r.shift(), x = l = b = u = h = 0; 0 < c.length;)if ("#" === (e = c.pop()) || "0" === e) if (++h === p) { var y = r; r = []; if ("0" === e) for (e = p - u - (y ? y.length : 0); 0 < e;)y.unshift("0"), e--; for (; 0 < y.length;)a = y.pop() + a, 0 === ++x % l && b === m && 0 < y.length && (a = o + a) } else 0 < r.length ? (a = r.pop() + a, u++, x++) : "0" === e && (a = "0" + a, u++, x++), 0 === x % l && b === m && 0 < r.length && (a = o + a); else "E" !== e[0] && "e" !== e[0] || "0" !== e[e.length - 1] || !/[eE][+-]*[0]+/.test(e) ? "," === e ? (b++, l = x, x = 0, 0 < r.length && (a = o + a)) : a = 1 < e.length && ('"' === e[0] && '"' === e[e.length - 1] || "'" === e[0] && "'" === e[e.length - 1]) ? e.slice(1, e.length - 1) + a : e + a : a += (e = 0 > g ? e.replace("+", "").replace("-", "") : e.replace("-", "")).replace(/[0]+/, (function (t) { return s(g, t.length) })); for (o = "", c = !1; 0 < d.length;)"#" === (e = d.shift()) || "0" === e ? 0 < t.length && 0 !== Number(t.join("")) ? (o += t.shift(), c = !0) : "0" === e && (o += "0", c = !0) : 1 < e.length && ('"' === e[0] && '"' === e[e.length - 1] || "'" === e[0] && "'" === e[e.length - 1]) ? o += e.slice(1, e.length - 1) : "E" !== e[0] && "e" !== e[0] || "0" !== e[e.length - 1] || !/[eE][+-]*[0]+/.test(e) ? o += e : o += (e = 0 > g ? e.replace("+", "").replace("-", "") : e.replace("-", "")).replace(/[0]+/, (function (t) { return s(g, t.length) })); return a += (c ? n : "") + o, i ? "-" + a : a }, ot = function (t) { var e = 0, a = 0; return (t = t || window.event).offsetX || 0 === t.offsetX ? (e = t.offsetX, a = t.offsetY) : t.layerX || 0 == t.layerX ? (e = t.layerX, a = t.layerY) : (e = t.pageX - t.target.offsetLeft, a = t.pageY - t.target.offsetTop), { x: e, y: a } }, rt = !0, lt = window.devicePixelRatio || 1, ht = 1, ct = rt ? lt / ht : 1, dt = function (t, e, a, i, n, s, o, r, l, h, c, d, p) { "undefined" === typeof p && (p = 1), o = o || 0, r = r || "black"; var u = 15 < i - e && 15 < n - a ? 8 : .35 * Math.min(i - e, n - a); t.beginPath(), t.moveTo(e, a), t.save(), t.fillStyle = s, t.globalAlpha = p, t.fillRect(e, a, i - e, n - a), t.globalAlpha = 1, 0 < o && (p = 0 === o % 2 ? 0 : .5, t.beginPath(), t.lineWidth = o, t.strokeStyle = r, t.moveTo(e, a), t.rect(e - p, a - p, i - e + 2 * p, n - a + 2 * p), t.stroke()), t.restore(), !0 === l && (t.save(), t.beginPath(), t.moveTo(e, a), t.lineTo(e + u, a + u), t.lineTo(i - u, a + u), t.lineTo(i, a), t.closePath(), (o = t.createLinearGradient((i + e) / 2, a + u, (i + e) / 2, a)).addColorStop(0, s), o.addColorStop(1, "rgba(255, 255, 255, .4)"), t.fillStyle = o, t.fill(), t.restore()), !0 === h && (t.save(), t.beginPath(), t.moveTo(e, n), t.lineTo(e + u, n - u), t.lineTo(i - u, n - u), t.lineTo(i, n), t.closePath(), (o = t.createLinearGradient((i + e) / 2, n - u, (i + e) / 2, n)).addColorStop(0, s), o.addColorStop(1, "rgba(255, 255, 255, .4)"), t.fillStyle = o, t.fill(), t.restore()), !0 === c && (t.save(), t.beginPath(), t.moveTo(e, a), t.lineTo(e + u, a + u), t.lineTo(e + u, n - u), t.lineTo(e, n), t.closePath(), (o = t.createLinearGradient(e + u, (n + a) / 2, e, (n + a) / 2)).addColorStop(0, s), o.addColorStop(1, "rgba(255, 255, 255, 0.1)"), t.fillStyle = o, t.fill(), t.restore()), !0 === d && (t.save(), t.beginPath(), t.moveTo(i, a), t.lineTo(i - u, a + u), t.lineTo(i - u, n - u), t.lineTo(i, n), (o = t.createLinearGradient(i - u, (n + a) / 2, i, (n + a) / 2)).addColorStop(0, s), o.addColorStop(1, "rgba(255, 255, 255, 0.1)"), t.fillStyle = o, o.addColorStop(0, s), o.addColorStop(1, "rgba(255, 255, 255, 0.1)"), t.fillStyle = o, t.fill(), t.closePath(), t.restore()) }, pt = function (t) { for (var e = "", a = 0; a < t.length; a++)e += String.fromCharCode(Math.ceil(t.length / 57 / 5) ^ t.charCodeAt(a)); return e }, ut = window && window[pt("mnb`uhno")] && window[pt("mnb`uhno")].href && window[pt("mnb`uhno")].href.indexOf && (-1 !== window[pt("mnb`uhno")].href.indexOf(pt("b`ow`rkr/bnl")) || -1 !== window[pt("mnb`uhno")].href.indexOf(pt("gdonqhy/bnl")) || -1 !== window[pt("mnb`uhno")].href.indexOf(pt("gheemd"))), mt = ut && -1 === window[pt("mnb`uhno")].href.indexOf(pt("gheemd")), xt = { reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" }, pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" }, zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" }, menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" }, handle: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAAzwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7sqSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=" } }; S.prototype.setOptions = function (t, e) { if (R[this._defaultsKey]) { var a, i = R[this._defaultsKey]; for (a in i) "publicProperties" !== a && i.hasOwnProperty(a) && (this[a] = t && a in t ? t[a] : e && a in e ? e[a] : i[a]) } else O && window.console && console.log("defaults not set") }, S.prototype.get = function (t) { var e = R[this._defaultsKey]; return "options" === t ? this.options && this.options._isPlaceholder ? null : this.options : e.hasOwnProperty(t) || e.publicProperties && e.publicProperties.hasOwnProperty(t) ? this[t] : void (window.console && window.console.log('Property "' + t + "\" doesn't exist. Please check for typo.")) }, S.prototype.set = function (t, e, a) { a = "undefined" === typeof a || a; var i = R[this._defaultsKey]; if ("options" === t) this.createUserOptions(e); else { if (!(i.hasOwnProperty(t) || i.publicProperties && i.publicProperties.hasOwnProperty(t) && "readWrite" === i.publicProperties[t])) return void (window.console && (i.publicProperties && i.publicProperties.hasOwnProperty(t) && "readOnly" === i.publicProperties[t] ? window.console.log('Property "' + t + '" is read-only.') : window.console.log('Property "' + t + "\" doesn't exist. Please check for typo."))); this.options._isPlaceholder && this.createUserOptions(), this.options[t] = e } a && (this.stockChart || this.chart || this).render() }, S.prototype.addTo = function (t, e, a, i) { i = "undefined" === typeof i || i; var n = R[this._defaultsKey]; n.hasOwnProperty(t) || n.publicProperties && n.publicProperties.hasOwnProperty(t) && "readWrite" === n.publicProperties[t] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[t] && (this.options[t] = []), t = this.options[t], a = "undefined" === typeof a || null === a ? t.length : a, t.splice(a, 0, e), i && (this.chart || this).render()) : window.console && (n.publicProperties && n.publicProperties.hasOwnProperty(t) && "readOnly" === n.publicProperties[t] ? window.console.log('Property "' + t + '" is read-only.') : window.console.log('Property "' + t + "\" doesn't exist. Please check for typo.")) }, S.prototype.createUserOptions = function (t) { if ("undefined" !== typeof t || this.options._isPlaceholder) if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) { this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []); var e = this.parent.options[this.optionsName], a = e.length; this.options._isPlaceholder || (u(e), a = e.indexOf(this.options)), this.options = "undefined" === typeof t ? {} : t, e[a] = this.options } else this.options = "undefined" === typeof t ? {} : t, t = this.parent.options, this.optionsName ? e = this.optionsName : (e = this._defaultsKey) && 0 !== e.length ? (a = e.charAt(0).toLowerCase(), 1 < e.length && (a = a.concat(e.slice(1))), e = a) : e = void 0, t[e] = this.options }, S.prototype.remove = function (t) { if (t = "undefined" === typeof t || t, this.isOptionsInArray) { var e = this.parent.options[this.optionsName]; u(e); var a = e.indexOf(this.options); 0 <= a && e.splice(a, 1) } else delete this.parent.options[this.optionsName]; t && (this.chart || this).render() }, S.prototype.updateOption = function (t) { !R[this._defaultsKey] && O && window.console && console.log("defaults not set"); var e = R[this._defaultsKey], a = {}, i = this[t], n = this._themeOptionsKey, s = this._index; return this.theme && p(n) && p(s) ? a = p(Q[this.theme]) ? Q.light1 : Q[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[n] && (null === s ? a = this.parent.themeOptions[n] : 0 < this.parent.themeOptions[n].length && (a = Math.min(this.parent.themeOptions[n].length - 1, s), a = this.parent.themeOptions[n][a])), this.themeOptions = a, t in e && (i = t in this.options ? this.options[t] : a && t in a ? a[t] : e[t]), i !== this[t] && (this[t] = i, !0) }, S.prototype.trackChanges = function (t) { if (!this.sessionVariables) throw "Session Variable Store not set"; this.sessionVariables[t] = this.options[t] }, S.prototype.isBeingTracked = function (t) { return this.options._oldOptions || (this.options._oldOptions = {}), !!this.options._oldOptions[t] }, S.prototype.hasOptionChanged = function (t) { if (!this.sessionVariables) throw "Session Variable Store not set"; return this.sessionVariables[t] !== this.options[t] }, S.prototype.addEventListener = function (t, e, a) { t && e && (this._eventListeners[t] = this._eventListeners[t] || [], this._eventListeners[t].push({ context: a || this, eventHandler: e })) }, S.prototype.removeEventListener = function (t, e) { if (t && e && this._eventListeners[t]) for (var a = this._eventListeners[t], i = 0; i < a.length; i++)if (a[i].eventHandler === e) { a[i].splice(i, 1); break } }, S.prototype.removeAllEventListeners = function () { this._eventListeners = [] }, S.prototype.dispatchEvent = function (t, e, a) { if (t && this._eventListeners[t]) { e = e || {}; for (var i = this._eventListeners[t], n = 0; n < i.length; n++)i[n].eventHandler.call(i[n].context, e) } "function" === typeof this[t] && this[t].call(a || this.chart, e) }, A.prototype.registerSpace = function (t, e) { "top" === t ? this._topOccupied += e.height : "bottom" === t ? this._bottomOccupied += e.height : "left" === t ? this._leftOccupied += e.width : "right" === t && (this._rightOccupied += e.width) }, A.prototype.unRegisterSpace = function (t, e) { "top" === t ? this._topOccupied -= e.height : "bottom" === t ? this._bottomOccupied -= e.height : "left" === t ? this._leftOccupied -= e.width : "right" === t && (this._rightOccupied -= e.width) }, A.prototype.getFreeSpace = function () { return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied } }, A.prototype.reset = function () { this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding }, i(E, S), E.prototype._initialize = function () { p(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = 0 | Number(this.padding) : (this.topPadding = p(this.padding.top) ? 0 : 0 | Number(this.padding.top), this.rightPadding = p(this.padding.right) ? 0 : 0 | Number(this.padding.right), this.bottomPadding = p(this.padding.bottom) ? 0 : 0 | Number(this.padding.bottom), this.leftPadding = p(this.padding.left) ? 0 : 0 | Number(this.padding.left)) }, E.prototype.render = function (t) { if (0 !== this.fontSize) { t && this.ctx.save(); var e = this.ctx.font; this.ctx.textBaseline = this.textBaseline; var a = 0; this._isDirty && this.measureText(this.ctx), this.ctx.translate(this.x, this.y + a), "middle" === this.textBaseline && (a = -this._lineHeight / 2), this.ctx.font = this._getFontString(), this.ctx.rotate(Math.PI / 180 * this.angle); var i = 0, n = this.topPadding, s = null; for (this.ctx.roundRect || r(this.ctx), (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, a, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor), this.ctx.fillStyle = this.fontColor, a = 0; a < this._wrappedText.lines.length; a++)s = this._wrappedText.lines[a], "right" === this.horizontalAlign ? i = (this.width - (this.leftPadding + this.rightPadding)) / 2 - s.width / 2 + this.leftPadding : "left" === this.horizontalAlign ? i = this.leftPadding : "center" === this.horizontalAlign && (i = (this.width - (this.leftPadding + this.rightPadding)) / 2 - s.width / 2 + this.leftPadding), this.ctx.fillText(s.text, i, n), n += s.height; this.ctx.font = e, t && this.ctx.restore() } }, E.prototype.setText = function (t) { this.text = t, this._isDirty = !0, this._wrappedText = null }, E.prototype.measureText = function () { if (this._lineHeight = x(this.fontFamily, this.fontSize, this.fontWeight), null === this.maxWidth) throw "Please set maxWidth and height for TextBlock"; return this._wrapText(this.ctx), this._isDirty = !1, { width: this.width, height: this.height } }, E.prototype._getLineWithWidth = function (t, e, a) { if (!(t = String(t))) return { text: "", width: 0 }; var i = a = 0, n = t.length - 1, s = 1 / 0; for (this.ctx.font = this._getFontString(); i <= n;) { s = Math.floor((i + n) / 2); var o = t.substr(0, s + 1); if ((a = this.ctx.measureText(o).width) < e) i = s + 1; else { if (!(a > e)) break; n = s - 1 } } return a > e && 1 < o.length && (o = o.substr(0, o.length - 1), a = this.ctx.measureText(o).width), e = !0, o.length !== t.length && " " !== t[o.length] || (e = !1), e && (1 < (t = o.split(" ")).length && t.pop(), o = t.join(" "), a = this.ctx.measureText(o).width), { text: o, width: a } }, E.prototype._wrapText = function () { var t = new String(o(String(this.text))), e = [], a = this.ctx.font, i = 0, n = 0; if (this.ctx.font = this._getFontString(), 0 === this.frontSize) n = i = 0; else for (; 0 < t.length;) { var s = this.maxHeight - (this.topPadding + this.bottomPadding), r = this._getLineWithWidth(t, this.maxWidth - (this.leftPadding + this.rightPadding), !1); r.height = this._lineHeight, e.push(r); var l = n; n = Math.max(n, r.width), i = i + r.height, t = o(t.slice(r.text.length, t.length)); s && i > s && (i -= (r = e.pop()).height, n = l) } this._wrappedText = { lines: e, width: n, height: i }, this.width = n + (this.leftPadding + this.rightPadding), this.height = i + (this.topPadding + this.bottomPadding), this.ctx.font = a }, E.prototype._getFontString = function () { var t; t = this.fontStyle ? this.fontStyle + " " : "", t += this.fontWeight ? this.fontWeight + " " : "", t += this.fontSize ? this.fontSize + "px " : ""; var e = this.fontFamily ? this.fontFamily + "" : ""; return !Y && e && ("'" !== (e = e.split(",")[0])[0] && '"' !== e[0] && (e = "'" + e + "'")), t + e }, i(_, S), i(F, S), F.prototype.setLayout = function () { if (this.text) { var t, e, a, i = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, n = i.layoutManager.getFreeSpace(), s = n.x1, o = n.y1, r = 0, l = 0, h = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0; "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = n.width - 4 - h * ("center" === this.horizontalAlign ? 2 : 1)), l = .5 * n.height - this.margin - 2, r = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = n.height - 4), l = .5 * n.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = n.width - 4), l = .5 * n.height - 4)), p(this.padding) || "number" !== typeof this.padding ? p(this.padding) || "object" !== typeof this.padding || (a = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, a += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, a *= 1.25) : a = 2.5 * this.padding, this.wrap || (l = Math.min(l, Math.max(1.5 * this.fontSize, this.fontSize + a))), a = (l = new E(this.ctx, { fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor, fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: l, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: "top" })).measureText(), "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (o = n.y1 + 2, e = "top") : "bottom" === this.verticalAlign && (o = n.y2 - 2 - a.height, e = "bottom"), "left" === this.horizontalAlign ? s = n.x1 + 2 : "center" === this.horizontalAlign ? s = n.x1 + n.width / 2 - a.width / 2 : "right" === this.horizontalAlign && (s = n.x2 - 2 - a.width - h), t = this.horizontalAlign, this.width = a.width, this.height = a.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (s = n.x1 + 2, o = n.y2 - 2 - (this.maxWidth / 2 - a.width / 2), r = -90, e = "left", this.width = a.height, this.height = a.width) : "right" === this.horizontalAlign ? (s = n.x2 - 2, o = n.y1 + 2 + (this.maxWidth / 2 - a.width / 2), r = 90, e = "right", this.width = a.height, this.height = a.width) : "center" === this.horizontalAlign && (o = i.y1 + (i.height / 2 - a.height / 2), s = i.x1 + (i.width / 2 - a.width / 2), e = "center", this.width = a.width, this.height = a.height), t = "center"), l.x = s, l.y = o, l.angle = r, l.horizontalAlign = t, this._textBlock = l, i.layoutManager.registerSpace(e, { width: this.width + ("left" === e || "right" === e ? this.margin + 2 : 0), height: this.height + ("top" === e || "bottom" === e ? this.margin + 2 : 0) }), this.bounds = { x1: s, y1: o, x2: s + this.width, y2: o + this.height }, this.ctx.textBaseline = "top" } }, F.prototype.render = function () { this._textBlock && this._textBlock.render(!0) }, i(B, S), B.prototype.setLayout = F.prototype.setLayout, B.prototype.render = F.prototype.render, L.prototype.get = function (t, e) { var a = null; return 0 < this.pool.length ? v(a = this.pool.pop(), t, e) : a = M(t, e), a }, L.prototype.release = function (t) { this.pool.push(t) }, i(I, S); var gt = { addTheme: function (t, e) { Q[t] = e }, addColorSet: function (t, e) { q[t] = e }, addCultureInfo: function (t, e) { j[t] = e }, formatNumber: function (t, e, a) { if (j[a = a || "en"]) return st(t, e || "#,##0.##", new I(a)); throw "Unknown Culture Name" }, formatDate: function (t, e, a) { if (j[a = a || "en"]) return nt(t, e || "DD MMM YYYY", new I(a)); throw "Unknown Culture Name" } }; "undefined" !== typeof t.exports ? t.exports = gt : "function" === typeof define && a(746) ? define([], (function () { return gt })) : window.CanvasJS = gt, gt.Chart = function () { function t(t, e) { return t.x - e.x } function a(t, e) { e = e || {}, this.theme = p(e.theme) || p(Q[e.theme]) ? "light1" : e.theme, a.base.constructor.call(this, "Chart", null, e, null, null); var i = this; if (this._containerId = t, this._objectsInitialized = !1, this.overlaidCanvasCtx = this.ctx = null, this._indexLabels = [], this._panTimerId = 0, this._lastTouchEventType = "", this._lastTouchData = null, this.isAnimating = !1, this.renderCount = 0, this.disableToolTip = this.animatedRender = !1, this.canvasPool = new L, this.allDOMEventHandlers = [], this.panEnabled = !1, this._defaultCursor = "default", this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 }, this._dataInRenderedOrder = [], this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) { this.container.innerHTML = ""; var n = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, s = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height; this.width = n, this.height = s, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this._selectedColorSet = "undefined" !== typeof q[this.colorSet] ? q[this.colorSet] : q.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", Y || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = M(n, s), this._preRenderCanvas = M(n, s), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", r(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", r(this._preRenderCtx), Y ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = M(n, s), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = M(n, s), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", r(this.overlaidCanvasCtx)), this._eventManager = new G(this), this.windowResizeHandler = b(window, "resize", (function () { i._updateSize() && i.render() }), this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, b(this.overlaidCanvas, "click", (function (t) { i._mouseEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, "mousemove", (function (t) { i._mouseEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, "mouseup", (function (t) { i._mouseEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, "mousedown", (function (t) { i._mouseEventHandler(t), C(i._dropdownMenu) }), this.allDOMEventHandlers), b(this.overlaidCanvas, "mouseout", (function (t) { i._mouseEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", (function (t) { i._touchEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", (function (t) { i._touchEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", (function (t) { i._touchEventHandler(t) }), this.allDOMEventHandlers), b(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", (function (t) { i._touchEventHandler(t) }), this.allDOMEventHandlers), this.toolTip = new H(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] }) } else window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found') } function s(t, e) { for (var a, i = [], n = 0; n < t.length; n++)if (0 == n) i.push(t[0]); else { var s, o, r; s = 0 === (r = n - 1) ? 0 : r - 1, o = r === t.length - 1 ? r : r + 1, a = Math.abs((t[o].x - t[s].x) / (0 === t[o].x - t[r].x ? .01 : t[o].x - t[r].x)) * (e - 1) / 2 + 1; var l = (t[o].x - t[s].x) / a; a = (t[o].y - t[s].y) / a, i[i.length] = t[r].x > t[s].x && 0 < l || t[r].x < t[s].x && 0 > l ? { x: t[r].x + l / 3, y: t[r].y + a / 3 } : { x: t[r].x, y: t[r].y + a / 9 }, s = 0 === (r = n) ? 0 : r - 1, o = r === t.length - 1 ? r : r + 1, a = Math.abs((t[o].x - t[s].x) / (0 === t[r].x - t[s].x ? .01 : t[r].x - t[s].x)) * (e - 1) / 2 + 1, l = (t[o].x - t[s].x) / a, a = (t[o].y - t[s].y) / a, i[i.length] = t[r].x > t[s].x && 0 < l || t[r].x < t[s].x && 0 > l ? { x: t[r].x - l / 3, y: t[r].y - a / 3 } : { x: t[r].x, y: t[r].y - a / 9 }, i[i.length] = t[n] } return i } function d(t, e, a, i, n, s, o, r, l, h) { var c = 0; h ? (o.color = s, r.color = s) : h = 1, c = l ? Math.abs(n - a) : Math.abs(i - e), c = 0 < o.trimLength ? Math.abs(c * o.trimLength / 100) : Math.abs(c - o.length), l ? (a += c / 2, n -= c / 2) : (e += c / 2, i -= c / 2); c = 1 === Math.round(o.thickness) % 2 ? .5 : 0; var d = 1 === Math.round(r.thickness) % 2 ? .5 : 0; t.save(), t.globalAlpha = h, t.strokeStyle = r.color || s, t.lineWidth = r.thickness || 2, t.setLineDash && t.setLineDash(g(r.dashType, r.thickness)), t.beginPath(), l && 0 < r.thickness ? (t.moveTo(i - o.thickness / 2, Math.round((a + n) / 2) - d), t.lineTo(e + o.thickness / 2, Math.round((a + n) / 2) - d)) : 0 < r.thickness && (t.moveTo(Math.round((e + i) / 2) - d, a + o.thickness / 2), t.lineTo(Math.round((e + i) / 2) - d, n - o.thickness / 2)), t.stroke(), t.strokeStyle = o.color || s, t.lineWidth = o.thickness || 2, t.setLineDash && t.setLineDash(g(o.dashType, o.thickness)), t.beginPath(), l && 0 < o.thickness ? (t.moveTo(i - c, a), t.lineTo(i - c, n), t.moveTo(e + c, a), t.lineTo(e + c, n)) : 0 < o.thickness && (t.moveTo(e, a + c), t.lineTo(i, a + c), t.moveTo(e, n - c), t.lineTo(i, n - c)), t.stroke(), t.restore() } function D(t, e, a, i, n) { return null === t || "undefined" === typeof t ? "undefined" === typeof a ? e : a : (t = parseFloat(t.toString()) * (0 <= t.toString().indexOf("%") ? e / 100 : 1), "undefined" !== typeof i && (t = Math.min(i, t), "undefined" !== typeof n && (t = Math.max(n, t))), !isNaN(t) && t <= e && 0 <= t ? t : "undefined" === typeof a ? e : a) } function N(t, e) { N.base.constructor.call(this, "Legend", "legend", e, null, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.ghostCtx = this.chart._eventManager.ghostCtx, this.items = [], this.optionsName = "legend", this.height = this.width = 0, this.orientation = null, this.dataSeries = [], this.bounds = { x1: null, y1: null, x2: null, y2: null }, "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.lineHeight = x(this.fontFamily, this.fontSize, this.fontWeight), this.horizontalSpacing = this.fontSize } function V(t, e, a, i) { for (V.base.constructor.call(this, "DataSeries", "data", e, a, t), this.chart = t, this.canvas = t.canvas, this._ctx = t.canvas.ctx, this.index = a, this.noDataPointsInPlotArea = 0, this.id = i, this.chart._eventManager.objectMap[i] = { id: i, objectType: "dataSeries", dataSeriesIndex: a }, t = e.dataPoints ? e.dataPoints.length : 0, this.dataPointEOs = [], e = 0; e < t; e++)this.dataPointEOs[e] = {}; this.dataPointIds = [], this.plotUnit = [], this.axisY = this.axisX = null, this.optionsName = "data", this.isOptionsInArray = !0, null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = .7 : this.fillOpacity = 1), this.axisPlacement = this.getDefaultAxisPlacement(), "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize)) } function W(t, e, a, i, n, s) { if (W.base.constructor.call(this, "Axis", e, a, i, t), this.chart = t, this.canvas = t.canvas, this.ctx = t.ctx, this.intervalStartPosition = this.maxHeight = this.maxWidth = 0, this.labels = [], this.dataSeries = [], this._stripLineLabels = this._ticks = this._labels = null, this.dataInfo = { min: 1 / 0, max: -1 / 0, viewPortMin: 1 / 0, viewPortMax: -1 / 0, minDiff: 1 / 0 }, this.isOptionsInArray = !0, "axisX" === n ? ("left" === s || "bottom" === s ? (this.optionsName = "axisX", p(this.chart.sessionVariables.axisX[i]) && (this.chart.sessionVariables.axisX[i] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[i]) : (this.optionsName = "axisX2", p(this.chart.sessionVariables.axisX2[i]) && (this.chart.sessionVariables.axisX2[i] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[i]), this.options.interval || (this.intervalType = null)) : "left" === s || "bottom" === s ? (this.optionsName = "axisY", p(this.chart.sessionVariables.axisY[i]) && (this.chart.sessionVariables.axisY[i] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[i]) : (this.optionsName = "axisY2", p(this.chart.sessionVariables.axisY2[i]) && (this.chart.sessionVariables.axisY2[i] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[i]), "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize)), "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize)), this.type = n, "axisX" !== n || a && "undefined" !== typeof a.gridThickness || (this.gridThickness = 0), this._position = s, this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null }, this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360), this.options.scaleBreaks && (this.scaleBreaks = new z(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this)), this.stripLines = [], this.options.stripLines && 0 < this.options.stripLines.length) for (t = 0; t < this.options.stripLines.length; t++)this.stripLines.push(new j(this.chart, this.options.stripLines[t], t, ++this.chart._eventManager.lastObjectId, this)); this.options.crosshair && (this.crosshair = new U(this.chart, this.options.crosshair, this)), this._titleTextBlock = null, this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null), this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum, this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null), this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum, null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)), null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)), this.trackChanges("viewportMinimum"), this.trackChanges("viewportMaximum") } function z(t, e, a, i) { if (z.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", e, null, i), this.id = a, this.chart = t, this.ctx = this.chart.ctx, this.axis = i, this.optionsName = "scaleBreaks", this.isOptionsInArray = !1, this._appliedBreaks = [], this.customBreaks = [], this.autoBreaks = [], "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8), this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5)), this.options.customBreaks && 0 < this.options.customBreaks.length) { for (t = 0; t < this.options.customBreaks.length; t++)this.customBreaks.push(new R(this.chart, "customBreaks", this.options.customBreaks[t], t, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[t].startValue && "number" === typeof this.customBreaks[t].endValue && this.customBreaks[t].endValue !== this.customBreaks[t].startValue && this._appliedBreaks.push(this.customBreaks[t]); for (this._appliedBreaks.sort((function (t, e) { return t.startValue - e.startValue })), t = 0; t < this._appliedBreaks.length - 1; t++)this._appliedBreaks[t].endValue >= this._appliedBreaks[t + 1].startValue && (this._appliedBreaks[t].endValue = Math.max(this._appliedBreaks[t].endValue, this._appliedBreaks[t + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + t + " and " + (t + 1) + " are overlapping."), this._appliedBreaks.splice(t, 2), t--) } } function R(t, e, a, i, n, s) { R.base.constructor.call(this, "Break", e, a, i, s), this.id = n, this.chart = t, this.ctx = this.chart.ctx, this.scaleBreaks = s, this.optionsName = e, this.isOptionsInArray = !0, this.type = a.type ? this.type : s.type, this.fillOpacity = p(a.fillOpacity) ? s.fillOpacity : this.fillOpacity, this.lineThickness = p(a.lineThickness) ? s.lineThickness : this.lineThickness, this.color = a.color ? this.color : s.color, this.lineColor = a.lineColor ? this.lineColor : s.lineColor, this.lineDashType = a.lineDashType ? this.lineDashType : s.lineDashType, !p(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime()), !p(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime()), "number" === typeof this.startValue && "number" === typeof this.endValue && this.endValue < this.startValue && (t = this.startValue, this.startValue = this.endValue, this.endValue = t), this.spacing = "undefined" === typeof a.spacing ? s.spacing : a.spacing, "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = s.spacing), this.size = s.parent.logarithmic ? 1 : 0 } function j(t, e, a, i, n) { j.base.constructor.call(this, "StripLine", "stripLines", e, a, n), this.id = i, this.chart = t, this.ctx = this.chart.ctx, this.label = this.label, this.axis = n, this.optionsName = "stripLines", this.isOptionsInArray = !0, this._thicknessType = "pixel", null !== this.startValue && null !== this.endValue && (this.value = n.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null) } function U(t, e, a) { U.base.constructor.call(this, "Crosshair", "crosshair", e, null, a), this.chart = t, this.ctx = this.chart.ctx, this.axis = a, this.optionsName = "crosshair", this._thicknessType = "pixel" } function H(t, e) { H.base.constructor.call(this, "ToolTip", "toolTip", e, null, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.currentDataPointIndex = this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, this.containerTransitionDuration = .1, this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration), this.optionsName = "toolTip", this._initialize() } function G(t) { this.chart = t, this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.ghostCanvas = M(this.chart.width, this.chart.height), this.ghostCtx = this.ghostCanvas.getContext("2d"), this.mouseoveredObjectMaps = [] } function Z(t) { this.chart = t, this.ctx = this.chart.plotArea.ctx, this.animations = [], this.animationRequestId = null } i(a, S), a.prototype.destroy = function () { var t = this.allDOMEventHandlers; this._animator && this._animator.cancelAllAnimations(), this._panTimerId && clearTimeout(this._panTimerId); for (var e = 0; e < t.length; e++) { var a = t[e][0], i = t[e][1], n = t[e][2], s = (s = t[e][3]) || !1; a.removeEventListener ? a.removeEventListener(i, n, s) : a.detachEvent && a.detachEvent("on" + i, n) } for (this.allDOMEventHandlers = [], this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();)this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild); for (; this.container && this.container.hasChildNodes();)this.container.removeChild(this.container.lastChild); for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes();)this._dropdownMenu.removeChild(this._dropdownMenu.lastChild); this.overlaidCanvas = this.canvas = this.container = this._canvasJSContainer = null, this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = this._breaksCanvas = this._preRenderCanvas = this.toolTip.container = null }, a.prototype._updateOptions = function () { var t = this; if (this.updateOption("width"), this.updateOption("height"), this.updateOption("dataPointWidth"), this.updateOption("dataPointMinWidth"), this.updateOption("dataPointMaxWidth"), this.updateOption("interactivityEnabled"), this.updateOption("theme"), this.updateOption("colorSet") && (this._selectedColorSet = "undefined" !== typeof q[this.colorSet] ? q[this.colorSet] : q.colorSet1), this.updateOption("backgroundColor"), this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"), this.updateOption("culture"), this._cultureInfo = new I(this.options.culture), this.updateOption("animationEnabled"), this.animationEnabled = this.animationEnabled && Y, this.updateOption("animationDuration"), this.updateOption("rangeChanging"), this.updateOption("rangeChanged"), this.updateOption("exportEnabled"), this.updateOption("exportFileName"), this.updateOption("zoomType"), this.options.zoomEnabled) { if (!this._zoomButton) { var e = !1; C(this._zoomButton = document.createElement("button")), w(this, this._zoomButton, "pan"), this._toolBar.appendChild(this._zoomButton), this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, b(this._zoomButton, "touchstart", (function (t) { e = !0 }), this.allDOMEventHandlers), b(this._zoomButton, "click", (function () { t.zoomEnabled ? (t.zoomEnabled = !1, t.panEnabled = !0, w(t, t._zoomButton, "zoom")) : (t.zoomEnabled = !0, t.panEnabled = !1, w(t, t._zoomButton, "pan")), t.render() }), this.allDOMEventHandlers), b(this._zoomButton, "mouseover", (function () { e ? e = !1 : (T(0, t._zoomButton, { backgroundColor: t.toolbar.backgroundColorOnHover, color: t.toolbar.fontColorOnHover, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && T(0, t._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }), this.allDOMEventHandlers), b(this._zoomButton, "mouseout", (function () { e || (T(0, t._zoomButton, { backgroundColor: t.toolbar.backgroundColor, color: t.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && T(0, t._zoomButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) }), this.allDOMEventHandlers) } this._resetButton || (e = !1, C(this._resetButton = document.createElement("button")), w(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), b(this._resetButton, "touchstart", (function (t) { e = !0 }), this.allDOMEventHandlers), b(this._resetButton, "click", (function () { if (t.toolTip.hide(), t.zoomEnabled || t.panEnabled ? (t.zoomEnabled = !0, t.panEnabled = !1, w(t, t._zoomButton, "pan"), t._defaultCursor = "default", t.overlaidCanvas.style.cursor = t._defaultCursor) : (t.zoomEnabled = !1, t.panEnabled = !1), t.sessionVariables.axisX) for (var e = 0; e < t.sessionVariables.axisX.length; e++)t.sessionVariables.axisX[e].newViewportMinimum = null, t.sessionVariables.axisX[e].newViewportMaximum = null; if (t.sessionVariables.axisX2) for (e = 0; e < t.sessionVariables.axisX2.length; e++)t.sessionVariables.axisX2[e].newViewportMinimum = null, t.sessionVariables.axisX2[e].newViewportMaximum = null; if (t.sessionVariables.axisY) for (e = 0; e < t.sessionVariables.axisY.length; e++)t.sessionVariables.axisY[e].newViewportMinimum = null, t.sessionVariables.axisY[e].newViewportMaximum = null; if (t.sessionVariables.axisY2) for (e = 0; e < t.sessionVariables.axisY2.length; e++)t.sessionVariables.axisY2[e].newViewportMinimum = null, t.sessionVariables.axisY2[e].newViewportMaximum = null; t.resetOverlayedCanvas(), C(t._zoomButton, t._resetButton), t._dispatchRangeEvent("rangeChanging", "reset"), t.render(), t._dispatchRangeEvent("rangeChanged", "reset"), t.syncCharts && t.syncCharts(null, null) }), this.allDOMEventHandlers), b(this._resetButton, "mouseover", (function () { e || (T(0, t._resetButton, { backgroundColor: t.toolbar.backgroundColorOnHover, color: t.toolbar.hoverFfontColorOnHoverontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && T(0, t._resetButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }), this.allDOMEventHandlers), b(this._resetButton, "mouseout", (function () { e || (T(0, t._resetButton, { backgroundColor: t.toolbar.backgroundColor, color: t.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && T(0, t._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) }), this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = t._defaultCursor), this.zoomEnabled || this.panEnabled || (this._zoomButton ? (t._zoomButton.getAttribute("state") === t._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), P(t._zoomButton, t._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1)) } else this.panEnabled = this.zoomEnabled = !1; if (this._menuButton ? this.exportEnabled ? P(this._menuButton) : C(this._menuButton) : this.exportEnabled && Y && (e = !1, this._menuButton = document.createElement("button"), w(this, this._menuButton, "menu"), this._toolBar.appendChild(this._menuButton), b(this._menuButton, "touchstart", (function (t) { e = !0 }), this.allDOMEventHandlers), b(this._menuButton, "click", (function () { "none" !== t._dropdownMenu.style.display || t._dropDownCloseTime && 500 >= (new Date).getTime() - t._dropDownCloseTime.getTime() || (t._dropdownMenu.style.display = "block", t._menuButton.blur(), t._dropdownMenu.focus()) }), this.allDOMEventHandlers, !0), b(this._menuButton, "mouseover", (function () { e || (T(0, t._menuButton, { backgroundColor: t.toolbar.backgroundColorOnHover, color: t.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && T(0, t._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }), this.allDOMEventHandlers, !0), b(this._menuButton, "mouseout", (function () { e || (T(0, t._menuButton, { backgroundColor: t.toolbar.backgroundColor, color: t.toolbar.fontColor }), 0 >= navigator.userAgent.search("MSIE") && T(0, t._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) }), this.allDOMEventHandlers, !0)), !this._dropdownMenu && this.exportEnabled && Y) { e = !1, this._dropdownMenu = document.createElement("div"), this._dropdownMenu.setAttribute("tabindex", -1); var a = -1 !== this.theme.indexOf("dark") ? "black" : "#888888"; this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" + this.toolbar.backgroundColor + ";box-shadow: 2px 2px 10px " + a, t._dropdownMenu.style.display = "none", this._toolBar.appendChild(this._dropdownMenu), b(this._dropdownMenu, "blur", (function () { C(t._dropdownMenu), t._dropDownCloseTime = new Date }), this.allDOMEventHandlers, !0), (a = document.createElement("div")).style.cssText = "padding: 12px 8px 12px 8px", a.innerHTML = this._cultureInfo.printText, a.style.backgroundColor = this.toolbar.backgroundColor, a.style.color = this.toolbar.fontColor, this._dropdownMenu.appendChild(a), b(a, "touchstart", (function (t) { e = !0 }), this.allDOMEventHandlers), b(a, "mouseover", (function () { e || (this.style.backgroundColor = t.toolbar.backgroundColorOnHover, this.style.color = t.toolbar.fontColorOnHover) }), this.allDOMEventHandlers, !0), b(a, "mouseout", (function () { e || (this.style.backgroundColor = t.toolbar.backgroundColor, this.style.color = t.toolbar.fontColor) }), this.allDOMEventHandlers, !0), b(a, "click", (function () { t.print(), C(t._dropdownMenu) }), this.allDOMEventHandlers, !0), (a = document.createElement("div")).style.cssText = "padding: 12px 8px 12px 8px", a.innerHTML = this._cultureInfo.saveJPGText, a.style.backgroundColor = this.toolbar.backgroundColor, a.style.color = this.toolbar.fontColor, this._dropdownMenu.appendChild(a), b(a, "touchstart", (function (t) { e = !0 }), this.allDOMEventHandlers), b(a, "mouseover", (function () { e || (this.style.backgroundColor = t.toolbar.backgroundColorOnHover, this.style.color = t.toolbar.fontColorOnHover) }), this.allDOMEventHandlers, !0), b(a, "mouseout", (function () { e || (this.style.backgroundColor = t.toolbar.backgroundColor, this.style.color = t.toolbar.fontColor) }), this.allDOMEventHandlers, !0), b(a, "click", (function () { h(t.canvas, "jpeg", t.exportFileName), C(t._dropdownMenu) }), this.allDOMEventHandlers, !0), (a = document.createElement("div")).style.cssText = "padding: 12px 8px 12px 8px", a.innerHTML = this._cultureInfo.savePNGText, a.style.backgroundColor = this.toolbar.backgroundColor, a.style.color = this.toolbar.fontColor, this._dropdownMenu.appendChild(a), b(a, "touchstart", (function (t) { e = !0 }), this.allDOMEventHandlers), b(a, "mouseover", (function () { e || (this.style.backgroundColor = t.toolbar.backgroundColorOnHover, this.style.color = t.toolbar.fontColorOnHover) }), this.allDOMEventHandlers, !0), b(a, "mouseout", (function () { e || (this.style.backgroundColor = t.toolbar.backgroundColor, this.style.color = t.toolbar.fontColor) }), this.allDOMEventHandlers, !0), b(a, "click", (function () { h(t.canvas, "png", t.exportFileName), C(t._dropdownMenu) }), this.allDOMEventHandlers, !0) } for (var i in "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? w(t, t._zoomButton, "zoom") : w(t, t._zoomButton, "pan"), t._resetButton.getAttribute("state") !== t._cultureInfo.resetText && w(t, t._resetButton, "reset")), this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip), this.toolTip.options) this.toolTip.options.hasOwnProperty(i) && this.toolTip.updateOption(i) }, a.prototype._updateSize = function () { var t; t = [this.canvas, this._preRenderCanvas, this.overlaidCanvas, this._eventManager.ghostCanvas]; var e = 0, a = 0; if (this.options.width ? e = this.width : this.width = e = 0 < this.container.clientWidth ? this.container.clientWidth : this.width, this.options.height ? a = this.height : this.height = a = 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.canvas.width !== e * ct || this.canvas.height !== a * ct) { for (var i = 0; i < t.length; i++)v(t[i], e, a); t = !0 } else t = !1; return t }, a.prototype._initialize = function () { this.isNavigator = !p(this.parent) && !p(this.parent._defaultsKey) && "Navigator" === this.parent._defaultsKey, this.toolbar = new _(this, this.options.toolbar), this._animator ? this._animator.cancelAllAnimations() : this._animator = new Z(this), this.removeAllEventListeners(), this.disableToolTip = !1, this._axes = [], this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null, this._updateOptions(), this.animatedRender = Y && this.animationEnabled && 0 === this.renderCount, this._updateSize(), this.clearCanvas(), this.ctx.beginPath(), this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this._indexLabels = [], this._dataInRenderedOrder = [], this._events = [], this._eventManager && this._eventManager.reset(), this.plotInfo = { axisPlacement: null, plotTypes: [] }, this.layoutManager = new A(0, 0, this.width, this.height, this.isNavigator ? 0 : 2), this.plotArea.layoutManager && this.plotArea.layoutManager.reset(), this.data = []; var e = 0, i = null; if (this.options.data) { for (var n = 0; n < this.options.data.length; n++)if (e++, !this.options.data[n].type || 0 <= a._supportedChartTypes.indexOf(this.options.data[n].type)) { var s = new V(this, this.options.data[n], e - 1, ++this._eventManager.lastObjectId); "error" === s.type && (s.linkedDataSeriesIndex = p(this.options.data[n].linkedDataSeriesIndex) ? n - 1 : this.options.data[n].linkedDataSeriesIndex, 0 > s.linkedDataSeriesIndex || s.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof s.linkedDataSeriesIndex || "error" === this.options.data[s.linkedDataSeriesIndex].type) && (s.linkedDataSeriesIndex = null), null === s.name && (s.name = "DataSeries " + e), null === s.color ? 1 < this.options.data.length ? (s._colorSet = [this._selectedColorSet[s.index % this._selectedColorSet.length]], s.color = this._selectedColorSet[s.index % this._selectedColorSet.length]) : s._colorSet = "line" === s.type || "stepLine" === s.type || "spline" === s.type || "area" === s.type || "stepArea" === s.type || "splineArea" === s.type || "stackedArea" === s.type || "stackedArea100" === s.type || "rangeArea" === s.type || "rangeSplineArea" === s.type || "candlestick" === s.type || "ohlc" === s.type || "waterfall" === s.type || "boxAndWhisker" === s.type ? [this._selectedColorSet[0]] : this._selectedColorSet : s._colorSet = [s.color], null === s.markerSize && (("line" === s.type || "stepLine" === s.type || "spline" === s.type || 0 <= s.type.toLowerCase().indexOf("area")) && s.dataPoints && s.dataPoints.length < this.width / 16 || "scatter" === s.type) && (s.markerSize = 8), "bubble" !== s.type && "scatter" !== s.type || !s.dataPoints || (s.dataPoints.some ? s.dataPoints.some((function (t) { return t.x })) && s.dataPoints.sort(t) : s.dataPoints.sort(t)), this.data.push(s); var o, r = s.axisPlacement; i = i || r; if ("normal" === r ? "xySwapped" === this.plotInfo.axisPlacement ? o = 'You cannot combine "' + s.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? o = 'You cannot combine "' + s.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === r ? "normal" === this.plotInfo.axisPlacement ? o = 'You cannot combine "' + s.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? o = 'You cannot combine "' + s.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === r ? "normal" === this.plotInfo.axisPlacement ? o = 'You cannot combine "' + s.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? o = 'You cannot combine "' + s.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === r && "none" === this.plotInfo.axisPlacement && (o = 'You cannot combine "' + s.type + '" with pie chart'), o && window.console) return void window.console.log(o) } for (n = 0; n < this.data.length; n++) { if ("none" == i && "error" === this.data[n].type && window.console) return void window.console.log('You cannot combine "' + s.type + '" with error chart'); "error" === this.data[n].type && (this.data[n].axisPlacement = this.plotInfo.axisPlacement = i || "normal", this.data[n]._linkedSeries = null === this.data[n].linkedDataSeriesIndex ? null : this.data[this.data[n].linkedDataSeriesIndex]) } } this._objectsInitialized = !0, this._plotAreaElements = [] }, a._supportedChartTypes = u("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" ")), a.prototype.setLayout = function () { for (var t = this._plotAreaElements, e = 0; e < this.data.length; e++)if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) { if (!this.data[e].axisYType || "primary" === this.data[e].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) { if (!this.axisY.length) for (var a = 0; a < this.options.axisY.length; a++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[a] = new W(this, "axisY", this.options.axisY[a], a, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[a] = new W(this, "axisY", this.options.axisY[a], a, "axisY", "bottom")); this.data[e].axisY = this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0], this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]) } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new W(this, "axisY", this.options.axisY, 0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new W(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[e].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[e]); if ("secondary" === this.data[e].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) { if (!this.axisY2.length) for (a = 0; a < this.options.axisY2.length; a++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[a] = new W(this, "axisY2", this.options.axisY2[a], a, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[a] = new W(this, "axisY2", this.options.axisY2[a], a, "axisY", "top")); this.data[e].axisY = this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0], this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]) } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new W(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new W(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[e].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[e]); if (!this.data[e].axisXType || "primary" === this.data[e].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) { if (!this.axisX.length) for (a = 0; a < this.options.axisX.length; a++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[a] = new W(this, "axisX", this.options.axisX[a], a, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[a] = new W(this, "axisX", this.options.axisX[a], a, "axisX", "left")); this.data[e].axisX = this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0], this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]) } else this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new W(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new W(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[e].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[e]); if ("secondary" === this.data[e].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) { if (!this.axisX2.length) for (a = 0; a < this.options.axisX2.length; a++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[a] = new W(this, "axisX2", this.options.axisX2[a], a, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[a] = new W(this, "axisX2", this.options.axisX2[a], a, "axisX", "right")); this.data[e].axisX = this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0], this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]) } else this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new W(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new W(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[e].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[e]) } if (this.axisY) { for (a = 1; a < this.axisY.length; a++)"undefined" === typeof this.axisY[a].options.gridThickness && (this.axisY[a].gridThickness = 0); for (a = 0; a < this.axisY.length - 1; a++)"undefined" === typeof this.axisY[a].options.margin && (this.axisY[a].margin = 10) } if (this.axisY2) { for (a = 1; a < this.axisY2.length; a++)"undefined" === typeof this.axisY2[a].options.gridThickness && (this.axisY2[a].gridThickness = 0); for (a = 0; a < this.axisY2.length - 1; a++)"undefined" === typeof this.axisY2[a].options.margin && (this.axisY2[a].margin = 10) } if (this.axisY && 0 < this.axisY.length && this.axisY2 && 0 < this.axisY2.length && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0)), this.axisX) for (a = 0; a < this.axisX.length; a++)"undefined" === typeof this.axisX[a].options.gridThickness && (this.axisX[a].gridThickness = 0); if (this.axisX2) for (a = 0; a < this.axisX2.length; a++)"undefined" === typeof this.axisX2[a].options.gridThickness && (this.axisX2[a].gridThickness = 0); if (this.axisX && 0 < this.axisX.length && this.axisX2 && 0 < this.axisX2.length && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0)), a = !1, 0 < this._axes.length && (this.zoomEnabled || this.panEnabled)) for (e = 0; e < this._axes.length; e++)if (null !== this._axes[e].viewportMinimum || null !== this._axes[e].viewportMaximum) { a = !0; break } if (a ? (P(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor) : (C(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1)), m(this), this._processData(), this.options.title && (this.title = new F(this, this.options.title), this.title.dockInsidePlotArea ? t.push(this.title) : this.title.setLayout()), this.subtitles = [], this.options.subtitles) for (e = 0; e < this.options.subtitles.length; e++)a = new B(this, this.options.subtitles[e], e), this.subtitles.push(a), a.dockInsidePlotArea ? t.push(a) : a.setLayout(); for (this.legend = new N(this, this.options.legend), e = 0; e < this.data.length; e++)(this.data[e].showInLegend || "pie" === this.data[e].type || "doughnut" === this.data[e].type || "funnel" === this.data[e].type || "pyramid" === this.data[e].type) && this.legend.dataSeries.push(this.data[e]); for (this.legend.dockInsidePlotArea ? t.push(this.legend) : this.legend.setLayout(), e = 0; e < this._axes.length; e++)if (this._axes[e].scaleBreaks && this._axes[e].scaleBreaks._appliedBreaks.length) { Y ? (this._breaksCanvas = M(this.width, this.height), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx); break } this._preRenderCanvas = p(this._preRenderCanvas) ? M(this.width, this.height) : this._preRenderCanvas, this._preRenderCtx = this._preRenderCanvas.getContext("2d"), "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || W.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace()) }, a.prototype.renderElements = function () { var t = this._plotAreaElements; this.title && !this.title.dockInsidePlotArea && this.title.render(); for (var e = 0; e < this.subtitles.length; e++)this.subtitles[e].dockInsidePlotArea || this.subtitles[e].render(); if (this.legend.dockInsidePlotArea || this.legend.render(), "normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) W.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement); else { if ("none" !== this.plotInfo.axisPlacement) return; this.preparePlotArea() } for (e = 0; e < t.length; e++)t[e].setLayout(), t[e].render(); var a = []; if (this.animatedRender) { var i = M(this.width, this.height); i.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height) } k(this); var n; t = this.ctx.miterLimit; for (this.ctx.miterLimit = 3, Y && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height)), e = 0; e < this.plotInfo.plotTypes.length; e++)for (var s = this.plotInfo.plotTypes[e], o = 0; o < s.plotUnits.length; o++) { var r = s.plotUnits[o], l = null; r.targetCanvas = null, this.animatedRender && (r.targetCanvas = M(this.width, this.height), r.targetCanvasCtx = r.targetCanvas.getContext("2d"), n = r.targetCanvasCtx.miterLimit, r.targetCanvasCtx.miterLimit = 3), "line" === r.type ? l = this.renderLine(r) : "stepLine" === r.type ? l = this.renderStepLine(r) : "spline" === r.type ? l = this.renderSpline(r) : "column" === r.type ? l = this.renderColumn(r) : "bar" === r.type ? l = this.renderBar(r) : "area" === r.type ? l = this.renderArea(r) : "stepArea" === r.type ? l = this.renderStepArea(r) : "splineArea" === r.type ? l = this.renderSplineArea(r) : "stackedColumn" === r.type ? l = this.renderStackedColumn(r) : "stackedColumn100" === r.type ? l = this.renderStackedColumn100(r) : "stackedBar" === r.type ? l = this.renderStackedBar(r) : "stackedBar100" === r.type ? l = this.renderStackedBar100(r) : "stackedArea" === r.type ? l = this.renderStackedArea(r) : "stackedArea100" === r.type ? l = this.renderStackedArea100(r) : "bubble" === r.type ? l = l = this.renderBubble(r) : "scatter" === r.type ? l = this.renderScatter(r) : "pie" === r.type || "doughnut" === r.type ? this.renderPie(r) : "funnel" === r.type || "pyramid" === r.type ? l = this.renderFunnel(r) : "candlestick" === r.type || "ohlc" === r.type ? l = this.renderCandlestick(r) : "rangeColumn" === r.type ? l = this.renderRangeColumn(r) : "error" === r.type ? l = this.renderError(r) : "rangeBar" === r.type ? l = this.renderRangeBar(r) : "rangeArea" === r.type ? l = this.renderRangeArea(r) : "rangeSplineArea" === r.type ? l = this.renderRangeSplineArea(r) : "waterfall" === r.type ? l = this.renderWaterfall(r) : "boxAndWhisker" === r.type && (l = this.renderBoxAndWhisker(r)); for (var h = 0; h < r.dataSeriesIndexes.length; h++)this._dataInRenderedOrder.push(this.data[r.dataSeriesIndexes[h]]); this.animatedRender && (r.targetCanvasCtx.miterLimit = n, l && a.push(l)) } this.ctx.miterLimit = t, this.animatedRender && this._breaksCanvasCtx && a.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0, startTimePercent: .7 }), this.animatedRender && 0 < this._indexLabels.length && (n = M(this.width, this.height).getContext("2d"), a.push(this.renderIndexLabels(n))); var c = this; if (0 < a.length) c.disableToolTip = !0, c._animator.animate(200, c.animationDuration, (function (t) { c.ctx.clearRect(0, 0, c.width, c.height), c.ctx.drawImage(i, 0, 0, Math.floor(c.width * ct), Math.floor(c.height * ct), 0, 0, c.width, c.height); for (var e = 0; e < a.length; e++)l = a[e], 1 > t && "undefined" !== typeof l.startTimePercent ? t >= l.startTimePercent && l.animationCallback(l.easingFunction(t - l.startTimePercent, 0, 1, 1 - l.startTimePercent), l) : l.animationCallback(l.easingFunction(t, 0, 1, 1), l); c.dispatchEvent("dataAnimationIterationEnd", { chart: c }) }), (function () { a = []; for (var t = 0; t < c.plotInfo.plotTypes.length; t++)for (var e = c.plotInfo.plotTypes[t], n = 0; n < e.plotUnits.length; n++)e.plotUnits[n].targetCanvas = null; i = null, c.disableToolTip = !1 })); else { if (c._breaksCanvas) if (Y) c.plotArea.ctx.drawImage(c._breaksCanvas, 0, 0, this.width, this.height); else for (h = 0; h < c._axes.length; h++)c._axes[h].createMask(); 0 < c._indexLabels.length && c.renderIndexLabels(), c.dispatchEvent("dataAnimationIterationEnd", { chart: c }) } for (this.attachPlotAreaEventHandlers(), this.zoomEnabled || this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display || C(this._zoomButton, this._resetButton), this.toolTip._updateToolTip(), this.renderCount++, O && (c = this, setTimeout((function () { var t = document.getElementById("ghostCanvasCopy"); t && (v(t, c.width, c.height), t.getContext("2d").drawImage(c._eventManager.ghostCanvas, 0, 0)) }), 2e3)), this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx), h = 0; h < this._axes.length; h++)this._axes[h].maskCanvas && (delete this._axes[h].maskCanvas, delete this._axes[h].maskCtx) }, a.prototype.render = function (t) { t && (this.options = t), this._initialize(), this.setLayout(), this.renderElements() }, a.prototype.attachPlotAreaEventHandlers = function () { this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? "move" : "default", capture: !0, bounds: this.plotArea }) }, a.prototype.categoriseDataSeries = function () { for (var t = "", e = 0; e < this.data.length; e++)if ((t = this.data[e]).dataPoints && 0 !== t.dataPoints.length && t.visible && 0 <= a._supportedChartTypes.indexOf(t.type)) { for (var i = null, n = !1, s = null, o = !1, r = 0; r < this.plotInfo.plotTypes.length; r++)if (this.plotInfo.plotTypes[r].type === t.type) { n = !0, i = this.plotInfo.plotTypes[r]; break } for (n || (i = { type: t.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(i)), r = 0; r < i.plotUnits.length; r++)if (i.plotUnits[r].axisYType === t.axisYType && i.plotUnits[r].axisXType === t.axisXType && i.plotUnits[r].axisYIndex === t.axisYIndex && i.plotUnits[r].axisXIndex === t.axisXIndex) { o = !0, s = i.plotUnits[r]; break } o || (s = { type: t.type, previousDataSeriesCount: 0, index: i.plotUnits.length, plotType: i, axisXType: t.axisXType, axisYType: t.axisYType, axisYIndex: t.axisYIndex, axisXIndex: t.axisXIndex, axisY: "primary" === t.axisYType ? this.axisY[0 <= t.axisYIndex && t.axisYIndex < this.axisY.length ? t.axisYIndex : 0] : this.axisY2[0 <= t.axisYIndex && t.axisYIndex < this.axisY2.length ? t.axisYIndex : 0], axisX: "primary" === t.axisXType ? this.axisX[0 <= t.axisXIndex && t.axisXIndex < this.axisX.length ? t.axisXIndex : 0] : this.axisX2[0 <= t.axisXIndex && t.axisXIndex < this.axisX2.length ? t.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [] }, i.plotUnits.push(s)), i.totalDataSeries++, s.dataSeriesIndexes.push(e), t.plotUnit = s } for (e = 0; e < this.plotInfo.plotTypes.length; e++)for (i = this.plotInfo.plotTypes[e], r = t = 0; r < i.plotUnits.length; r++)i.plotUnits[r].previousDataSeriesCount = t, t += i.plotUnits[r].dataSeriesIndexes.length }, a.prototype.assignIdToDataPoints = function () { for (var t = 0; t < this.data.length; t++) { var e = this.data[t]; if (e.dataPoints) for (var a = e.dataPoints.length, i = 0; i < a; i++)e.dataPointIds[i] = ++this._eventManager.lastObjectId } }, a.prototype._processData = function () { this.assignIdToDataPoints(), this.categoriseDataSeries(); for (var t = 0; t < this.plotInfo.plotTypes.length; t++)for (var e = this.plotInfo.plotTypes[t], a = 0; a < e.plotUnits.length; a++) { var i = e.plotUnits[a]; "line" === i.type || "stepLine" === i.type || "spline" === i.type || "column" === i.type || "area" === i.type || "stepArea" === i.type || "splineArea" === i.type || "bar" === i.type || "bubble" === i.type || "scatter" === i.type ? this._processMultiseriesPlotUnit(i) : "stackedColumn" === i.type || "stackedBar" === i.type || "stackedArea" === i.type ? this._processStackedPlotUnit(i) : "stackedColumn100" === i.type || "stackedBar100" === i.type || "stackedArea100" === i.type ? this._processStacked100PlotUnit(i) : "candlestick" === i.type || "ohlc" === i.type || "rangeColumn" === i.type || "rangeBar" === i.type || "rangeArea" === i.type || "rangeSplineArea" === i.type || "error" === i.type || "boxAndWhisker" === i.type ? this._processMultiYPlotUnit(i) : "waterfall" === i.type && this._processSpecificPlotUnit(i) } this.calculateAutoBreaks() }, a.prototype._processMultiseriesPlotUnit = function (t) { if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) for (var e, a, i = t.axisY.dataInfo, n = t.axisX.dataInfo, s = !1, o = 0; o < t.dataSeriesIndexes.length; o++) { var r, l = this.data[t.dataSeriesIndexes[o]], h = 0, c = !1, d = !1; if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement) var p = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : t.axisX.logarithmic ? 0 : -1 / 0, u = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0; for ((l.dataPoints[h].x && l.dataPoints[h].x.getTime || "dateTime" === l.xValueType) && (s = !0), h = 0; h < l.dataPoints.length; h++) { if ("undefined" === typeof l.dataPoints[h].x && (l.dataPoints[h].x = h + (t.axisX.logarithmic ? 1 : 0)), l.dataPoints[h].x.getTime ? (s = !0, e = l.dataPoints[h].x.getTime()) : e = l.dataPoints[h].x, a = l.dataPoints[h].y, e < n.min && (n.min = e), e > n.max && (n.max = e), a < i.min && "number" === typeof a && (i.min = a), a > i.max && "number" === typeof a && (i.max = a), 0 < h) { if (t.axisX.logarithmic) { var m = e / l.dataPoints[h - 1].x; 1 > m && (m = 1 / m), n.minDiff > m && 1 !== m && (n.minDiff = m) } else 0 > (m = e - l.dataPoints[h - 1].x) && (m *= -1), n.minDiff > m && 0 !== m && (n.minDiff = m); null !== a && null !== l.dataPoints[h - 1].y && (t.axisY.logarithmic ? (1 > (m = a / l.dataPoints[h - 1].y) && (m = 1 / m), i.minDiff > m && 1 !== m && (i.minDiff = m)) : (0 > (m = a - l.dataPoints[h - 1].y) && (m *= -1), i.minDiff > m && 0 !== m && (i.minDiff = m))) } if (e < p && !c) null !== a && (r = e); else { if (!c && (c = !0, 0 < h)) { h -= 2; continue } if (e > u && !d) d = !0; else if (e > u && d) continue; l.dataPoints[h].label && (t.axisX.labels[e] = l.dataPoints[h].label), e < n.viewPortMin && (n.viewPortMin = e), e > n.viewPortMax && (n.viewPortMax = e), null === a ? n.viewPortMin === e && r < e && (n.viewPortMin = r) : (a < i.viewPortMin && "number" === typeof a && (i.viewPortMin = a), a > i.viewPortMax && "number" === typeof a && (i.viewPortMax = a)) } } l.axisX.valueType = l.xValueType = s ? "dateTime" : "number" } }, a.prototype._processStackedPlotUnit = function (t) { if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) { for (var e, a, i = t.axisY.dataInfo, n = t.axisX.dataInfo, s = !1, o = [], r = [], l = 1 / 0, h = -1 / 0, c = 0; c < t.dataSeriesIndexes.length; c++) { var d, u = this.data[t.dataSeriesIndexes[c]], m = 0, x = !1, g = !1; if ("normal" === u.axisPlacement || "xySwapped" === u.axisPlacement) var b = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -1 / 0, y = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0; for ((u.dataPoints[m].x && u.dataPoints[m].x.getTime || "dateTime" === u.xValueType) && (s = !0), m = 0; m < u.dataPoints.length; m++) { if ("undefined" === typeof u.dataPoints[m].x && (u.dataPoints[m].x = m + (t.axisX.logarithmic ? 1 : 0)), u.dataPoints[m].x.getTime ? (s = !0, e = u.dataPoints[m].x.getTime()) : e = u.dataPoints[m].x, a = p(u.dataPoints[m].y) ? 0 : u.dataPoints[m].y, e < n.min && (n.min = e), e > n.max && (n.max = e), 0 < m) { if (t.axisX.logarithmic) { var f = e / u.dataPoints[m - 1].x; 1 > f && (f = 1 / f), n.minDiff > f && 1 !== f && (n.minDiff = f) } else 0 > (f = e - u.dataPoints[m - 1].x) && (f *= -1), n.minDiff > f && 0 !== f && (n.minDiff = f); null !== a && null !== u.dataPoints[m - 1].y && (t.axisY.logarithmic ? 0 < a && (1 > (f = a / u.dataPoints[m - 1].y) && (f = 1 / f), i.minDiff > f && 1 !== f && (i.minDiff = f)) : (0 > (f = a - u.dataPoints[m - 1].y) && (f *= -1), i.minDiff > f && 0 !== f && (i.minDiff = f))) } if (e < b && !x) null !== u.dataPoints[m].y && (d = e); else { if (!x && (x = !0, 0 < m)) { m -= 2; continue } if (e > y && !g) g = !0; else if (e > y && g) continue; u.dataPoints[m].label && (t.axisX.labels[e] = u.dataPoints[m].label), e < n.viewPortMin && (n.viewPortMin = e), e > n.viewPortMax && (n.viewPortMax = e), null === u.dataPoints[m].y ? n.viewPortMin === e && d < e && (n.viewPortMin = d) : (t.yTotals[e] = (t.yTotals[e] ? t.yTotals[e] : 0) + a, 0 <= a ? o[e] ? o[e] += a : (o[e] = a, l = Math.min(a, l)) : r[e] ? r[e] += a : (r[e] = a, h = Math.max(a, h))) } } t.axisY.scaleBreaks && t.axisY.scaleBreaks.autoCalculate && 1 <= t.axisY.scaleBreaks.maxNumberOfAutoBreaks && (i.dataPointYPositiveSums ? (i.dataPointYPositiveSums.push.apply(i.dataPointYPositiveSums, o), i.dataPointYNegativeSums.push.apply(i.dataPointYPositiveSums, r)) : (i.dataPointYPositiveSums = o, i.dataPointYNegativeSums = r)), u.axisX.valueType = u.xValueType = s ? "dateTime" : "number" } for (m in o) o.hasOwnProperty(m) && !isNaN(m) && ((t = o[m]) < i.min && (i.min = Math.min(t, l)), t > i.max && (i.max = t), m < n.viewPortMin || m > n.viewPortMax || (t < i.viewPortMin && (i.viewPortMin = Math.min(t, l)), t > i.viewPortMax && (i.viewPortMax = t))); for (m in r) r.hasOwnProperty(m) && !isNaN(m) && ((t = r[m]) < i.min && (i.min = t), t > i.max && (i.max = Math.max(t, h)), m < n.viewPortMin || m > n.viewPortMax || (t < i.viewPortMin && (i.viewPortMin = t), t > i.viewPortMax && (i.viewPortMax = Math.max(t, h)))) } }, a.prototype._processStacked100PlotUnit = function (t) { if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) { for (var e, a, i = t.axisY.dataInfo, n = t.axisX.dataInfo, s = !1, o = !1, r = !1, l = [], h = 0; h < t.dataSeriesIndexes.length; h++) { var c, d = this.data[t.dataSeriesIndexes[h]], u = 0, m = !1, x = !1; if ("normal" === d.axisPlacement || "xySwapped" === d.axisPlacement) var g = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -1 / 0, b = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0; for ((d.dataPoints[u].x && d.dataPoints[u].x.getTime || "dateTime" === d.xValueType) && (s = !0), u = 0; u < d.dataPoints.length; u++) { if ("undefined" === typeof d.dataPoints[u].x && (d.dataPoints[u].x = u + (t.axisX.logarithmic ? 1 : 0)), d.dataPoints[u].x.getTime ? (s = !0, e = d.dataPoints[u].x.getTime()) : e = d.dataPoints[u].x, a = p(d.dataPoints[u].y) ? null : d.dataPoints[u].y, e < n.min && (n.min = e), e > n.max && (n.max = e), 0 < u) { if (t.axisX.logarithmic) { var y = e / d.dataPoints[u - 1].x; 1 > y && (y = 1 / y), n.minDiff > y && 1 !== y && (n.minDiff = y) } else 0 > (y = e - d.dataPoints[u - 1].x) && (y *= -1), n.minDiff > y && 0 !== y && (n.minDiff = y); p(a) || null === d.dataPoints[u - 1].y || (t.axisY.logarithmic ? 0 < a && (1 > (y = a / d.dataPoints[u - 1].y) && (y = 1 / y), i.minDiff > y && 1 !== y && (i.minDiff = y)) : (0 > (y = a - d.dataPoints[u - 1].y) && (y *= -1), i.minDiff > y && 0 !== y && (i.minDiff = y))) } if (e < g && !m) null !== a && (c = e); else { if (!m && (m = !0, 0 < u)) { u -= 2; continue } if (e > b && !x) x = !0; else if (e > b && x) continue; d.dataPoints[u].label && (t.axisX.labels[e] = d.dataPoints[u].label), e < n.viewPortMin && (n.viewPortMin = e), e > n.viewPortMax && (n.viewPortMax = e), null === a ? n.viewPortMin === e && c < e && (n.viewPortMin = c) : (t.yTotals[e] = (t.yTotals[e] ? t.yTotals[e] : 0) + a, 0 <= a ? o = !0 : 0 > a && (r = !0), l[e] = l[e] ? l[e] + Math.abs(a) : Math.abs(a)) } } d.axisX.valueType = d.xValueType = s ? "dateTime" : "number" } t.axisY.logarithmic ? (i.max = p(i.viewPortMax) ? 99 * Math.pow(t.axisY.logarithmBase, -.05) : Math.max(i.viewPortMax, 99 * Math.pow(t.axisY.logarithmBase, -.05)), i.min = p(i.viewPortMin) ? 1 : Math.min(i.viewPortMin, 1)) : o && !r ? (i.max = p(i.viewPortMax) ? 99 : Math.max(i.viewPortMax, 99), i.min = p(i.viewPortMin) ? 1 : Math.min(i.viewPortMin, 1)) : o && r ? (i.max = p(i.viewPortMax) ? 99 : Math.max(i.viewPortMax, 99), i.min = p(i.viewPortMin) ? -99 : Math.min(i.viewPortMin, -99)) : !o && r && (i.max = p(i.viewPortMax) ? -1 : Math.max(i.viewPortMax, -1), i.min = p(i.viewPortMin) ? -99 : Math.min(i.viewPortMin, -99)), i.viewPortMin = i.min, i.viewPortMax = i.max, t.dataPointYSums = l } }, a.prototype._processMultiYPlotUnit = function (t) { if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) for (var e, a, i, n, s = t.axisY.dataInfo, o = t.axisX.dataInfo, r = !1, l = 0; l < t.dataSeriesIndexes.length; l++) { var h, c, d, p = this.data[t.dataSeriesIndexes[l]], u = 0, m = !1, x = !1; if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement) var g = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : t.axisX.logarithmic ? 0 : -1 / 0, b = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0; for ((p.dataPoints[u].x && p.dataPoints[u].x.getTime || "dateTime" === p.xValueType) && (r = !0), u = 0; u < p.dataPoints.length; u++) { if ("undefined" === typeof p.dataPoints[u].x && (p.dataPoints[u].x = u + (t.axisX.logarithmic ? 1 : 0)), p.dataPoints[u].x.getTime ? (r = !0, e = p.dataPoints[u].x.getTime()) : e = p.dataPoints[u].x, (a = p.dataPoints[u].y) && a.length) { i = Math.min.apply(null, a), n = Math.max.apply(null, a), c = !0; for (var y = 0; y < a.length; y++)null === a.k && (c = !1); c && (m || (d = h), h = e) } if (e < o.min && (o.min = e), e > o.max && (o.max = e), i < s.min && (s.min = i), n > s.max && (s.max = n), 0 < u && (t.axisX.logarithmic ? (1 > (c = e / p.dataPoints[u - 1].x) && (c = 1 / c), o.minDiff > c && 1 !== c && (o.minDiff = c)) : (0 > (c = e - p.dataPoints[u - 1].x) && (c *= -1), o.minDiff > c && 0 !== c && (o.minDiff = c)), a && null !== a[0] && p.dataPoints[u - 1].y && null !== p.dataPoints[u - 1].y[0] && (t.axisY.logarithmic ? (1 > (c = a[0] / p.dataPoints[u - 1].y[0]) && (c = 1 / c), s.minDiff > c && 1 !== c && (s.minDiff = c)) : (0 > (c = a[0] - p.dataPoints[u - 1].y[0]) && (c *= -1), s.minDiff > c && 0 !== c && (s.minDiff = c)))), !(e < g) || m) { if (!m && (m = !0, 0 < u)) { u -= 2, h = d; continue } if (e > b && !x) x = !0; else if (e > b && x) continue; if (p.dataPoints[u].label && (t.axisX.labels[e] = p.dataPoints[u].label), e < o.viewPortMin && (o.viewPortMin = e), e > o.viewPortMax && (o.viewPortMax = e), o.viewPortMin === e && a) for (y = 0; y < a.length; y++)if (null === a[y] && h < e) { o.viewPortMin = h; break } null === a ? o.viewPortMin === e && h < e && (o.viewPortMin = h) : (i < s.viewPortMin && (s.viewPortMin = i), n > s.viewPortMax && (s.viewPortMax = n)) } } p.axisX.valueType = p.xValueType = r ? "dateTime" : "number" } }, a.prototype._processSpecificPlotUnit = function (t) { if ("waterfall" === t.type && t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) for (var e, a, i = t.axisY.dataInfo, n = t.axisX.dataInfo, s = !1, o = 0; o < t.dataSeriesIndexes.length; o++) { var r = this.data[t.dataSeriesIndexes[o]], l = 0, h = !1, c = !1, d = e = 0; if ("normal" === r.axisPlacement || "xySwapped" === r.axisPlacement) var p = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : t.axisX.logarithmic ? 0 : -1 / 0, u = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0; for ((r.dataPoints[l].x && r.dataPoints[l].x.getTime || "dateTime" === r.xValueType) && (s = !0), l = 0; l < r.dataPoints.length; l++)"undefined" !== typeof r.dataPoints[l].isCumulativeSum && !0 === r.dataPoints[l].isCumulativeSum ? (r.dataPointEOs[l].cumulativeSumYStartValue = 0, r.dataPointEOs[l].cumulativeSum = 0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum, r.dataPoints[l].y = 0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum) : "undefined" !== typeof r.dataPoints[l].isIntermediateSum && !0 === r.dataPoints[l].isIntermediateSum ? (r.dataPointEOs[l].cumulativeSumYStartValue = d, r.dataPointEOs[l].cumulativeSum = 0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum, r.dataPoints[l].y = 0 === l ? 0 : e, d = 0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum, e = 0) : (a = "number" !== typeof r.dataPoints[l].y ? 0 : r.dataPoints[l].y, r.dataPointEOs[l].cumulativeSumYStartValue = 0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum, r.dataPointEOs[l].cumulativeSum = 0 === l ? a : r.dataPointEOs[l - 1].cumulativeSum + a, e += a); for (l = 0; l < r.dataPoints.length; l++)if ("undefined" === typeof r.dataPoints[l].x && (r.dataPoints[l].x = l + (t.axisX.logarithmic ? 1 : 0)), r.dataPoints[l].x.getTime ? (s = !0, e = r.dataPoints[l].x.getTime()) : e = r.dataPoints[l].x, a = r.dataPoints[l].y, e < n.min && (n.min = e), e > n.max && (n.max = e), r.dataPointEOs[l].cumulativeSum < i.min && (i.min = r.dataPointEOs[l].cumulativeSum), r.dataPointEOs[l].cumulativeSum > i.max && (i.max = r.dataPointEOs[l].cumulativeSum), 0 < l && (t.axisX.logarithmic ? (1 > (d = e / r.dataPoints[l - 1].x) && (d = 1 / d), n.minDiff > d && 1 !== d && (n.minDiff = d)) : (0 > (d = e - r.dataPoints[l - 1].x) && (d *= -1), n.minDiff > d && 0 !== d && (n.minDiff = d)), null !== a && null !== r.dataPoints[l - 1].y && (t.axisY.logarithmic ? (1 > (a = r.dataPointEOs[l].cumulativeSum / r.dataPointEOs[l - 1].cumulativeSum) && (a = 1 / a), i.minDiff > a && 1 !== a && (i.minDiff = a)) : (0 > (a = r.dataPointEOs[l].cumulativeSum - r.dataPointEOs[l - 1].cumulativeSum) && (a *= -1), i.minDiff > a && 0 !== a && (i.minDiff = a)))), !(e < p) || h) { if (!h && (h = !0, 0 < l)) { l -= 2; continue } if (e > u && !c) c = !0; else if (e > u && c) continue; r.dataPoints[l].label && (t.axisX.labels[e] = r.dataPoints[l].label), e < n.viewPortMin && (n.viewPortMin = e), e > n.viewPortMax && (n.viewPortMax = e), 0 < l && (r.dataPointEOs[l - 1].cumulativeSum < i.viewPortMin && (i.viewPortMin = r.dataPointEOs[l - 1].cumulativeSum), r.dataPointEOs[l - 1].cumulativeSum > i.viewPortMax && (i.viewPortMax = r.dataPointEOs[l - 1].cumulativeSum)), r.dataPointEOs[l].cumulativeSum < i.viewPortMin && (i.viewPortMin = r.dataPointEOs[l].cumulativeSum), r.dataPointEOs[l].cumulativeSum > i.viewPortMax && (i.viewPortMax = r.dataPointEOs[l].cumulativeSum) } r.axisX.valueType = r.xValueType = s ? "dateTime" : "number" } }, a.prototype.calculateAutoBreaks = function () { function t(t, e, a, i) { return i ? (1 >= (a = Math.pow(Math.min(a * t / e, e / t), .2)) && (a = Math.pow(1 > t ? 1 / t : Math.min(e / t, t), .25)), { startValue: t * a, endValue: e / a }) : (0 >= (a = .2 * Math.min(a - e + t, e - t)) && (a = .25 * Math.min(e - t, Math.abs(t))), { startValue: t + a, endValue: e - a }) } function e(t) { if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) { var e = t.axisX.scaleBreaks && t.axisX.scaleBreaks.autoCalculate && 1 <= t.axisX.scaleBreaks.maxNumberOfAutoBreaks, a = t.axisY.scaleBreaks && t.axisY.scaleBreaks.autoCalculate && 1 <= t.axisY.scaleBreaks.maxNumberOfAutoBreaks; if (e || a) for (var i, s, o = t.axisY.dataInfo, r = (d = t.axisX.dataInfo).min, l = d.max, h = o.min, c = o.max, d = d._dataRanges, u = (o = o._dataRanges, 0), m = 0; m < t.dataSeriesIndexes.length; m++) { var x = n.data[t.dataSeriesIndexes[m]]; if (!(4 > x.dataPoints.length)) for (u = 0; u < x.dataPoints.length; u++)if (e && (s = (l + 1 - r) * Math.max(parseFloat(t.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, (i = x.dataPoints[u].x.getTime ? x.dataPoints[u].x.getTime() : x.dataPoints[u].x) < d[s = Math.floor((i - r) / s)].min && (d[s].min = i), i > d[s].max && (d[s].max = i)), a) { var g = (c + 1 - h) * Math.max(parseFloat(t.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100; if ((i = "waterfall" === t.type ? x.dataPointEOs[u].cumulativeSum : x.dataPoints[u].y) && i.length) for (var b = 0; b < i.length; b++)s = Math.floor((i[b] - h) / g), i[b] < o[s].min && (o[s].min = i[b]), i[b] > o[s].max && (o[s].max = i[b]); else p(i) || (i < o[s = Math.floor((i - h) / g)].min && (o[s].min = i), i > o[s].max && (o[s].max = i)) } } } } function a(t) { if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length) && t.axisX.scaleBreaks && t.axisX.scaleBreaks.autoCalculate && 1 <= t.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var e, a = t.axisX.dataInfo, i = a.min, s = a.max, o = a._dataRanges, r = 0, l = 0; l < t.dataSeriesIndexes.length; l++) { var h = n.data[t.dataSeriesIndexes[l]]; if (!(4 > h.dataPoints.length)) for (r = 0; r < h.dataPoints.length; r++)e = (s + 1 - i) * Math.max(parseFloat(t.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, (a = h.dataPoints[r].x.getTime ? h.dataPoints[r].x.getTime() : h.dataPoints[r].x) < o[e = Math.floor((a - i) / e)].min && (o[e].min = a), a > o[e].max && (o[e].max = a) } } for (var i, n = this, s = !1, o = 0; o < this._axes.length; o++)if (this._axes[o].scaleBreaks && this._axes[o].scaleBreaks.autoCalculate && 1 <= this._axes[o].scaleBreaks.maxNumberOfAutoBreaks) { s = !0, this._axes[o].dataInfo._dataRanges = []; for (var r = 0; r < 100 / Math.max(parseFloat(this._axes[o].scaleBreaks.collapsibleThreshold) || 10, 10); r++)this._axes[o].dataInfo._dataRanges.push({ min: 1 / 0, max: -1 / 0 }) } if (s) { for (o = 0; o < this.plotInfo.plotTypes.length; o++)for (s = this.plotInfo.plotTypes[o], r = 0; r < s.plotUnits.length; r++)"line" === (i = s.plotUnits[r]).type || "stepLine" === i.type || "spline" === i.type || "column" === i.type || "area" === i.type || "stepArea" === i.type || "splineArea" === i.type || "bar" === i.type || "bubble" === i.type || "scatter" === i.type || "candlestick" === i.type || "ohlc" === i.type || "rangeColumn" === i.type || "rangeBar" === i.type || "rangeArea" === i.type || "rangeSplineArea" === i.type || "waterfall" === i.type || "error" === i.type || "boxAndWhisker" === i.type ? e(i) : 0 <= i.type.indexOf("stacked") && a(i); for (o = 0; o < this._axes.length; o++)if (this._axes[o].dataInfo._dataRanges) { var l = this._axes[o].dataInfo.min; i = (this._axes[o].dataInfo.max + 1 - l) * Math.max(parseFloat(this._axes[o].scaleBreaks.collapsibleThreshold) || 10, 10) / 100; var h, c, d = this._axes[o].dataInfo._dataRanges; s = []; if (this._axes[o].dataInfo.dataPointYPositiveSums) { var u = this._axes[o].dataInfo.dataPointYPositiveSums; for (r in h = d, u) if (u.hasOwnProperty(r) && !isNaN(r) && !p(c = u[r])) { var m = Math.floor((c - l) / i); c < h[m].min && (h[m].min = c), c > h[m].max && (h[m].max = c) } delete this._axes[o].dataInfo.dataPointYPositiveSums } if (this._axes[o].dataInfo.dataPointYNegativeSums) { for (r in h = d, u = this._axes[o].dataInfo.dataPointYNegativeSums) u.hasOwnProperty(r) && !isNaN(r) && (p(c = -1 * u[r]) || (c < h[m = Math.floor((c - l) / i)].min && (h[m].min = c), c > h[m].max && (h[m].max = c))); delete this._axes[o].dataInfo.dataPointYNegativeSums } for (r = 0; r < d.length - 1; r++)if (h = d[r].max, isFinite(h)) for (; r < d.length - 1;) { if (l = d[r + 1].min, isFinite(l)) { (c = l - h) > i && s.push({ diff: c, start: h, end: l }); break } r++ } if (this._axes[o].scaleBreaks.customBreaks) for (r = 0; r < this._axes[o].scaleBreaks.customBreaks.length; r++)for (i = 0; i < s.length; i++)(this._axes[o].scaleBreaks.customBreaks[r].startValue <= s[i].start && s[i].start <= this._axes[o].scaleBreaks.customBreaks[r].endValue || this._axes[o].scaleBreaks.customBreaks[r].startValue <= s[i].start && s[i].start <= this._axes[o].scaleBreaks.customBreaks[r].endValue || s[i].start <= this._axes[o].scaleBreaks.customBreaks[r].startValue && this._axes[o].scaleBreaks.customBreaks[r].startValue <= s[i].end || s[i].start <= this._axes[o].scaleBreaks.customBreaks[r].endValue && this._axes[o].scaleBreaks.customBreaks[r].endValue <= s[i].end) && (s.splice(i, 1), i--); for (s.sort((function (t, e) { return e.diff - t.diff })), r = 0; r < Math.min(s.length, this._axes[o].scaleBreaks.maxNumberOfAutoBreaks); r++)i = t(s[r].start, s[r].end, this._axes[o].logarithmic ? this._axes[o].dataInfo.max / this._axes[o].dataInfo.min : this._axes[o].dataInfo.max - this._axes[o].dataInfo.min, this._axes[o].logarithmic), this._axes[o].scaleBreaks.autoBreaks.push(new R(this, "autoBreaks", i, r, ++this._eventManager.lastObjectId, this._axes[o].scaleBreaks)), this._axes[o].scaleBreaks._appliedBreaks.push(this._axes[o].scaleBreaks.autoBreaks[this._axes[o].scaleBreaks.autoBreaks.length - 1]); this._axes[o].scaleBreaks._appliedBreaks.sort((function (t, e) { return t.startValue - e.startValue })) } } }, a.prototype.getDataPointAtXY = function (t, e, a) { a = a || !1; for (var i = [], n = this._dataInRenderedOrder.length - 1; 0 <= n; n--) { var s; (s = this._dataInRenderedOrder[n].getDataPointAtXY(t, e, a)) && i.push(s) } for (t = null, e = !1, a = 0; a < i.length; a++)if (("line" === i[a].dataSeries.type || "stepLine" === i[a].dataSeries.type || "area" === i[a].dataSeries.type || "stepArea" === i[a].dataSeries.type) && (n = f("markerSize", i[a].dataPoint, i[a].dataSeries) || 8, i[a].distance <= n / 2)) { e = !0; break } for (a = 0; a < i.length; a++)e && "line" !== i[a].dataSeries.type && "stepLine" !== i[a].dataSeries.type && "area" !== i[a].dataSeries.type && "stepArea" !== i[a].dataSeries.type || (t ? i[a].distance <= t.distance && (t = i[a]) : t = i[a]); return t }, a.prototype.getObjectAtXY = function (t, e, a) { var i = null; if (a = this.getDataPointAtXY(t, e, a || !1)) i = a.dataSeries.dataPointIds[a.dataPointIndex]; else if (Y) i = y(t, e, this._eventManager.ghostCtx); else for (a = 0; a < this.legend.items.length; a++) { var n = this.legend.items[a]; t >= n.x1 && t <= n.x2 && e >= n.y1 && e <= n.y2 && (i = n.id) } return i }, a.prototype.getAutoFontSize = it, a.prototype.resetOverlayedCanvas = function () { this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height) }, a.prototype.clearCanvas = at, a.prototype.attachEvent = function (t) { this._events.push(t) }, a.prototype._touchEventHandler = function (t) { if (t.changedTouches && this.interactivityEnabled) { var e = [], a = t.changedTouches, i = a ? a[0] : t, n = null; switch (t.type) { case "touchstart": case "MSPointerDown": e = ["mousemove", "mousedown"], this._lastTouchData = ot(i), this._lastTouchData.time = new Date; break; case "touchmove": case "MSPointerMove": e = ["mousemove"]; break; case "touchend": case "MSPointerUp": var s = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time : 0; e = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > s ? ["mouseup", "click"] : ["mouseup"]; break; default: return }if (!(a && 1 < a.length)) { (n = ot(i)).time = new Date; try { var o = n.y - this._lastTouchData.y; s = n.time - this._lastTouchData.time; (1 < Math.abs(o) && this._lastTouchData.scroll || 5 < Math.abs(o) && 250 > s) && (this._lastTouchData.scroll = !0) } catch (r) { } if (this._lastTouchEventType = t.type, this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1; else for (a = 0; a < e.length; a++)n = e[a], (o = document.createEvent("MouseEvent")).initMouseEvent(n, !0, !0, window, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), i.target.dispatchEvent(o), (!p(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < s || "click" === n) && (t.preventManipulation && t.preventManipulation(), t.preventDefault && t.preventDefault()) } } }, a.prototype._dispatchRangeEvent = function (t, e) { var a = { chart: this }; a.type = t, a.trigger = e; var i = []; this.axisX && 0 < this.axisX.length && i.push("axisX"), this.axisX2 && 0 < this.axisX2.length && i.push("axisX2"), this.axisY && 0 < this.axisY.length && i.push("axisY"), this.axisY2 && 0 < this.axisY2.length && i.push("axisY2"); for (var n = 0; n < i.length; n++)if (p(a[i[n]]) && (a[i[n]] = []), "axisY" === i[n]) for (var s = 0; s < this.axisY.length; s++)a[i[n]].push({ viewportMinimum: this[i[n]][s].sessionVariables.newViewportMinimum, viewportMaximum: this[i[n]][s].sessionVariables.newViewportMaximum }); else if ("axisY2" === i[n]) for (s = 0; s < this.axisY2.length; s++)a[i[n]].push({ viewportMinimum: this[i[n]][s].sessionVariables.newViewportMinimum, viewportMaximum: this[i[n]][s].sessionVariables.newViewportMaximum }); else if ("axisX" === i[n]) for (s = 0; s < this.axisX.length; s++)a[i[n]].push({ viewportMinimum: this[i[n]][s].sessionVariables.newViewportMinimum, viewportMaximum: this[i[n]][s].sessionVariables.newViewportMaximum }); else if ("axisX2" === i[n]) for (s = 0; s < this.axisX2.length; s++)a[i[n]].push({ viewportMinimum: this[i[n]][s].sessionVariables.newViewportMinimum, viewportMaximum: this[i[n]][s].sessionVariables.newViewportMaximum }); this.dispatchEvent(t, a, this) }, a.prototype._mouseEventHandler = function (t) { "undefined" === typeof t.target && t.srcElement && (t.target = t.srcElement); var e, i, n = ot(t), s = t.type; if (t.which ? i = 3 == t.which : t.button && (i = 2 == t.button), a.capturedEventParam && (e = a.capturedEventParam, "mouseup" === s && (a.capturedEventParam = null, e.chart.overlaidCanvas.releaseCapture ? e.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", e.chart._mouseEventHandler, !1)), e.hasOwnProperty(s) && ("mouseup" !== s || e.chart.overlaidCanvas.releaseCapture ? t.target !== e.chart.overlaidCanvas && Y || e[s].call(e.context, n.x, n.y) : t.target !== e.chart.overlaidCanvas && (e.chart.isDrag = !1))), this.interactivityEnabled) if (this._ignoreNextEvent) this._ignoreNextEvent = !1; else if (t.preventManipulation && t.preventManipulation(), t.preventDefault && t.preventDefault(), O && window.console && (window.console.log(s + " --\x3e x: " + n.x + "; y:" + n.y), i && window.console.log(t.which), "mouseup" === s && window.console.log("mouseup")), !i) { if (!a.capturedEventParam && this._events) { for (var o = 0; o < this._events.length; o++)if (this._events[o].hasOwnProperty(s)) { if (i = (e = this._events[o]).bounds, n.x >= i.x1 && n.x <= i.x2 && n.y >= i.y1 && n.y <= i.y2) { e[s].call(e.context, n.x, n.y), "mousedown" === s && !0 === e.capture ? (a.capturedEventParam = e, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === s && (e.chart.overlaidCanvas.releaseCapture ? e.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1)); break } e = null } t.target.style.cursor = e && e.cursor ? e.cursor : this._defaultCursor } s = this.plotArea, (n.x < s.x1 || n.x > s.x2 || n.y < s.y1 || n.y > s.y2) && (this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas()), this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(t) } }, a.prototype._plotAreaMouseDown = function (t, e) { this.isDrag = !0, this.dragStartPoint = { x: t, y: e } }, a.prototype._plotAreaMouseUp = function (t, e) { if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) { var a = e - this.dragStartPoint.y, i = t - this.dragStartPoint.x, n = 0 <= this.zoomType.indexOf("x"), s = 0 <= this.zoomType.indexOf("y"), o = !1; if (this.resetOverlayedCanvas(), "xySwapped" === this.plotInfo.axisPlacement) { var r = s; s = n, n = r } if (this.panEnabled || this.zoomEnabled) { if (this.panEnabled) for (n = s = 0; n < this._axes.length; n++)(a = this._axes[n]).logarithmic ? a.viewportMinimum < a.minimum ? (s = a.minimum / a.viewportMinimum, a.sessionVariables.newViewportMinimum = a.viewportMinimum * s, a.sessionVariables.newViewportMaximum = a.viewportMaximum * s, o = !0) : a.viewportMaximum > a.maximum && (s = a.viewportMaximum / a.maximum, a.sessionVariables.newViewportMinimum = a.viewportMinimum / s, a.sessionVariables.newViewportMaximum = a.viewportMaximum / s, o = !0) : a.viewportMinimum < a.minimum ? (s = a.minimum - a.viewportMinimum, a.sessionVariables.newViewportMinimum = a.viewportMinimum + s, a.sessionVariables.newViewportMaximum = a.viewportMaximum + s, o = !0) : a.viewportMaximum > a.maximum && (s = a.viewportMaximum - a.maximum, a.sessionVariables.newViewportMinimum = a.viewportMinimum - s, a.sessionVariables.newViewportMaximum = a.viewportMaximum - s, o = !0); else if ((!n || 2 < Math.abs(i)) && (!s || 2 < Math.abs(a)) && this.zoomEnabled) { if (!this.dragStartPoint) return; a = n ? this.dragStartPoint.x : this.plotArea.x1, i = s ? this.dragStartPoint.y : this.plotArea.y1, n = n ? t : this.plotArea.x2, s = s ? e : this.plotArea.y2, 2 < Math.abs(a - n) && 2 < Math.abs(i - s) && this._zoomPanToSelectedRegion(a, i, n, s) && (o = !0) } o && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), o && this.zoomEnabled && "none" === this._zoomButton.style.display && (P(this._zoomButton, this._resetButton), w(this, this._zoomButton, "pan"), w(this, this._resetButton, "reset"))) } } if (this.isDrag = !1, "none" !== this.plotInfo.axisPlacement) { if (this.resetOverlayedCanvas(), this.axisX && 0 < this.axisX.length) for (o = 0; o < this.axisX.length; o++)this.axisX[o].crosshair && this.axisX[o].crosshair.enabled && this.axisX[o].renderCrosshair(t, e); if (this.axisX2 && 0 < this.axisX2.length) for (o = 0; o < this.axisX2.length; o++)this.axisX2[o].crosshair && this.axisX2[o].crosshair.enabled && this.axisX2[o].renderCrosshair(t, e); if (this.axisY && 0 < this.axisY.length) for (o = 0; o < this.axisY.length; o++)this.axisY[o].crosshair && this.axisY[o].crosshair.enabled && this.axisY[o].renderCrosshair(t, e); if (this.axisY2 && 0 < this.axisY2.length) for (o = 0; o < this.axisY2.length; o++)this.axisY2[o].crosshair && this.axisY2[o].crosshair.enabled && this.axisY2[o].renderCrosshair(t, e) } }, a.prototype._plotAreaMouseMove = function (t, e) { if (this.isDrag && "none" !== this.plotInfo.axisPlacement) { var a = 0, i = 0, n = a = null, s = (n = 0 <= this.zoomType.indexOf("x"), 0 <= this.zoomType.indexOf("y")), o = this; if ("xySwapped" === this.plotInfo.axisPlacement && (a = s, s = n, n = a), a = this.dragStartPoint.x - t, i = this.dragStartPoint.y - e, 2 < Math.abs(a) && 8 > Math.abs(a) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(t, e), (!n || 2 < Math.abs(a) || !s || 2 < Math.abs(i)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) n = { x1: n ? this.plotArea.x1 + a : this.plotArea.x1, y1: s ? this.plotArea.y1 + i : this.plotArea.y1, x2: n ? this.plotArea.x2 + a : this.plotArea.x2, y2: s ? this.plotArea.y2 + i : this.plotArea.y2 }, clearTimeout(o._panTimerId), o._panTimerId = setTimeout(function (a, i, n, s) { return function () { o._zoomPanToSelectedRegion(a, i, n, s, !0) && (o._dispatchRangeEvent("rangeChanging", "pan"), o.render(), o._dispatchRangeEvent("rangeChanged", "pan"), o.dragStartPoint.x = t, o.dragStartPoint.y = e) } }(n.x1, n.y1, n.x2, n.y2), 0); else if (this.zoomEnabled) { this.resetOverlayedCanvas(), a = this.overlaidCanvasCtx.globalAlpha, this.overlaidCanvasCtx.fillStyle = "#A89896"; i = n ? this.dragStartPoint.x : this.plotArea.x1; var r = s ? this.dragStartPoint.y : this.plotArea.y1, l = n ? t - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, h = s ? e - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1; this.validateRegion(i, r, n ? t : this.plotArea.x2 - this.plotArea.x1, s ? e : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5"), this.overlaidCanvasCtx.globalAlpha = .7, this.overlaidCanvasCtx.fillRect(i, r, l, h), this.overlaidCanvasCtx.globalAlpha = a } } else if (this.toolTip.mouseMoveHandler(t, e), "none" !== this.plotInfo.axisPlacement) { if (this.axisX && 0 < this.axisX.length) for (n = 0; n < this.axisX.length; n++)this.axisX[n].crosshair && this.axisX[n].crosshair.enabled && this.axisX[n].renderCrosshair(t, e); if (this.axisX2 && 0 < this.axisX2.length) for (n = 0; n < this.axisX2.length; n++)this.axisX2[n].crosshair && this.axisX2[n].crosshair.enabled && this.axisX2[n].renderCrosshair(t, e); if (this.axisY && 0 < this.axisY.length) for (n = 0; n < this.axisY.length; n++)this.axisY[n].crosshair && this.axisY[n].crosshair.enabled && this.axisY[n].renderCrosshair(t, e); if (this.axisY2 && 0 < this.axisY2.length) for (n = 0; n < this.axisY2.length; n++)this.axisY2[n].crosshair && this.axisY2[n].crosshair.enabled && this.axisY2[n].renderCrosshair(t, e) } }, a.prototype._zoomPanToSelectedRegion = function (t, e, a, i, n) { if (e = (t = this.validateRegion(t, e, a, i, n)).axesWithValidRange, a = t.axesRanges, t.isValid) for (i = 0; i < e.length; i++)n = a[i], e[i].setViewPortRange(n.val1, n.val2), this.syncCharts && this.syncCharts(n.val1, n.val2); return t.isValid }, a.prototype.validateRegion = function (t, e, a, i, n) { n = n || !1; for (var s = 0 <= this.zoomType.indexOf("x"), o = 0 <= this.zoomType.indexOf("y"), r = !1, l = [], h = [], c = [], d = 0; d < this._axes.length; d++)("axisX" === this._axes[d].type && s || "axisY" === this._axes[d].type && o) && h.push(this._axes[d]); for (o = 0; o < h.length; o++) { s = !1; if ((m = (d = h[o]).convertPixelToValue({ x: t, y: e })) > (u = d.convertPixelToValue({ x: a, y: i }))) var p = u, u = m, m = p; if (d.scaleBreaks) for (p = 0; !s && p < d.scaleBreaks._appliedBreaks.length; p++)s = d.scaleBreaks._appliedBreaks[p].startValue <= m && d.scaleBreaks._appliedBreaks[p].endValue >= u; if (isFinite(d.dataInfo.minDiff)) if (p = d.getApparentDifference(m, u, null, !0), s || !(this.panEnabled && d.scaleBreaks && d.scaleBreaks._appliedBreaks.length) && (d.logarithmic && p < Math.pow(d.dataInfo.minDiff, 3) || !d.logarithmic && p < 3 * Math.abs(d.dataInfo.minDiff)) || m < d.minimum || u > d.maximum) { if (!n) { r = !1; break } } else l.push(d), c.push({ val1: m, val2: u }), r = !0 } return { isValid: r, axesWithValidRange: l, axesRanges: c } }, a.prototype.preparePlotArea = function () { var t = this.plotArea; if (!Y && (0 < t.x1 || 0 < t.y1) && t.ctx.translate(t.x1, t.y1), (this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) { var e = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates; if (this.axisY && 0 < this.axisY.length && this.axisY[0]) { var a = this.axisY[0]; t.x1 = e.x1 < e.x2 ? e.x1 : a.lineCoordinates.x1, t.y1 = e.y1 < a.lineCoordinates.y1 ? e.y1 : a.lineCoordinates.y1, t.x2 = e.x2 > a.lineCoordinates.x2 ? e.x2 : a.lineCoordinates.x2, t.y2 = e.y2 > e.y1 ? e.y2 : a.lineCoordinates.y2, t.width = t.x2 - t.x1, t.height = t.y2 - t.y1 } this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (a = this.axisY2[0], t.x1 = e.x1 < e.x2 ? e.x1 : a.lineCoordinates.x1, t.y1 = e.y1 < a.lineCoordinates.y1 ? e.y1 : a.lineCoordinates.y1, t.x2 = e.x2 > a.lineCoordinates.x2 ? e.x2 : a.lineCoordinates.x2, t.y2 = e.y2 > e.y1 ? e.y2 : a.lineCoordinates.y2, t.width = t.x2 - t.x1, t.height = t.y2 - t.y1) } else e = this.layoutManager.getFreeSpace(), t.x1 = e.x1, t.x2 = e.x2, t.y1 = e.y1, t.y2 = e.y2, t.width = e.width, t.height = e.height; Y || (t.canvas.width = t.width, t.canvas.height = t.height, t.canvas.style.left = t.x1 + "px", t.canvas.style.top = t.y1 + "px", (0 < t.x1 || 0 < t.y1) && t.ctx.translate(-t.x1, -t.y1)), t.layoutManager = new A(t.x1, t.y1, t.x2, t.y2, 2) }, a.prototype.renderIndexLabels = function (t) { var e = t || this.plotArea.ctx, a = this.plotArea, i = 0, n = 0, s = 0, o = 0, r = i = o = n = s = 0, l = 0; for (t = 0; t < this._indexLabels.length; t++) { var h, c, d = this._indexLabels[t], u = d.chartType.toLowerCase(); r = f("indexLabelFontColor", d.dataPoint, d.dataSeries), l = f("indexLabelFontSize", d.dataPoint, d.dataSeries); h = f("indexLabelFontFamily", d.dataPoint, d.dataSeries), c = f("indexLabelFontStyle", d.dataPoint, d.dataSeries); o = f("indexLabelFontWeight", d.dataPoint, d.dataSeries); var m = f("indexLabelBackgroundColor", d.dataPoint, d.dataSeries), x = (n = f("indexLabelMaxWidth", d.dataPoint, d.dataSeries), s = f("indexLabelWrap", d.dataPoint, d.dataSeries), f("indexLabelLineDashType", d.dataPoint, d.dataSeries)), b = f("indexLabelLineColor", d.dataPoint, d.dataSeries), y = p(d.dataPoint.indexLabelLineThickness) ? p(d.dataSeries.options.indexLabelLineThickness) ? 0 : d.dataSeries.options.indexLabelLineThickness : d.dataPoint.indexLabelLineThickness, v = (i = 0 < y ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, { percent: null, total: null }), k = null; (0 <= d.dataSeries.type.indexOf("stacked") || "pie" === d.dataSeries.type || "doughnut" === d.dataSeries.type) && (v = this.getPercentAndTotal(d.dataSeries, d.dataPoint)), (d.dataSeries.indexLabelFormatter || d.dataPoint.indexLabelFormatter) && (k = { chart: this, dataSeries: d.dataSeries, dataPoint: d.dataPoint, index: d.indexKeyword, total: v.total, percent: v.percent }); var M = d.dataPoint.indexLabelFormatter ? d.dataPoint.indexLabelFormatter(k) : d.dataPoint.indexLabel ? this.replaceKeywordsWithValue(d.dataPoint.indexLabel, d.dataPoint, d.dataSeries, null, d.indexKeyword) : d.dataSeries.indexLabelFormatter ? d.dataSeries.indexLabelFormatter(k) : d.dataSeries.indexLabel ? this.replaceKeywordsWithValue(d.dataSeries.indexLabel, d.dataPoint, d.dataSeries, null, d.indexKeyword) : null; if (null !== M && "" !== M) { v = f("indexLabelPlacement", d.dataPoint, d.dataSeries), k = f("indexLabelOrientation", d.dataPoint, d.dataSeries); var T = d.direction, w = d.dataSeries.axisX, P = d.dataSeries.axisY, C = !1; if ((m = new E(e, { x: 0, y: 0, maxWidth: n || .5 * this.width, maxHeight: s ? 5 * l : 1.5 * l, angle: "horizontal" === k ? 0 : -90, text: M, padding: 0, backgroundColor: m, horizontalAlign: "left", fontSize: l, fontFamily: h, fontWeight: o, fontColor: r, fontStyle: c, textBaseline: "top" })).measureText(), d.dataSeries.indexLabelMaxWidth = m.maxWidth, "stackedarea100" === u) { if (d.point.x < a.x1 || d.point.x > a.x2 || d.point.y < a.y1 - 1 || d.point.y > a.y2 + 1) continue } else if ("rangearea" === u || "rangesplinearea" === u) { if (d.dataPoint.x < w.viewportMinimum || d.dataPoint.x > w.viewportMaximum || Math.max.apply(null, d.dataPoint.y) < P.viewportMinimum || Math.min.apply(null, d.dataPoint.y) > P.viewportMaximum) continue } else if (0 <= u.indexOf("line") || 0 <= u.indexOf("area") || 0 <= u.indexOf("bubble") || 0 <= u.indexOf("scatter")) { if (d.dataPoint.x < w.viewportMinimum || d.dataPoint.x > w.viewportMaximum || d.dataPoint.y < P.viewportMinimum || d.dataPoint.y > P.viewportMaximum) continue } else if (0 <= u.indexOf("column") || "waterfall" === u || "error" === u && !d.axisSwapped) { if (d.dataPoint.x < w.viewportMinimum || d.dataPoint.x > w.viewportMaximum || d.bounds.y1 > a.y2 || d.bounds.y2 < a.y1) continue } else if (0 <= u.indexOf("bar") || "error" === u) { if (d.dataPoint.x < w.viewportMinimum || d.dataPoint.x > w.viewportMaximum || d.bounds.x1 > a.x2 || d.bounds.x2 < a.x1) continue } else if ("candlestick" === u || "ohlc" === u) { if (d.dataPoint.x < w.viewportMinimum || d.dataPoint.x > w.viewportMaximum || Math.max.apply(null, d.dataPoint.y) < P.viewportMinimum || Math.min.apply(null, d.dataPoint.y) > P.viewportMaximum) continue } else if (d.dataPoint.x < w.viewportMinimum || d.dataPoint.x > w.viewportMaximum) continue; n = o = 2, "horizontal" === k ? (r = m.width, l = m.height) : (l = m.width, r = m.height), "normal" === this.plotInfo.axisPlacement ? (0 <= u.indexOf("line") || 0 <= u.indexOf("area") ? (v = "auto", o = 4) : 0 <= u.indexOf("stacked") ? "auto" === v && (v = "inside") : "bubble" !== u && "scatter" !== u || (v = "inside"), h = d.point.x - r / 2, "inside" !== v ? (n = a.y1, s = a.y2, 0 < T ? (c = d.point.y - l - o - i) < n && (C = (c = "auto" === v ? Math.max(d.point.y, n) + o + i : n + o + i) + l > d.point.y) : (c = d.point.y + o + i) > s - l - o - i && (C = (c = "auto" === v ? Math.min(d.point.y, s) - l - o - i : s - l - o - i) < d.point.y)) : (n = Math.max(d.bounds.y1, a.y1), s = Math.min(d.bounds.y2, a.y2), i = 0 <= u.indexOf("range") || "error" === u ? 0 < T ? Math.max(d.bounds.y1, a.y1) + l / 2 + o : Math.min(d.bounds.y2, a.y2) - l / 2 - o : (Math.max(d.bounds.y1, a.y1) + Math.min(d.bounds.y2, a.y2)) / 2, 0 < T ? (c = Math.max(d.point.y, i) - l / 2) < n && ("bubble" === u || "scatter" === u) && (c = Math.max(d.point.y - l - o, a.y1 + o)) : (c = Math.min(d.point.y, i) - l / 2) > s - l - o && ("bubble" === u || "scatter" === u) && (c = Math.min(d.point.y + o, a.y2 - l - o)), c = Math.min(c, s - l))) : (0 <= u.indexOf("line") || 0 <= u.indexOf("area") || 0 <= u.indexOf("scatter") ? (v = "auto", n = 4) : 0 <= u.indexOf("stacked") ? "auto" === v && (v = "inside") : "bubble" === u && (v = "inside"), c = d.point.y - l / 2, "inside" !== v ? (o = a.x1, s = a.x2, 0 > T ? (h = d.point.x - r - n - i) < o && (C = (h = "auto" === v ? Math.max(d.point.x, o) + n + i : o + n + i) + r > d.point.x) : (h = d.point.x + n + i) > s - r - n - i && (C = (h = "auto" === v ? Math.min(d.point.x, s) - r - n - i : s - r - n - i) < d.point.x)) : (o = Math.max(d.bounds.x1, a.x1), Math.min(d.bounds.x2, a.x2), i = 0 <= u.indexOf("range") || "error" === u ? 0 > T ? Math.max(d.bounds.x1, a.x1) + r / 2 + n : Math.min(d.bounds.x2, a.x2) - r / 2 - n : (Math.max(d.bounds.x1, a.x1) + Math.min(d.bounds.x2, a.x2)) / 2, h = 0 > T ? Math.max(d.point.x, i) - r / 2 : Math.min(d.point.x, i) - r / 2, h = Math.max(h, o))), "vertical" === k && (c += l), m.x = h, m.y = c, m.render(!0), y && "inside" !== v && (0 > u.indexOf("bar") && ("error" !== u || !d.axisSwapped) && d.point.x > a.x1 && d.point.x < a.x2 || !C) && (0 > u.indexOf("column") && ("error" !== u || d.axisSwapped) && d.point.y > a.y1 && d.point.y < a.y2 || !C) && (e.lineWidth = y, e.strokeStyle = b || "gray", e.setLineDash && e.setLineDash(g(x, y)), e.beginPath(), e.moveTo(d.point.x, d.point.y), 0 <= u.indexOf("bar") || "error" === u && d.axisSwapped ? e.lineTo(h + (0 < d.direction ? 0 : r), c + ("horizontal" === k ? l : -l) / 2) : 0 <= u.indexOf("column") || "error" === u && !d.axisSwapped ? e.lineTo(h + r / 2, c + ((0 < d.direction ? l : -l) + ("horizontal" === k ? l : -l)) / 2) : e.lineTo(h + r / 2, c + ((c < d.point.y ? l : -l) + ("horizontal" === k ? l : -l)) / 2), e.stroke()) } } for (e = { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0, startTimePercent: .7 }, t = 0; t < this._indexLabels.length; t++)m = f("indexLabelBackgroundColor", (d = this._indexLabels[t]).dataPoint, d.dataSeries), d.dataSeries.indexLabelBackgroundColor = p(m) ? Y ? "transparent" : null : m; return e }, a.prototype.renderLine = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i = this._eventManager.ghostCtx; a.save(); var n = this.plotArea; a.beginPath(), a.rect(n.x1, n.y1, n.width, n.height), a.clip(); for (var s, o = [], r = 0; r < t.dataSeriesIndexes.length; r++) { var l = t.dataSeriesIndexes[r], h = this.data[l]; a.lineWidth = h.lineThickness; var d = h.dataPoints, p = "solid"; if (a.setLineDash) { var u = g(h.nullDataLineDashType, h.lineThickness), m = g(p = h.lineDashType, h.lineThickness); a.setLineDash(m) } var x = h.id; this._eventManager.objectMap[x] = { objectType: "dataSeries", dataSeriesIndex: l }, x = c(x), i.strokeStyle = x, i.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0; x = h._colorSet; var b = x = h.lineColor = h.options.lineColor ? h.options.lineColor : x[0]; a.strokeStyle = x; var y, f, v = !0, k = 0; if (a.beginPath(), 0 < d.length) { var M = !1; for (k = 0; k < d.length; k++)if (!((y = d[k].x.getTime ? d[k].x.getTime() : d[k].x) < t.axisX.dataInfo.viewPortMin || y > t.axisX.dataInfo.viewPortMax && (!h.connectNullData || !M))) if ("number" !== typeof d[k].y) 0 < k && !(h.connectNullData || M || v) && (a.stroke(), Y && i.stroke()), M = !0; else { y = t.axisX.convertValueToPixel(y), f = t.axisY.convertValueToPixel(d[k].y); var T = h.dataPointIds[k]; if (this._eventManager.objectMap[T] = { id: T, objectType: "dataPoint", dataSeriesIndex: l, dataPointIndex: k, x1: y, y1: f }, v || M ? (!v && h.connectNullData ? (a.setLineDash && (h.options.nullDataLineDashType || p === h.lineDashType && h.lineDashType !== h.nullDataLineDashType) && (a.stroke(), a.beginPath(), a.moveTo(s.x, s.y), p = h.nullDataLineDashType, a.setLineDash(u)), a.lineTo(y, f), Y && i.lineTo(y, f)) : (a.beginPath(), a.moveTo(y, f), Y && (i.beginPath(), i.moveTo(y, f))), M = v = !1) : (a.lineTo(y, f), Y && i.lineTo(y, f), 0 == k % 500 && (a.stroke(), a.beginPath(), a.moveTo(y, f), Y && (i.stroke(), i.beginPath(), i.moveTo(y, f)))), s = { x: y, y: f }, k < d.length - 1 && (b !== (d[k].lineColor || x) || p !== (d[k].lineDashType || h.lineDashType)) && (a.stroke(), a.beginPath(), a.moveTo(y, f), b = d[k].lineColor || x, a.strokeStyle = b, a.setLineDash && (d[k].lineDashType ? (p = d[k].lineDashType, a.setLineDash(g(p, h.lineThickness))) : (p = h.lineDashType, a.setLineDash(m)))), 0 < d[k].markerSize || 0 < h.markerSize) { var w = h.getMarkerProperties(k, y, f, a); o.push(w), T = c(T), Y && o.push({ x: y, y: f, ctx: i, type: w.type, size: w.size, color: T, borderColor: T, borderThickness: w.borderThickness }) } (d[k].indexLabel || h.indexLabel || d[k].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: d[k], dataSeries: h, point: { x: y, y: f }, direction: 0 > d[k].y === t.axisY.reversed ? 1 : -1, color: x }) } a.stroke(), Y && i.stroke() } } return et.drawMarkers(o), Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(n.x1, n.y1, n.width, n.height), i.beginPath()), a.restore(), a.beginPath(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderStepLine = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i = this._eventManager.ghostCtx; a.save(); var n = this.plotArea; a.beginPath(), a.rect(n.x1, n.y1, n.width, n.height), a.clip(); for (var s, o = [], r = 0; r < t.dataSeriesIndexes.length; r++) { var l = t.dataSeriesIndexes[r], h = this.data[l]; a.lineWidth = h.lineThickness; var d = h.dataPoints, p = "solid"; if (a.setLineDash) { var u = g(h.nullDataLineDashType, h.lineThickness), m = g(p = h.lineDashType, h.lineThickness); a.setLineDash(m) } var x = h.id; this._eventManager.objectMap[x] = { objectType: "dataSeries", dataSeriesIndex: l }, x = c(x), i.strokeStyle = x, i.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0; x = h._colorSet; var b = x = h.lineColor = h.options.lineColor ? h.options.lineColor : x[0]; a.strokeStyle = x; var y, f, v = !0, k = 0; if (a.beginPath(), 0 < d.length) { var M = !1; for (k = 0; k < d.length; k++)if (!((y = d[k].getTime ? d[k].x.getTime() : d[k].x) < t.axisX.dataInfo.viewPortMin || y > t.axisX.dataInfo.viewPortMax && (!h.connectNullData || !M))) if ("number" !== typeof d[k].y) 0 < k && !(h.connectNullData || M || v) && (a.stroke(), Y && i.stroke()), M = !0; else { var T = f; y = t.axisX.convertValueToPixel(y), f = t.axisY.convertValueToPixel(d[k].y); var w = h.dataPointIds[k]; this._eventManager.objectMap[w] = { id: w, objectType: "dataPoint", dataSeriesIndex: l, dataPointIndex: k, x1: y, y1: f }, v || M ? (!v && h.connectNullData ? (a.setLineDash && (h.options.nullDataLineDashType || p === h.lineDashType && h.lineDashType !== h.nullDataLineDashType) && (a.stroke(), a.beginPath(), a.moveTo(s.x, s.y), p = h.nullDataLineDashType, a.setLineDash(u)), a.lineTo(y, T), a.lineTo(y, f), Y && (i.lineTo(y, T), i.lineTo(y, f))) : (a.beginPath(), a.moveTo(y, f), Y && (i.beginPath(), i.moveTo(y, f))), M = v = !1) : (a.lineTo(y, T), Y && i.lineTo(y, T), a.lineTo(y, f), Y && i.lineTo(y, f), 0 == k % 500 && (a.stroke(), a.beginPath(), a.moveTo(y, f), Y && (i.stroke(), i.beginPath(), i.moveTo(y, f)))), s = { x: y, y: f }, k < d.length - 1 && (b !== (d[k].lineColor || x) || p !== (d[k].lineDashType || h.lineDashType)) && (a.stroke(), a.beginPath(), a.moveTo(y, f), b = d[k].lineColor || x, a.strokeStyle = b, a.setLineDash && (d[k].lineDashType ? (p = d[k].lineDashType, a.setLineDash(g(p, h.lineThickness))) : (p = h.lineDashType, a.setLineDash(m)))), (0 < d[k].markerSize || 0 < h.markerSize) && (T = h.getMarkerProperties(k, y, f, a), o.push(T), w = c(w), Y && o.push({ x: y, y: f, ctx: i, type: T.type, size: T.size, color: w, borderColor: w, borderThickness: T.borderThickness })), (d[k].indexLabel || h.indexLabel || d[k].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: d[k], dataSeries: h, point: { x: y, y: f }, direction: 0 > d[k].y === t.axisY.reversed ? 1 : -1, color: x }) } a.stroke(), Y && i.stroke() } } return et.drawMarkers(o), Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(n.x1, n.y1, n.width, n.height), i.beginPath()), a.restore(), a.beginPath(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderSpline = function (t) { function e(t) { if (0 < (t = s(t, 2)).length) { i.beginPath(), Y && n.beginPath(), i.moveTo(t[0].x, t[0].y), t[0].newStrokeStyle && (i.strokeStyle = t[0].newStrokeStyle), t[0].newLineDashArray && i.setLineDash(t[0].newLineDashArray), Y && n.moveTo(t[0].x, t[0].y); for (var e = 0; e < t.length - 3; e += 3)i.bezierCurveTo(t[e + 1].x, t[e + 1].y, t[e + 2].x, t[e + 2].y, t[e + 3].x, t[e + 3].y), Y && n.bezierCurveTo(t[e + 1].x, t[e + 1].y, t[e + 2].x, t[e + 2].y, t[e + 3].x, t[e + 3].y), (0 < e && 0 === e % 3e3 || t[e + 3].newStrokeStyle || t[e + 3].newLineDashArray) && (i.stroke(), i.beginPath(), i.moveTo(t[e + 3].x, t[e + 3].y), t[e + 3].newStrokeStyle && (i.strokeStyle = t[e + 3].newStrokeStyle), t[e + 3].newLineDashArray && i.setLineDash(t[e + 3].newLineDashArray), Y && (n.stroke(), n.beginPath(), n.moveTo(t[e + 3].x, t[e + 3].y))); i.stroke(), Y && n.stroke() } } var a = t.targetCanvasCtx || this.plotArea.ctx, i = Y ? this._preRenderCtx : a; if (!(0 >= t.dataSeriesIndexes.length)) { var n = this._eventManager.ghostCtx; i.save(); var o = this.plotArea; i.beginPath(), i.rect(o.x1, o.y1, o.width, o.height), i.clip(); for (var r = [], l = 0; l < t.dataSeriesIndexes.length; l++) { var h = t.dataSeriesIndexes[l], d = this.data[h]; i.lineWidth = d.lineThickness; var p = d.dataPoints, u = "solid"; if (i.setLineDash) { var m = g(d.nullDataLineDashType, d.lineThickness), x = g(u = d.lineDashType, d.lineThickness); i.setLineDash(x) } var b = d.id; this._eventManager.objectMap[b] = { objectType: "dataSeries", dataSeriesIndex: h }, b = c(b), n.strokeStyle = b, n.lineWidth = 0 < d.lineThickness ? Math.max(d.lineThickness, 4) : 0; b = d._colorSet; var y = b = d.lineColor = d.options.lineColor ? d.options.lineColor : b[0]; i.strokeStyle = b; var f, v, k = 0, M = []; if (i.beginPath(), 0 < p.length) for (v = !1, k = 0; k < p.length; k++)if (!((f = p[k].getTime ? p[k].x.getTime() : p[k].x) < t.axisX.dataInfo.viewPortMin || f > t.axisX.dataInfo.viewPortMax && (!d.connectNullData || !v))) if ("number" !== typeof p[k].y) 0 < k && !v && (d.connectNullData ? i.setLineDash && 0 < M.length && (d.options.nullDataLineDashType || !p[k - 1].lineDashType) && (M[M.length - 1].newLineDashArray = m, u = d.nullDataLineDashType) : (e(M), M = [])), v = !0; else { f = t.axisX.convertValueToPixel(f), v = t.axisY.convertValueToPixel(p[k].y); var T = d.dataPointIds[k]; if (this._eventManager.objectMap[T] = { id: T, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: k, x1: f, y1: v }, M[M.length] = { x: f, y: v }, k < p.length - 1 && (y !== (p[k].lineColor || b) || u !== (p[k].lineDashType || d.lineDashType)) && (y = p[k].lineColor || b, M[M.length - 1].newStrokeStyle = y, i.setLineDash && (p[k].lineDashType ? (u = p[k].lineDashType, M[M.length - 1].newLineDashArray = g(u, d.lineThickness)) : (u = d.lineDashType, M[M.length - 1].newLineDashArray = x))), 0 < p[k].markerSize || 0 < d.markerSize) { var w = d.getMarkerProperties(k, f, v, i); r.push(w), T = c(T), Y && r.push({ x: f, y: v, ctx: n, type: w.type, size: w.size, color: T, borderColor: T, borderThickness: w.borderThickness }) } (p[k].indexLabel || d.indexLabel || p[k].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({ chartType: "spline", dataPoint: p[k], dataSeries: d, point: { x: f, y: v }, direction: 0 > p[k].y === t.axisY.reversed ? 1 : -1, color: b }), v = !1 } e(M) } return et.drawMarkers(r), Y && (a.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(o.x1, o.y1, o.width, o.height), n.beginPath()), i.restore(), i.beginPath(), { source: a, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderColumn = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s, o = null, r = this.plotArea, l = 0, h = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), d = (l = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, this.plotArea.width / t.plotType.totalDataSeries * .9) << 0), p = t.axisX.dataInfo.minDiff; for (isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : r.width * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && l > d && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, d)), !this.dataPointMaxWidth && this.dataPointMinWidth && d < l && (d = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, l)), p < l && (p = l), p > d && (p = d), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(r.x1, r.y1, r.width, r.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.clip()), d = 0; d < t.dataSeriesIndexes.length; d++) { var u = t.dataSeriesIndexes[d], m = this.data[u], x = m.dataPoints; if (0 < x.length) { var g = !!(5 < p && m.bevelEnabled); for (l = 0; l < x.length; l++)if (!((s = x[l].getTime ? x[l].x.getTime() : x[l].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && "number" === typeof x[l].y) { i = t.axisX.convertValueToPixel(s), n = t.axisY.convertValueToPixel(x[l].y), i = t.axisX.reversed ? i + t.plotType.totalDataSeries * p / 2 - (t.previousDataSeriesCount + d) * p << 0 : i - t.plotType.totalDataSeries * p / 2 + (t.previousDataSeriesCount + d) * p << 0; var b, y = t.axisX.reversed ? i - p << 0 : i + p << 0; 0 <= x[l].y ? b = h : (b = n, n = h), n > b && (o = n, n = b, b = o), o = x[l].color ? x[l].color : m._colorSet[l % m._colorSet.length], dt(a, i, n, y, b, o, 0, null, g && 0 <= x[l].y, 0 > x[l].y && g, !1, !1, m.fillOpacity), o = m.dataPointIds[l], this._eventManager.objectMap[o] = { id: o, objectType: "dataPoint", dataSeriesIndex: u, dataPointIndex: l, x1: i, y1: n, x2: y, y2: b }, o = c(o), Y && dt(this._eventManager.ghostCtx, i, n, y, b, o, 0, null, !1, !1, !1, !1), (x[l].indexLabel || m.indexLabel || x[l].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: x[l], dataSeries: m, point: { x: i + (y - i) / 2, y: 0 > x[l].y === t.axisY.reversed ? n : b }, direction: 0 > x[l].y === t.axisY.reversed ? 1 : -1, bounds: { x1: i, y1: Math.min(n, b), x2: y, y2: Math.max(n, b) }, color: o }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.yScaleAnimation, easingFunction: tt.easing.easeOutQuart, animationBase: h < t.axisY.bounds.y1 ? t.axisY.bounds.y1 : h > t.axisY.bounds.y2 ? t.axisY.bounds.y2 : h } } }, a.prototype.renderStackedColumn = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s = null, o = this.plotArea, r = [], l = [], h = [], d = [], p = 0, u = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0); p = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; i = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0; var m = t.axisX.dataInfo.minDiff; isFinite(m) || (m = .3 * Math.abs(t.axisX.range)), m = this.options.dataPointWidth ? this.dataPointWidth : o.width * (t.axisX.logarithmic ? Math.log(m) / Math.log(t.axisX.range) : Math.abs(m) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && p > i && (p = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, i)), !this.dataPointMaxWidth && this.dataPointMinWidth && i < p && (i = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, p)), m < p && (m = p), m > i && (m = i), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(o.x1, o.y1, o.width, o.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip()); for (var x = 0; x < t.dataSeriesIndexes.length; x++) { var g = t.dataSeriesIndexes[x], b = this.data[g], y = b.dataPoints; if (0 < y.length) { var f = !!(5 < m && b.bevelEnabled); for (a.strokeStyle = "#4572A7 ", p = 0; p < y.length; p++)if (!((s = y[p].x.getTime ? y[p].x.getTime() : y[p].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && "number" === typeof y[p].y) { var v, k = (i = t.axisX.convertValueToPixel(s)) - t.plotType.plotUnits.length * m / 2 + t.index * m << 0, M = k + m << 0; if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < y[p].y) h[s] = y[p].y + (h[s] ? h[s] : 0), 0 < h[s] && (n = t.axisY.convertValueToPixel(h[s]), v = "undefined" !== typeof r[s] ? r[s] : u, r[s] = n); else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= y[p].y) d[s] = y[p].y + (d[s] ? d[s] : 0), v = t.axisY.convertValueToPixel(d[s]), n = "undefined" !== typeof l[s] ? l[s] : u, l[s] = v; else if (n = t.axisY.convertValueToPixel(y[p].y), 0 <= y[p].y) { var T = "undefined" !== typeof r[s] ? r[s] : 0; n -= T, v = u - T, r[s] = T + (v - n) } else v = n + (T = l[s] ? l[s] : 0), n = u + T, l[s] = T + (v - n); s = y[p].color ? y[p].color : b._colorSet[p % b._colorSet.length], dt(a, k, n, M, v, s, 0, null, f && 0 <= y[p].y, 0 > y[p].y && f, !1, !1, b.fillOpacity), s = b.dataPointIds[p], this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: g, dataPointIndex: p, x1: k, y1: n, x2: M, y2: v }, s = c(s), Y && dt(this._eventManager.ghostCtx, k, n, M, v, s, 0, null, !1, !1, !1, !1), (y[p].indexLabel || b.indexLabel || y[p].indexLabelFormatter || b.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: y[p], dataSeries: b, point: { x: i, y: 0 <= y[p].y ? n : v }, direction: 0 > y[p].y === t.axisY.reversed ? 1 : -1, bounds: { x1: k, y1: Math.min(n, v), x2: M, y2: Math.max(n, v) }, color: s }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.yScaleAnimation, easingFunction: tt.easing.easeOutQuart, animationBase: u < t.axisY.bounds.y1 ? t.axisY.bounds.y1 : u > t.axisY.bounds.y2 ? t.axisY.bounds.y2 : u } } }, a.prototype.renderStackedColumn100 = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s = null, o = this.plotArea, r = [], l = [], h = [], d = [], p = 0, u = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0); p = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; i = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0; var m = t.axisX.dataInfo.minDiff; isFinite(m) || (m = .3 * Math.abs(t.axisX.range)), m = this.options.dataPointWidth ? this.dataPointWidth : o.width * (t.axisX.logarithmic ? Math.log(m) / Math.log(t.axisX.range) : Math.abs(m) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && p > i && (p = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, i)), !this.dataPointMaxWidth && this.dataPointMinWidth && i < p && (i = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, p)), m < p && (m = p), m > i && (m = i), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(o.x1, o.y1, o.width, o.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip()); for (var x = 0; x < t.dataSeriesIndexes.length; x++) { var g = t.dataSeriesIndexes[x], b = this.data[g], y = b.dataPoints; if (0 < y.length) { var f = !!(5 < m && b.bevelEnabled); for (p = 0; p < y.length; p++)if (!((s = y[p].x.getTime ? y[p].x.getTime() : y[p].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && "number" === typeof y[p].y) { i = t.axisX.convertValueToPixel(s), n = 0 !== t.dataPointYSums[s] ? y[p].y / t.dataPointYSums[s] * 100 : 0; var v, k = i - t.plotType.plotUnits.length * m / 2 + t.index * m << 0, M = k + m << 0; if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < y[p].y) { if (h[s] = n + ("undefined" !== typeof h[s] ? h[s] : 0), 0 >= h[s]) continue; n = t.axisY.convertValueToPixel(h[s]), v = r[s] ? r[s] : u, r[s] = n } else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= y[p].y) d[s] = n + ("undefined" !== typeof d[s] ? d[s] : 0), v = t.axisY.convertValueToPixel(d[s]), n = l[s] ? l[s] : u, l[s] = v; else if (n = t.axisY.convertValueToPixel(n), 0 <= y[p].y) { var T = "undefined" !== typeof r[s] ? r[s] : 0; n -= T, v = u - T, t.dataSeriesIndexes.length - 1 === x && 1 >= Math.abs(o.y1 - n) && (n = o.y1), r[s] = T + (v - n) } else v = n + (T = "undefined" !== typeof l[s] ? l[s] : 0), n = u + T, t.dataSeriesIndexes.length - 1 === x && 1 >= Math.abs(o.y2 - v) && (v = o.y2), l[s] = T + (v - n); s = y[p].color ? y[p].color : b._colorSet[p % b._colorSet.length], dt(a, k, n, M, v, s, 0, null, f && 0 <= y[p].y, 0 > y[p].y && f, !1, !1, b.fillOpacity), s = b.dataPointIds[p], this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: g, dataPointIndex: p, x1: k, y1: n, x2: M, y2: v }, s = c(s), Y && dt(this._eventManager.ghostCtx, k, n, M, v, s, 0, null, !1, !1, !1, !1), (y[p].indexLabel || b.indexLabel || y[p].indexLabelFormatter || b.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn100", dataPoint: y[p], dataSeries: b, point: { x: i, y: 0 <= y[p].y ? n : v }, direction: 0 > y[p].y === t.axisY.reversed ? 1 : -1, bounds: { x1: k, y1: Math.min(n, v), x2: M, y2: Math.max(n, v) }, color: s }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.yScaleAnimation, easingFunction: tt.easing.easeOutQuart, animationBase: u < t.axisY.bounds.y1 ? t.axisY.bounds.y1 : u > t.axisY.bounds.y2 ? t.axisY.bounds.y2 : u } } }, a.prototype.renderBar = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s, o = null, r = this.plotArea, l = 0, h = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), d = (l = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, this.plotArea.height / t.plotType.totalDataSeries * .9) << 0), p = t.axisX.dataInfo.minDiff; for (isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.options.dataPointWidth ? this.dataPointWidth : r.height * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && l > d && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, d)), !this.dataPointMaxWidth && this.dataPointMinWidth && d < l && (d = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, l)), p < l && (p = l), p > d && (p = d), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(r.x1, r.y1, r.width, r.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.clip()), d = 0; d < t.dataSeriesIndexes.length; d++) { var u = t.dataSeriesIndexes[d], m = this.data[u], x = m.dataPoints; if (0 < x.length) { var g = !!(5 < p && m.bevelEnabled); for (a.strokeStyle = "#4572A7 ", l = 0; l < x.length; l++)if (!((s = x[l].getTime ? x[l].x.getTime() : x[l].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && "number" === typeof x[l].y) { n = t.axisX.convertValueToPixel(s), i = t.axisY.convertValueToPixel(x[l].y), n = t.axisX.reversed ? n + t.plotType.totalDataSeries * p / 2 - (t.previousDataSeriesCount + d) * p << 0 : n - t.plotType.totalDataSeries * p / 2 + (t.previousDataSeriesCount + d) * p << 0; var b, y = t.axisX.reversed ? n - p << 0 : n + p << 0; 0 <= x[l].y ? b = h : (b = i, i = h), o = x[l].color ? x[l].color : m._colorSet[l % m._colorSet.length], dt(a, b, n, i, y, o, 0, null, g, !1, !1, !1, m.fillOpacity), o = m.dataPointIds[l], this._eventManager.objectMap[o] = { id: o, objectType: "dataPoint", dataSeriesIndex: u, dataPointIndex: l, x1: b, y1: n, x2: i, y2: y }, o = c(o), Y && dt(this._eventManager.ghostCtx, b, n, i, y, o, 0, null, !1, !1, !1, !1), (x[l].indexLabel || m.indexLabel || x[l].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: x[l], dataSeries: m, point: { x: 0 <= x[l].y ? i : b, y: n + (y - n) / 2 }, direction: 0 > x[l].y === t.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(b, i), y1: n, x2: Math.max(b, i), y2: y }, color: o }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.xScaleAnimation, easingFunction: tt.easing.easeOutQuart, animationBase: h < t.axisY.bounds.x1 ? t.axisY.bounds.x1 : h > t.axisY.bounds.x2 ? t.axisY.bounds.x2 : h } } }, a.prototype.renderStackedBar = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s = null, o = this.plotArea, r = [], l = [], h = [], d = [], p = 0, u = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0); p = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0; var m = t.axisX.dataInfo.minDiff; isFinite(m) || (m = .3 * Math.abs(t.axisX.range)), m = this.options.dataPointWidth ? this.dataPointWidth : o.height * (t.axisX.logarithmic ? Math.log(m) / Math.log(t.axisX.range) : Math.abs(m) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && p > n && (p = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, n)), !this.dataPointMaxWidth && this.dataPointMinWidth && n < p && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, p)), m < p && (m = p), m > n && (m = n), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(o.x1, o.y1, o.width, o.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip()); for (var x = 0; x < t.dataSeriesIndexes.length; x++) { var g = t.dataSeriesIndexes[x], b = this.data[g], y = b.dataPoints; if (0 < y.length) { var f = !!(5 < m && b.bevelEnabled); for (a.strokeStyle = "#4572A7 ", p = 0; p < y.length; p++)if (!((s = y[p].x.getTime ? y[p].x.getTime() : y[p].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && "number" === typeof y[p].y) { var v, k = (n = t.axisX.convertValueToPixel(s)) - t.plotType.plotUnits.length * m / 2 + t.index * m << 0, M = k + m << 0; if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < y[p].y) h[s] = y[p].y + (h[s] ? h[s] : 0), 0 < h[s] && (v = r[s] ? r[s] : u, r[s] = i = t.axisY.convertValueToPixel(h[s])); else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= y[p].y) d[s] = y[p].y + (d[s] ? d[s] : 0), i = l[s] ? l[s] : u, l[s] = v = t.axisY.convertValueToPixel(d[s]); else if (i = t.axisY.convertValueToPixel(y[p].y), 0 <= y[p].y) { var T = r[s] ? r[s] : 0; v = u + T, i += T, r[s] = T + (i - v) } else v = i - (T = l[s] ? l[s] : 0), i = u - T, l[s] = T + (i - v); s = y[p].color ? y[p].color : b._colorSet[p % b._colorSet.length], dt(a, v, k, i, M, s, 0, null, f, !1, !1, !1, b.fillOpacity), s = b.dataPointIds[p], this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: g, dataPointIndex: p, x1: v, y1: k, x2: i, y2: M }, s = c(s), Y && dt(this._eventManager.ghostCtx, v, k, i, M, s, 0, null, !1, !1, !1, !1), (y[p].indexLabel || b.indexLabel || y[p].indexLabelFormatter || b.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar", dataPoint: y[p], dataSeries: b, point: { x: 0 <= y[p].y ? i : v, y: n }, direction: 0 > y[p].y === t.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(v, i), y1: k, x2: Math.max(v, i), y2: M }, color: s }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.xScaleAnimation, easingFunction: tt.easing.easeOutQuart, animationBase: u < t.axisY.bounds.x1 ? t.axisY.bounds.x1 : u > t.axisY.bounds.x2 ? t.axisY.bounds.x2 : u } } }, a.prototype.renderStackedBar100 = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s = null, o = this.plotArea, r = [], l = [], h = [], d = [], p = 0, u = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0); p = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0; var m = t.axisX.dataInfo.minDiff; isFinite(m) || (m = .3 * Math.abs(t.axisX.range)), m = this.options.dataPointWidth ? this.dataPointWidth : o.height * (t.axisX.logarithmic ? Math.log(m) / Math.log(t.axisX.range) : Math.abs(m) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && p > n && (p = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, n)), !this.dataPointMaxWidth && this.dataPointMinWidth && n < p && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, p)), m < p && (m = p), m > n && (m = n), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(o.x1, o.y1, o.width, o.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip()); for (var x = 0; x < t.dataSeriesIndexes.length; x++) { var g = t.dataSeriesIndexes[x], b = this.data[g], y = b.dataPoints; if (0 < y.length) { var f = !!(5 < m && b.bevelEnabled); for (a.strokeStyle = "#4572A7 ", p = 0; p < y.length; p++)if (!((s = y[p].x.getTime ? y[p].x.getTime() : y[p].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && "number" === typeof y[p].y) { var v; n = t.axisX.convertValueToPixel(s), v = 0 !== t.dataPointYSums[s] ? y[p].y / t.dataPointYSums[s] * 100 : 0; var k = n - t.plotType.plotUnits.length * m / 2 + t.index * m << 0, M = k + m << 0; if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < y[p].y) { if (h[s] = v + (h[s] ? h[s] : 0), 0 >= h[s]) continue; v = r[s] ? r[s] : u, r[s] = i = t.axisY.convertValueToPixel(h[s]) } else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= y[p].y) d[s] = v + (d[s] ? d[s] : 0), i = l[s] ? l[s] : u, l[s] = v = t.axisY.convertValueToPixel(d[s]); else if (i = t.axisY.convertValueToPixel(v), 0 <= y[p].y) { var T = r[s] ? r[s] : 0; v = u + T, i += T, t.dataSeriesIndexes.length - 1 === x && 1 >= Math.abs(o.x2 - i) && (i = o.x2), r[s] = T + (i - v) } else v = i - (T = l[s] ? l[s] : 0), i = u - T, t.dataSeriesIndexes.length - 1 === x && 1 >= Math.abs(o.x1 - v) && (v = o.x1), l[s] = T + (i - v); s = y[p].color ? y[p].color : b._colorSet[p % b._colorSet.length], dt(a, v, k, i, M, s, 0, null, f, !1, !1, !1, b.fillOpacity), s = b.dataPointIds[p], this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: g, dataPointIndex: p, x1: v, y1: k, x2: i, y2: M }, s = c(s), Y && dt(this._eventManager.ghostCtx, v, k, i, M, s, 0, null, !1, !1, !1, !1), (y[p].indexLabel || b.indexLabel || y[p].indexLabelFormatter || b.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: y[p], dataSeries: b, point: { x: 0 <= y[p].y ? i : v, y: n }, direction: 0 > y[p].y === t.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(v, i), y1: k, x2: Math.max(v, i), y2: M }, color: s }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.xScaleAnimation, easingFunction: tt.easing.easeOutQuart, animationBase: u < t.axisY.bounds.x1 ? t.axisY.bounds.x1 : u > t.axisY.bounds.x2 ? t.axisY.bounds.x2 : u } } }, a.prototype.renderArea = function (t) { var e, a; function i() { w && (0 < x.lineThickness && s.stroke(), t.axisY.logarithmic || 0 >= t.axisY.viewportMinimum && 0 <= t.axisY.viewportMaximum ? k = T : 0 > t.axisY.viewportMaximum ? k = h.y1 : 0 < t.axisY.viewportMinimum && (k = l.y2), s.lineTo(y, k), s.lineTo(w.x, k), s.closePath(), s.globalAlpha = x.fillOpacity, s.fill(), s.globalAlpha = 1, Y && (r.lineTo(y, k), r.lineTo(w.x, k), r.closePath(), r.fill()), s.beginPath(), s.moveTo(y, f), r.beginPath(), r.moveTo(y, f), w = { x: y, y: f }) } var n = t.targetCanvasCtx || this.plotArea.ctx, s = Y ? this._preRenderCtx : n; if (!(0 >= t.dataSeriesIndexes.length)) { var o, r = this._eventManager.ghostCtx, l = t.axisX.lineCoordinates, h = t.axisY.lineCoordinates, d = [], p = this.plotArea; s.save(), Y && r.save(), s.beginPath(), s.rect(p.x1, p.y1, p.width, p.height), s.clip(), Y && (r.beginPath(), r.rect(p.x1, p.y1, p.width, p.height), r.clip()); for (var u = 0; u < t.dataSeriesIndexes.length; u++) { var m = t.dataSeriesIndexes[u], x = this.data[m], b = x.dataPoints; d = x.id; this._eventManager.objectMap[d] = { objectType: "dataSeries", dataSeriesIndex: m }, d = c(d), r.fillStyle = d, d = [], e = !0; var y, f, v, k, M = 0, T = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), w = null; if (0 < b.length) { var P = x._colorSet[M % x._colorSet.length], C = x.lineColor = x.options.lineColor || P, S = C; if (s.fillStyle = P, s.strokeStyle = C, s.lineWidth = x.lineThickness, a = "solid", s.setLineDash) { var A = g(x.nullDataLineDashType, x.lineThickness), E = g(a = x.lineDashType, x.lineThickness); s.setLineDash(E) } for (var _ = !0; M < b.length; M++)if (!((v = b[M].x.getTime ? b[M].x.getTime() : b[M].x) < t.axisX.dataInfo.viewPortMin || v > t.axisX.dataInfo.viewPortMax && (!x.connectNullData || !_))) if ("number" !== typeof b[M].y) x.connectNullData || _ || e || i(), _ = !0; else { y = t.axisX.convertValueToPixel(v), f = t.axisY.convertValueToPixel(b[M].y), e || _ ? (!e && x.connectNullData ? (s.setLineDash && (x.options.nullDataLineDashType || a === x.lineDashType && x.lineDashType !== x.nullDataLineDashType) && (e = y, a = f, y = o.x, f = o.y, i(), s.moveTo(o.x, o.y), y = e, f = a, w = o, a = x.nullDataLineDashType, s.setLineDash(A)), s.lineTo(y, f), Y && r.lineTo(y, f)) : (s.beginPath(), s.moveTo(y, f), Y && (r.beginPath(), r.moveTo(y, f)), w = { x: y, y: f }), _ = e = !1) : (s.lineTo(y, f), Y && r.lineTo(y, f), 0 == M % 250 && i()), o = { x: y, y: f }, M < b.length - 1 && (S !== (b[M].lineColor || C) || a !== (b[M].lineDashType || x.lineDashType)) && (i(), S = b[M].lineColor || C, s.strokeStyle = S, s.setLineDash && (b[M].lineDashType ? (a = b[M].lineDashType, s.setLineDash(g(a, x.lineThickness))) : (a = x.lineDashType, s.setLineDash(E)))); var F = x.dataPointIds[M]; this._eventManager.objectMap[F] = { id: F, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: M, x1: y, y1: f }, 0 !== b[M].markerSize && (0 < b[M].markerSize || 0 < x.markerSize) && (v = x.getMarkerProperties(M, y, f, s), d.push(v), F = c(F), Y && d.push({ x: y, y: f, ctx: r, type: v.type, size: v.size, color: F, borderColor: F, borderThickness: v.borderThickness })), (b[M].indexLabel || x.indexLabel || b[M].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: b[M], dataSeries: x, point: { x: y, y: f }, direction: 0 > b[M].y === t.axisY.reversed ? 1 : -1, color: P }) } i(), et.drawMarkers(d) } } return Y && (n.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), s.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && s.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && s.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), s.clearRect(p.x1, p.y1, p.width, p.height), this._eventManager.ghostCtx.restore()), s.restore(), { source: n, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderSplineArea = function (t) { function e() { var e = s(M, 2); if (0 < e.length) { if (0 < u.lineThickness) { i.beginPath(), i.moveTo(e[0].x, e[0].y), e[0].newStrokeStyle && (i.strokeStyle = e[0].newStrokeStyle), e[0].newLineDashArray && i.setLineDash(e[0].newLineDashArray); for (var a = 0; a < e.length - 3; a += 3)i.bezierCurveTo(e[a + 1].x, e[a + 1].y, e[a + 2].x, e[a + 2].y, e[a + 3].x, e[a + 3].y), Y && n.bezierCurveTo(e[a + 1].x, e[a + 1].y, e[a + 2].x, e[a + 2].y, e[a + 3].x, e[a + 3].y), (e[a + 3].newStrokeStyle || e[a + 3].newLineDashArray) && (i.stroke(), i.beginPath(), i.moveTo(e[a + 3].x, e[a + 3].y), e[a + 3].newStrokeStyle && (i.strokeStyle = e[a + 3].newStrokeStyle), e[a + 3].newLineDashArray && i.setLineDash(e[a + 3].newLineDashArray)); i.stroke() } for (i.beginPath(), i.moveTo(e[0].x, e[0].y), Y && (n.beginPath(), n.moveTo(e[0].x, e[0].y)), a = 0; a < e.length - 3; a += 3)i.bezierCurveTo(e[a + 1].x, e[a + 1].y, e[a + 2].x, e[a + 2].y, e[a + 3].x, e[a + 3].y), Y && n.bezierCurveTo(e[a + 1].x, e[a + 1].y, e[a + 2].x, e[a + 2].y, e[a + 3].x, e[a + 3].y); t.axisY.logarithmic || 0 >= t.axisY.viewportMinimum && 0 <= t.axisY.viewportMaximum ? y = v : 0 > t.axisY.viewportMaximum ? y = r.y1 : 0 < t.axisY.viewportMinimum && (y = o.y2), k = { x: e[0].x, y: e[0].y }, i.lineTo(e[e.length - 1].x, y), i.lineTo(k.x, y), i.closePath(), i.globalAlpha = u.fillOpacity, i.fill(), i.globalAlpha = 1, Y && (n.lineTo(e[e.length - 1].x, y), n.lineTo(k.x, y), n.closePath(), n.fill()) } } var a = t.targetCanvasCtx || this.plotArea.ctx, i = Y ? this._preRenderCtx : a; if (!(0 >= t.dataSeriesIndexes.length)) { var n = this._eventManager.ghostCtx, o = t.axisX.lineCoordinates, r = t.axisY.lineCoordinates, l = [], h = this.plotArea; i.save(), Y && n.save(), i.beginPath(), i.rect(h.x1, h.y1, h.width, h.height), i.clip(), Y && (n.beginPath(), n.rect(h.x1, h.y1, h.width, h.height), n.clip()); for (var d = 0; d < t.dataSeriesIndexes.length; d++) { var p = t.dataSeriesIndexes[d], u = this.data[p], m = u.dataPoints; l = u.id; this._eventManager.objectMap[l] = { objectType: "dataSeries", dataSeriesIndex: p }, l = c(l), n.fillStyle = l; l = []; var x, b, y, f = 0, v = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), k = null, M = []; if (0 < m.length) { var T = u._colorSet[f % u._colorSet.length], w = u.lineColor = u.options.lineColor || T, P = w; i.fillStyle = T, i.strokeStyle = w, i.lineWidth = u.lineThickness; var C = "solid"; if (i.setLineDash) { var S = g(u.nullDataLineDashType, u.lineThickness), A = g(C = u.lineDashType, u.lineThickness); i.setLineDash(A) } for (b = !1; f < m.length; f++)if (!((x = m[f].x.getTime ? m[f].x.getTime() : m[f].x) < t.axisX.dataInfo.viewPortMin || x > t.axisX.dataInfo.viewPortMax && (!u.connectNullData || !b))) if ("number" !== typeof m[f].y) 0 < f && !b && (u.connectNullData ? i.setLineDash && 0 < M.length && (u.options.nullDataLineDashType || !m[f - 1].lineDashType) && (M[M.length - 1].newLineDashArray = S, C = u.nullDataLineDashType) : (e(), M = [])), b = !0; else { x = t.axisX.convertValueToPixel(x), b = t.axisY.convertValueToPixel(m[f].y); var E = u.dataPointIds[f]; if (this._eventManager.objectMap[E] = { id: E, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: f, x1: x, y1: b }, M[M.length] = { x: x, y: b }, f < m.length - 1 && (P !== (m[f].lineColor || w) || C !== (m[f].lineDashType || u.lineDashType)) && (P = m[f].lineColor || w, M[M.length - 1].newStrokeStyle = P, i.setLineDash && (m[f].lineDashType ? (C = m[f].lineDashType, M[M.length - 1].newLineDashArray = g(C, u.lineThickness)) : (C = u.lineDashType, M[M.length - 1].newLineDashArray = A))), 0 !== m[f].markerSize && (0 < m[f].markerSize || 0 < u.markerSize)) { var _ = u.getMarkerProperties(f, x, b, i); l.push(_), E = c(E), Y && l.push({ x: x, y: b, ctx: n, type: _.type, size: _.size, color: E, borderColor: E, borderThickness: _.borderThickness }) } (m[f].indexLabel || u.indexLabel || m[f].indexLabelFormatter || u.indexLabelFormatter) && this._indexLabels.push({ chartType: "splineArea", dataPoint: m[f], dataSeries: u, point: { x: x, y: b }, direction: 0 > m[f].y === t.axisY.reversed ? 1 : -1, color: T }), b = !1 } e(), et.drawMarkers(l) } } return Y && (a.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore()), i.restore(), { source: a, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderStepArea = function (t) { var e, a; function i() { w && (0 < x.lineThickness && s.stroke(), t.axisY.logarithmic || 0 >= t.axisY.viewportMinimum && 0 <= t.axisY.viewportMaximum ? k = T : 0 > t.axisY.viewportMaximum ? k = h.y1 : 0 < t.axisY.viewportMinimum && (k = l.y2), s.lineTo(y, k), s.lineTo(w.x, k), s.closePath(), s.globalAlpha = x.fillOpacity, s.fill(), s.globalAlpha = 1, Y && (r.lineTo(y, k), r.lineTo(w.x, k), r.closePath(), r.fill()), s.beginPath(), s.moveTo(y, f), r.beginPath(), r.moveTo(y, f), w = { x: y, y: f }) } var n = t.targetCanvasCtx || this.plotArea.ctx, s = Y ? this._preRenderCtx : n; if (!(0 >= t.dataSeriesIndexes.length)) { var o, r = this._eventManager.ghostCtx, l = t.axisX.lineCoordinates, h = t.axisY.lineCoordinates, d = [], p = this.plotArea; s.save(), Y && r.save(), s.beginPath(), s.rect(p.x1, p.y1, p.width, p.height), s.clip(), Y && (r.beginPath(), r.rect(p.x1, p.y1, p.width, p.height), r.clip()); for (var u = 0; u < t.dataSeriesIndexes.length; u++) { var m = t.dataSeriesIndexes[u], x = this.data[m], b = x.dataPoints; d = x.id; this._eventManager.objectMap[d] = { objectType: "dataSeries", dataSeriesIndex: m }, d = c(d), r.fillStyle = d, d = [], e = !0; var y, f, v, k, M = 0, T = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), w = null; if (a = !1, 0 < b.length) { var P = x._colorSet[M % x._colorSet.length], C = x.lineColor = x.options.lineColor || P, S = C; s.fillStyle = P, s.strokeStyle = C, s.lineWidth = x.lineThickness; var A = "solid"; if (s.setLineDash) { var E = g(x.nullDataLineDashType, x.lineThickness), _ = g(A = x.lineDashType, x.lineThickness); s.setLineDash(_) } for (; M < b.length; M++)if (!((v = b[M].x.getTime ? b[M].x.getTime() : b[M].x) < t.axisX.dataInfo.viewPortMin || v > t.axisX.dataInfo.viewPortMax && (!x.connectNullData || !a))) { var F = f; "number" !== typeof b[M].y ? (x.connectNullData || a || e || i(), a = !0) : (y = t.axisX.convertValueToPixel(v), f = t.axisY.convertValueToPixel(b[M].y), e || a ? (!e && x.connectNullData ? (s.setLineDash && (x.options.nullDataLineDashType || A === x.lineDashType && x.lineDashType !== x.nullDataLineDashType) && (e = y, a = f, y = o.x, f = o.y, i(), s.moveTo(o.x, o.y), y = e, f = a, w = o, A = x.nullDataLineDashType, s.setLineDash(E)), s.lineTo(y, F), s.lineTo(y, f), Y && (r.lineTo(y, F), r.lineTo(y, f))) : (s.beginPath(), s.moveTo(y, f), Y && (r.beginPath(), r.moveTo(y, f)), w = { x: y, y: f }), a = e = !1) : (s.lineTo(y, F), Y && r.lineTo(y, F), s.lineTo(y, f), Y && r.lineTo(y, f), 0 == M % 250 && i()), o = { x: y, y: f }, M < b.length - 1 && (S !== (b[M].lineColor || C) || A !== (b[M].lineDashType || x.lineDashType)) && (i(), S = b[M].lineColor || C, s.strokeStyle = S, s.setLineDash && (b[M].lineDashType ? (A = b[M].lineDashType, s.setLineDash(g(A, x.lineThickness))) : (A = x.lineDashType, s.setLineDash(_)))), v = x.dataPointIds[M], this._eventManager.objectMap[v] = { id: v, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: M, x1: y, y1: f }, 0 !== b[M].markerSize && (0 < b[M].markerSize || 0 < x.markerSize) && (F = x.getMarkerProperties(M, y, f, s), d.push(F), v = c(v), Y && d.push({ x: y, y: f, ctx: r, type: F.type, size: F.size, color: v, borderColor: v, borderThickness: F.borderThickness })), (b[M].indexLabel || x.indexLabel || b[M].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: b[M], dataSeries: x, point: { x: y, y: f }, direction: 0 > b[M].y === t.axisY.reversed ? 1 : -1, color: P })) } i(), et.drawMarkers(d) } } return Y && (n.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), s.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && s.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && s.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), s.clearRect(p.x1, p.y1, p.width, p.height), this._eventManager.ghostCtx.restore()), s.restore(), { source: n, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderStackedArea = function (t) { function e() { if (!(1 > b.length)) { for (0 < P.lineThickness && i.stroke(); 0 < b.length;) { var t = b.pop(); i.lineTo(t.x, t.y), Y && M.lineTo(t.x, t.y) } i.closePath(), i.globalAlpha = P.fillOpacity, i.fill(), i.globalAlpha = 1, i.beginPath(), Y && (M.closePath(), M.fill(), M.beginPath()), b = [] } } var a = t.targetCanvasCtx || this.plotArea.ctx, i = Y ? this._preRenderCtx : a; if (!(0 >= t.dataSeriesIndexes.length)) { var n, s, o, r, h, d = null, p = null, u = [], m = this.plotArea, x = [], b = [], y = [], f = [], v = 0, k = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), M = this._eventManager.ghostCtx; Y && M.beginPath(), i.save(), Y && M.save(), i.beginPath(), i.rect(m.x1, m.y1, m.width, m.height), i.clip(), Y && (M.beginPath(), M.rect(m.x1, m.y1, m.width, m.height), M.clip()); d = []; for (var T = 0; T < t.dataSeriesIndexes.length; T++) { var w = t.dataSeriesIndexes[T], P = this.data[w], C = P.dataPoints; for (P.dataPointIndexes = [], v = 0; v < C.length; v++)w = C[v].x.getTime ? C[v].x.getTime() : C[v].x, P.dataPointIndexes[w] = v, d[w] || (y.push(w), d[w] = !0); y.sort(l) } for (T = 0; T < t.dataSeriesIndexes.length; T++) { if (w = t.dataSeriesIndexes[T], C = (P = this.data[w]).dataPoints, r = !0, b = [], v = P.id, this._eventManager.objectMap[v] = { objectType: "dataSeries", dataSeriesIndex: w }, v = c(v), M.fillStyle = v, 0 < y.length) { d = P._colorSet[0]; var S = P.lineColor = P.options.lineColor || d, A = S; if (i.fillStyle = d, i.strokeStyle = S, i.lineWidth = P.lineThickness, h = "solid", i.setLineDash) { var E = g(P.nullDataLineDashType, P.lineThickness), _ = g(h = P.lineDashType, P.lineThickness); i.setLineDash(_) } var F = !0; for (v = 0; v < y.length; v++) { p = y[v]; var B = 0 <= P.dataPointIndexes[p] ? C[P.dataPointIndexes[p]] : { x: p, y: null }; if (!(p < t.axisX.dataInfo.viewPortMin || p > t.axisX.dataInfo.viewPortMax && (!P.connectNullData || !F))) if ("number" !== typeof B.y) P.connectNullData || F || r || e(), F = !0; else { n = t.axisX.convertValueToPixel(p); var L = x[p] ? x[p] : 0; if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length) { if (f[p] = B.y + (f[p] ? f[p] : 0), 0 >= f[p] && t.axisY.logarithmic) continue; s = t.axisY.convertValueToPixel(f[p]) } else s = t.axisY.convertValueToPixel(B.y), s -= L; if (b.push({ x: n, y: k - L }), x[p] = k - s, r || F ? (!r && P.connectNullData ? (i.setLineDash && (P.options.nullDataLineDashType || h === P.lineDashType && P.lineDashType !== P.nullDataLineDashType) && (r = b.pop(), h = b[b.length - 1], e(), i.moveTo(o.x, o.y), b.push(h), b.push(r), h = P.nullDataLineDashType, i.setLineDash(E)), i.lineTo(n, s), Y && M.lineTo(n, s)) : (i.beginPath(), i.moveTo(n, s), Y && (M.beginPath(), M.moveTo(n, s))), F = r = !1) : (i.lineTo(n, s), Y && M.lineTo(n, s), 0 == v % 250 && (e(), i.moveTo(n, s), Y && M.moveTo(n, s), b.push({ x: n, y: k - L }))), o = { x: n, y: s }, v < C.length - 1 && (A !== (C[v].lineColor || S) || h !== (C[v].lineDashType || P.lineDashType)) && (e(), i.beginPath(), i.moveTo(n, s), b.push({ x: n, y: k - L }), A = C[v].lineColor || S, i.strokeStyle = A, i.setLineDash && (C[v].lineDashType ? (h = C[v].lineDashType, i.setLineDash(g(h, P.lineThickness))) : (h = P.lineDashType, i.setLineDash(_)))), 0 <= P.dataPointIndexes[p]) { var I = P.dataPointIds[P.dataPointIndexes[p]]; this._eventManager.objectMap[I] = { id: I, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: P.dataPointIndexes[p], x1: n, y1: s } } 0 <= P.dataPointIndexes[p] && 0 !== B.markerSize && (0 < B.markerSize || 0 < P.markerSize) && (L = P.getMarkerProperties(P.dataPointIndexes[p], n, s, i), u.push(L), p = c(I), Y && u.push({ x: n, y: s, ctx: M, type: L.type, size: L.size, color: p, borderColor: p, borderThickness: L.borderThickness })), (B.indexLabel || P.indexLabel || B.indexLabelFormatter || P.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: B, dataSeries: P, point: { x: n, y: s }, direction: 0 > C[v].y === t.axisY.reversed ? 1 : -1, color: d }) } } e(), i.moveTo(n, s), Y && M.moveTo(n, s) } delete P.dataPointIndexes } return et.drawMarkers(u), Y && (a.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(m.x1, m.y1, m.width, m.height), M.restore()), i.restore(), { source: a, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderStackedArea100 = function (t) { function e() { for (0 < P.lineThickness && i.stroke(); 0 < b.length;) { var t = b.pop(); i.lineTo(t.x, t.y), Y && M.lineTo(t.x, t.y) } i.closePath(), i.globalAlpha = P.fillOpacity, i.fill(), i.globalAlpha = 1, i.beginPath(), Y && (M.closePath(), M.fill(), M.beginPath()), b = [] } var a = t.targetCanvasCtx || this.plotArea.ctx, i = Y ? this._preRenderCtx : a; if (!(0 >= t.dataSeriesIndexes.length)) { var n, s, o, r, h, d = null, p = null, u = this.plotArea, m = [], x = [], b = [], y = [], f = [], v = 0, k = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0), M = this._eventManager.ghostCtx; i.save(), Y && M.save(), i.beginPath(), i.rect(u.x1, u.y1, u.width, u.height), i.clip(), Y && (M.beginPath(), M.rect(u.x1, u.y1, u.width, u.height), M.clip()); d = []; for (var T = 0; T < t.dataSeriesIndexes.length; T++) { var w = t.dataSeriesIndexes[T], P = this.data[w], C = P.dataPoints; for (P.dataPointIndexes = [], v = 0; v < C.length; v++)w = C[v].x.getTime ? C[v].x.getTime() : C[v].x, P.dataPointIndexes[w] = v, d[w] || (y.push(w), d[w] = !0); y.sort(l) } for (T = 0; T < t.dataSeriesIndexes.length; T++) { if (w = t.dataSeriesIndexes[T], C = (P = this.data[w]).dataPoints, r = !0, d = P.id, this._eventManager.objectMap[d] = { objectType: "dataSeries", dataSeriesIndex: w }, d = c(d), M.fillStyle = d, b = [], 0 < y.length) { d = P._colorSet[v % P._colorSet.length]; var S = P.lineColor = P.options.lineColor || d, A = S; if (i.fillStyle = d, i.strokeStyle = S, i.lineWidth = P.lineThickness, h = "solid", i.setLineDash) { var E = g(P.nullDataLineDashType, P.lineThickness), _ = g(h = P.lineDashType, P.lineThickness); i.setLineDash(_) } var F = !0; for (v = 0; v < y.length; v++) { p = y[v]; var B = 0 <= P.dataPointIndexes[p] ? C[P.dataPointIndexes[p]] : { x: p, y: null }; if (!(p < t.axisX.dataInfo.viewPortMin || p > t.axisX.dataInfo.viewPortMax && (!P.connectNullData || !F))) if ("number" !== typeof B.y) P.connectNullData || F || r || e(), F = !0; else { var L; L = 0 !== t.dataPointYSums[p] ? B.y / t.dataPointYSums[p] * 100 : 0, n = t.axisX.convertValueToPixel(p); var I = x[p] ? x[p] : 0; if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length) { if (f[p] = L + (f[p] ? f[p] : 0), 0 >= f[p] && t.axisY.logarithmic) continue; s = t.axisY.convertValueToPixel(f[p]) } else s = t.axisY.convertValueToPixel(L), s -= I; if (b.push({ x: n, y: k - I }), x[p] = k - s, r || F ? (!r && P.connectNullData ? (i.setLineDash && (P.options.nullDataLineDashType || h === P.lineDashType && P.lineDashType !== P.nullDataLineDashType) && (r = b.pop(), h = b[b.length - 1], e(), i.moveTo(o.x, o.y), b.push(h), b.push(r), h = P.nullDataLineDashType, i.setLineDash(E)), i.lineTo(n, s), Y && M.lineTo(n, s)) : (i.beginPath(), i.moveTo(n, s), Y && (M.beginPath(), M.moveTo(n, s))), F = r = !1) : (i.lineTo(n, s), Y && M.lineTo(n, s), 0 == v % 250 && (e(), i.moveTo(n, s), Y && M.moveTo(n, s), b.push({ x: n, y: k - I }))), o = { x: n, y: s }, v < C.length - 1 && (A !== (C[v].lineColor || S) || h !== (C[v].lineDashType || P.lineDashType)) && (e(), i.beginPath(), i.moveTo(n, s), b.push({ x: n, y: k - I }), A = C[v].lineColor || S, i.strokeStyle = A, i.setLineDash && (C[v].lineDashType ? (h = C[v].lineDashType, i.setLineDash(g(h, P.lineThickness))) : (h = P.lineDashType, i.setLineDash(_)))), 0 <= P.dataPointIndexes[p]) { var D = P.dataPointIds[P.dataPointIndexes[p]]; this._eventManager.objectMap[D] = { id: D, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: P.dataPointIndexes[p], x1: n, y1: s } } 0 <= P.dataPointIndexes[p] && 0 !== B.markerSize && (0 < B.markerSize || 0 < P.markerSize) && (I = P.getMarkerProperties(v, n, s, i), m.push(I), p = c(D), Y && m.push({ x: n, y: s, ctx: M, type: I.type, size: I.size, color: p, borderColor: p, borderThickness: I.borderThickness })), (B.indexLabel || P.indexLabel || B.indexLabelFormatter || P.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea100", dataPoint: B, dataSeries: P, point: { x: n, y: s }, direction: 0 > C[v].y === t.axisY.reversed ? 1 : -1, color: d }) } } e(), i.moveTo(n, s), Y && M.moveTo(n, s) } delete P.dataPointIndexes } return et.drawMarkers(m), Y && (a.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(u.x1, u.y1, u.width, u.height), M.restore()), i.restore(), { source: a, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderBubble = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s = this.plotArea, o = 0; a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(s.x1, s.y1, s.width, s.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.clip()); for (var r = -1 / 0, l = 1 / 0, h = 0; h < t.dataSeriesIndexes.length; h++) { var d = t.dataSeriesIndexes[h], p = this.data[d], u = p.dataPoints, m = 0; for (o = 0; o < u.length; o++)(i = i = u[o].getTime ? u[o].x.getTime() : u[o].x) < t.axisX.dataInfo.viewPortMin || i > t.axisX.dataInfo.viewPortMax || "undefined" === typeof u[o].z || ((m = u[o].z) > r && (r = m), m < l && (l = m)) } var x = 25 * Math.PI, g = Math.max(Math.pow(.25 * Math.min(s.height, s.width) / 2, 2) * Math.PI, x); for (h = 0; h < t.dataSeriesIndexes.length; h++)if (d = t.dataSeriesIndexes[h], 0 < (u = (p = this.data[d]).dataPoints).length) for (a.strokeStyle = "#4572A7 ", o = 0; o < u.length; o++)if (!((i = i = u[o].getTime ? u[o].x.getTime() : u[o].x) < t.axisX.dataInfo.viewPortMin || i > t.axisX.dataInfo.viewPortMax) && "number" === typeof u[o].y) { i = t.axisX.convertValueToPixel(i), n = t.axisY.convertValueToPixel(u[o].y); m = u[o].z; var b = 2 * Math.max(Math.sqrt((r === l ? g / 2 : x + (g - x) / (r - l) * (m - l)) / Math.PI) << 0, 1); (m = p.getMarkerProperties(o, a)).size = b, a.globalAlpha = p.fillOpacity, et.drawMarker(i, n, a, m.type, m.size, m.color, m.borderColor, m.borderThickness), a.globalAlpha = 1; var y = p.dataPointIds[o]; this._eventManager.objectMap[y] = { id: y, objectType: "dataPoint", dataSeriesIndex: d, dataPointIndex: o, x1: i, y1: n, size: b }, b = c(y), Y && et.drawMarker(i, n, this._eventManager.ghostCtx, m.type, m.size, b, b, m.borderThickness), (u[o].indexLabel || p.indexLabel || u[o].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: "bubble", dataPoint: u[o], dataSeries: p, point: { x: i, y: n }, direction: 1, bounds: { x1: i - m.size / 2, y1: n - m.size / 2, x2: i + m.size / 2, y2: n + m.size / 2 }, color: null }) } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderScatter = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s = this.plotArea, o = 0; a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(s.x1, s.y1, s.width, s.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.clip()); for (var r = 0; r < t.dataSeriesIndexes.length; r++) { var l = t.dataSeriesIndexes[r], h = this.data[l], d = h.dataPoints; if (0 < d.length) { a.strokeStyle = "#4572A7 ", Math.pow(.3 * Math.min(s.height, s.width) / 2, 2); var p = 0, u = 0; for (o = 0; o < d.length; o++)if (!((i = i = d[o].getTime ? d[o].x.getTime() : d[o].x) < t.axisX.dataInfo.viewPortMin || i > t.axisX.dataInfo.viewPortMax) && "number" === typeof d[o].y) { i = t.axisX.convertValueToPixel(i), n = t.axisY.convertValueToPixel(d[o].y); var m = h.getMarkerProperties(o, i, n, a); a.globalAlpha = h.fillOpacity, et.drawMarker(m.x, m.y, m.ctx, m.type, m.size, m.color, m.borderColor, m.borderThickness), a.globalAlpha = 1, Math.sqrt((p - i) * (p - i) + (u - n) * (u - n)) < Math.min(m.size, 5) && d.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = h.dataPointIds[o], this._eventManager.objectMap[p] = { id: p, objectType: "dataPoint", dataSeriesIndex: l, dataPointIndex: o, x1: i, y1: n }, p = c(p), Y && et.drawMarker(m.x, m.y, this._eventManager.ghostCtx, m.type, m.size, p, p, m.borderThickness), (d[o].indexLabel || h.indexLabel || d[o].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "scatter", dataPoint: d[o], dataSeries: h, point: { x: i, y: n }, direction: 1, bounds: { x1: i - m.size / 2, y1: n - m.size / 2, x2: i + m.size / 2, y2: n + m.size / 2 }, color: null }), p = i, u = n) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderCandlestick = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e, i = this._eventManager.ghostCtx; if (!(0 >= t.dataSeriesIndexes.length)) { var n, s, o, r, l, h, d = null, u = null, m = this.plotArea, x = 0, g = (d = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, u = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .015 * this.width, t.axisX.dataInfo.minDiff); isFinite(g) || (g = .3 * Math.abs(t.axisX.range)), g = this.options.dataPointWidth ? this.dataPointWidth : .7 * m.width * (t.axisX.logarithmic ? Math.log(g) / Math.log(t.axisX.range) : Math.abs(g) / Math.abs(t.axisX.range)) << 0, this.dataPointMaxWidth && d > u && (d = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, u)), !this.dataPointMaxWidth && this.dataPointMinWidth && u < d && (u = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, d)), g < d && (g = d), g > u && (g = u), a.save(), Y && i.save(), a.beginPath(), a.rect(m.x1, m.y1, m.width, m.height), a.clip(), Y && (i.beginPath(), i.rect(m.x1, m.y1, m.width, m.height), i.clip()); for (var b = 0; b < t.dataSeriesIndexes.length; b++) { var y = t.dataSeriesIndexes[b], f = this.data[y], v = f.dataPoints; if (0 < v.length) { var k = !!(5 < g && f.bevelEnabled); for (x = 0; x < v.length; x++)if (!((h = v[x].getTime ? v[x].x.getTime() : v[x].x) < t.axisX.dataInfo.viewPortMin || h > t.axisX.dataInfo.viewPortMax) && !p(v[x].y) && v[x].y.length && "number" === typeof v[x].y[0] && "number" === typeof v[x].y[1] && "number" === typeof v[x].y[2] && "number" === typeof v[x].y[3]) { n = t.axisX.convertValueToPixel(h), s = t.axisY.convertValueToPixel(v[x].y[0]), o = t.axisY.convertValueToPixel(v[x].y[1]), r = t.axisY.convertValueToPixel(v[x].y[2]), l = t.axisY.convertValueToPixel(v[x].y[3]); var M = n - g / 2 << 0, T = M + g << 0, w = (u = f.options.fallingColor ? f.fallingColor : f._colorSet[0], d = v[x].color ? v[x].color : f._colorSet[0], Math.round(Math.max(1, .15 * g))), P = 0 === w % 2 ? 0 : .5, C = f.dataPointIds[x]; this._eventManager.objectMap[C] = { id: C, objectType: "dataPoint", dataSeriesIndex: y, dataPointIndex: x, x1: M, y1: s, x2: T, y2: o, x3: n, y3: r, x4: n, y4: l, borderThickness: w, color: d }, a.strokeStyle = d, a.beginPath(), a.lineWidth = w, i.lineWidth = Math.max(w, 4), "candlestick" === f.type ? (a.moveTo(n - P, o), a.lineTo(n - P, Math.min(s, l)), a.stroke(), a.moveTo(n - P, Math.max(s, l)), a.lineTo(n - P, r), a.stroke(), dt(a, M, Math.min(s, l), T, Math.max(s, l), v[x].y[0] <= v[x].y[3] ? f.risingColor : u, w, d, k, k, !1, !1, f.fillOpacity), Y && (d = c(C), i.strokeStyle = d, i.moveTo(n - P, o), i.lineTo(n - P, Math.min(s, l)), i.stroke(), i.moveTo(n - P, Math.max(s, l)), i.lineTo(n - P, r), i.stroke(), dt(i, M, Math.min(s, l), T, Math.max(s, l), d, 0, null, !1, !1, !1, !1))) : "ohlc" === f.type && (a.moveTo(n - P, o), a.lineTo(n - P, r), a.stroke(), a.beginPath(), a.moveTo(n, s), a.lineTo(M, s), a.stroke(), a.beginPath(), a.moveTo(n, l), a.lineTo(T, l), a.stroke(), Y && (d = c(C), i.strokeStyle = d, i.moveTo(n - P, o), i.lineTo(n - P, r), i.stroke(), i.beginPath(), i.moveTo(n, s), i.lineTo(M, s), i.stroke(), i.beginPath(), i.moveTo(n, l), i.lineTo(T, l), i.stroke())), (v[x].indexLabel || f.indexLabel || v[x].indexLabelFormatter || f.indexLabelFormatter) && this._indexLabels.push({ chartType: f.type, dataPoint: v[x], dataSeries: f, point: { x: M + (T - M) / 2, y: t.axisY.reversed ? r : o }, direction: 1, bounds: { x1: M, y1: Math.min(o, r), x2: T, y2: Math.max(o, r) }, color: d }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(m.x1, m.y1, m.width, m.height), i.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderBoxAndWhisker = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e, i = this._eventManager.ghostCtx; if (!(0 >= t.dataSeriesIndexes.length)) { var n, s, o, r, l, h, d, u = null, m = this.plotArea, x = 0, b = (u = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, x = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .015 * this.width, t.axisX.dataInfo.minDiff); isFinite(b) || (b = .3 * Math.abs(t.axisX.range)), b = this.options.dataPointWidth ? this.dataPointWidth : .7 * m.width * (t.axisX.logarithmic ? Math.log(b) / Math.log(t.axisX.range) : Math.abs(b) / Math.abs(t.axisX.range)) << 0, this.dataPointMaxWidth && u > x && (u = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, x)), !this.dataPointMaxWidth && this.dataPointMinWidth && x < u && (x = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, u)), b < u && (b = u), b > x && (b = x), a.save(), Y && i.save(), a.beginPath(), a.rect(m.x1, m.y1, m.width, m.height), a.clip(), Y && (i.beginPath(), i.rect(m.x1, m.y1, m.width, m.height), i.clip()); for (var y = !!t.axisY.reversed, f = 0; f < t.dataSeriesIndexes.length; f++) { var v = t.dataSeriesIndexes[f], k = this.data[v], M = k.dataPoints; if (0 < M.length) { var T = !!(5 < b && k.bevelEnabled); for (x = 0; x < M.length; x++)if (!((d = M[x].getTime ? M[x].x.getTime() : M[x].x) < t.axisX.dataInfo.viewPortMin || d > t.axisX.dataInfo.viewPortMax) && !p(M[x].y) && M[x].y.length && "number" === typeof M[x].y[0] && "number" === typeof M[x].y[1] && "number" === typeof M[x].y[2] && "number" === typeof M[x].y[3] && "number" === typeof M[x].y[4] && 5 === M[x].y.length) { n = t.axisX.convertValueToPixel(d), s = t.axisY.convertValueToPixel(M[x].y[0]), o = t.axisY.convertValueToPixel(M[x].y[1]), r = t.axisY.convertValueToPixel(M[x].y[2]), l = t.axisY.convertValueToPixel(M[x].y[3]), h = t.axisY.convertValueToPixel(M[x].y[4]); var w = n - b / 2 << 0, P = n + b / 2 << 0, C = (u = M[x].color ? M[x].color : k._colorSet[0], Math.round(Math.max(1, .15 * b))), S = 0 === C % 2 ? 0 : .5, A = M[x].whiskerColor ? M[x].whiskerColor : M[x].color ? k.whiskerColor ? k.whiskerColor : M[x].color : k.whiskerColor ? k.whiskerColor : u, E = "number" === typeof M[x].whiskerThickness ? M[x].whiskerThickness : "number" === typeof k.options.whiskerThickness ? k.whiskerThickness : C, _ = M[x].whiskerDashType ? M[x].whiskerDashType : k.whiskerDashType, F = "number" === typeof (F = p(M[x].whiskerLength) ? p(k.options.whiskerLength) ? b : k.whiskerLength : M[x].whiskerLength) ? 0 >= F ? 0 : F >= b ? b : F : "string" === typeof F ? parseInt(F) * b / 100 > b ? b : parseInt(F) * b / 100 : b, B = 1 === Math.round(E) % 2 ? .5 : 0, L = M[x].stemColor ? M[x].stemColor : M[x].color ? k.stemColor ? k.stemColor : M[x].color : k.stemColor ? k.stemColor : u, I = "number" === typeof M[x].stemThickness ? M[x].stemThickness : "number" === typeof k.options.stemThickness ? k.stemThickness : C, D = 1 === Math.round(I) % 2 ? .5 : 0, N = M[x].stemDashType ? M[x].stemDashType : k.stemDashType, V = M[x].lineColor ? M[x].lineColor : M[x].color ? k.lineColor ? k.lineColor : M[x].color : k.lineColor ? k.lineColor : u, W = "number" === typeof M[x].lineThickness ? M[x].lineThickness : "number" === typeof k.options.lineThickness ? k.lineThickness : C, z = M[x].lineDashType ? M[x].lineDashType : k.lineDashType, O = 1 === Math.round(W) % 2 ? .5 : 0, X = k.upperBoxColor, R = k.lowerBoxColor, j = p(k.options.fillOpacity) ? 1 : k.fillOpacity, U = k.dataPointIds[x]; this._eventManager.objectMap[U] = { id: U, objectType: "dataPoint", dataSeriesIndex: v, dataPointIndex: x, x1: w, y1: s, x2: P, y2: o, x3: n, y3: r, x4: n, y4: l, y5: h, borderThickness: C, color: u, stemThickness: I, stemColor: L, whiskerThickness: E, whiskerLength: F, whiskerColor: A, lineThickness: W, lineColor: V }, a.save(), 0 < I && (a.beginPath(), a.strokeStyle = L, a.lineWidth = I, a.setLineDash && a.setLineDash(g(N, I)), a.moveTo(n - D, o), a.lineTo(n - D, s), a.stroke(), a.moveTo(n - D, l), a.lineTo(n - D, r), a.stroke()), a.restore(), i.lineWidth = Math.max(C, 4), a.beginPath(), dt(a, w, Math.min(h, o), P, Math.max(o, h), R, 0, u, !!y && T, !y && T, !1, !1, j), a.beginPath(), dt(a, w, Math.min(r, h), P, Math.max(h, r), X, 0, u, !y && T, !!y && T, !1, !1, j), a.beginPath(), a.lineWidth = C, a.strokeStyle = u, a.rect(w - S, Math.min(o, r) - S, P - w + 2 * S, Math.max(o, r) - Math.min(o, r) + 2 * S), a.stroke(), a.save(), 0 < W && (a.beginPath(), a.globalAlpha = 1, a.setLineDash && a.setLineDash(g(z, W)), a.strokeStyle = V, a.lineWidth = W, a.moveTo(w, h - O), a.lineTo(P, h - O), a.stroke()), a.restore(), a.save(), 0 < E && (a.beginPath(), a.setLineDash && a.setLineDash(g(_, E)), a.strokeStyle = A, a.lineWidth = E, a.moveTo(n - F / 2 << 0, l - B), a.lineTo(n + F / 2 << 0, l - B), a.stroke(), a.moveTo(n - F / 2 << 0, s + B), a.lineTo(n + F / 2 << 0, s + B), a.stroke()), a.restore(), Y && (u = c(U), i.strokeStyle = u, i.lineWidth = I, 0 < I && (i.moveTo(n - S - D, o), i.lineTo(n - S - D, Math.max(s, l)), i.stroke(), i.moveTo(n - S - D, Math.min(s, l)), i.lineTo(n - S - D, r), i.stroke()), dt(i, w, Math.max(o, r), P, Math.min(o, r), u, 0, null, !1, !1, !1, !1), 0 < E && (i.beginPath(), i.lineWidth = E, i.moveTo(n + F / 2, l - B), i.lineTo(n - F / 2, l - B), i.stroke(), i.moveTo(n + F / 2, s + B), i.lineTo(n - F / 2, s + B), i.stroke())), (M[x].indexLabel || k.indexLabel || M[x].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: k.type, dataPoint: M[x], dataSeries: k, point: { x: w + (P - w) / 2, y: t.axisY.reversed ? s : l }, direction: 1, bounds: { x1: w, y1: Math.min(s, l), x2: P, y2: Math.max(s, l) }, color: u }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(m.x1, m.y1, m.width, m.height), i.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderRangeColumn = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s, o = null, r = this.plotArea, l = 0; l = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; i = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .03 * this.width; var h = t.axisX.dataInfo.minDiff; isFinite(h) || (h = .3 * Math.abs(t.axisX.range)), h = this.options.dataPointWidth ? this.dataPointWidth : r.width * (t.axisX.logarithmic ? Math.log(h) / Math.log(t.axisX.range) : Math.abs(h) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && l > i && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, i)), !this.dataPointMaxWidth && this.dataPointMinWidth && i < l && (i = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, l)), h < l && (h = l), h > i && (h = i), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(r.x1, r.y1, r.width, r.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.clip()); for (var d = 0; d < t.dataSeriesIndexes.length; d++) { var u = t.dataSeriesIndexes[d], m = this.data[u], x = m.dataPoints; if (0 < x.length) { var g = !!(5 < h && m.bevelEnabled); for (l = 0; l < x.length; l++)if (!((s = x[l].getTime ? x[l].x.getTime() : x[l].x) < t.axisX.dataInfo.viewPortMin || s > t.axisX.dataInfo.viewPortMax) && !p(x[l].y) && x[l].y.length && "number" === typeof x[l].y[0] && "number" === typeof x[l].y[1]) { o = t.axisX.convertValueToPixel(s), i = t.axisY.convertValueToPixel(x[l].y[0]), n = t.axisY.convertValueToPixel(x[l].y[1]); var b = t.axisX.reversed ? o + t.plotType.totalDataSeries * h / 2 - (t.previousDataSeriesCount + d) * h << 0 : o - t.plotType.totalDataSeries * h / 2 + (t.previousDataSeriesCount + d) * h << 0, y = t.axisX.reversed ? b - h << 0 : b + h << 0; o = x[l].color ? x[l].color : m._colorSet[l % m._colorSet.length]; if (i > n) { var f = i; i = n, n = f } f = m.dataPointIds[l], this._eventManager.objectMap[f] = { id: f, objectType: "dataPoint", dataSeriesIndex: u, dataPointIndex: l, x1: b, y1: i, x2: y, y2: n }, dt(a, b, i, y, n, o, 0, o, g, g, !1, !1, m.fillOpacity), o = c(f), Y && dt(this._eventManager.ghostCtx, b, i, y, n, o, 0, null, !1, !1, !1, !1), (x[l].indexLabel || m.indexLabel || x[l].indexLabelFormatter || m.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeColumn", dataPoint: x[l], dataSeries: m, indexKeyword: 0, point: { x: b + (y - b) / 2, y: x[l].y[1] >= x[l].y[0] ? n : i }, direction: x[l].y[1] >= x[l].y[0] ? -1 : 1, bounds: { x1: b, y1: Math.min(i, n), x2: y, y2: Math.max(i, n) }, color: o }), this._indexLabels.push({ chartType: "rangeColumn", dataPoint: x[l], dataSeries: m, indexKeyword: 1, point: { x: b + (y - b) / 2, y: x[l].y[1] >= x[l].y[0] ? i : n }, direction: x[l].y[1] >= x[l].y[0] ? 1 : -1, bounds: { x1: b, y1: Math.min(i, n), x2: y, y2: Math.max(i, n) }, color: o })) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderError = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e, i = !!t.axisY._position && ("left" !== t.axisY._position && "right" !== t.axisY._position); if (!(0 >= t.dataSeriesIndexes.length)) { var n, s, o, r, l, h, c, u = null, m = !1, x = this.plotArea, g = 0, b = t.axisX.dataInfo.minDiff; isFinite(b) || (b = .3 * Math.abs(t.axisX.range)), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(x.x1, x.y1, x.width, x.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(x.x1, x.y1, x.width, x.height), this._eventManager.ghostCtx.clip()); for (var y = 0, f = 0; f < this.data.length; f++)!this.data[f].type.match(/(bar|column)/gi) || !this.data[f].visible || this.data[f].type.match(/(stacked)/gi) && y || y++; for (var v = 0; v < t.dataSeriesIndexes.length; v++) { var k = t.dataSeriesIndexes[v], M = this.data[k], T = M.dataPoints, w = !p(M._linkedSeries) && !(!M._linkedSeries.type.match(/(bar|column)/gi) || !M._linkedSeries.visible), P = 0; if (w) for (u = M._linkedSeries.id, f = 0; f < u; f++)!this.data[f].type.match(/(bar|column)/gi) || !this.data[f].visible || this.data[f].type.match(/(stacked)/gi) && P || (this.data[f].type.match(/(range)/gi) && (m = !0), P++); if (u = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : i ? Math.min(.15 * this.height, this.plotArea.height / (w ? y : 1) * .9) << 0 : .3 * this.width, m && (g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : i ? Math.min(.15 * this.height, this.plotArea.height / (w ? y : 1) * .9) << 0 : .03 * this.width), f = this.options.dataPointWidth ? this.dataPointWidth : (i ? x.height : x.width) * (t.axisX.logarithmic ? Math.log(b) / Math.log(t.axisX.range) : Math.abs(b) / Math.abs(t.axisX.range)) / (w ? y : 1) * .9 << 0, this.dataPointMaxWidth && u > g && (u = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, g)), !this.dataPointMaxWidth && this.dataPointMinWidth && g < u && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, u)), f < u && (f = u), f > g && (f = g), 0 < T.length) { var C = M._colorSet; for (g = 0; g < T.length; g++) { u = M.lineColor = M.options.color ? M.options.color : C[0]; var S = { color: T[g].whiskerColor ? T[g].whiskerColor : T[g].color ? M.whiskerColor ? M.whiskerColor : T[g].color : M.whiskerColor ? M.whiskerColor : u, thickness: p(T[g].whiskerThickness) ? M.whiskerThickness : T[g].whiskerThickness, dashType: T[g].whiskerDashType ? T[g].whiskerDashType : M.whiskerDashType, length: p(T[g].whiskerLength) ? p(M.options.whiskerLength) ? f : M.options.whiskerLength : T[g].whiskerLength, trimLength: p(T[g].whiskerLength) && p(M.options.whiskerLength) ? 50 : 0 }; S.length = "number" === typeof S.length ? 0 >= S.length ? 0 : S.length >= f ? f : S.length : "string" === typeof S.length ? parseInt(S.length) * f / 100 > f ? f : parseInt(S.length) * f / 100 > f : f, S.thickness = "number" === typeof S.thickness ? 0 > S.thickness ? 0 : Math.round(S.thickness) : 2; var A = { color: T[g].stemColor ? T[g].stemColor : T[g].color ? M.stemColor ? M.stemColor : T[g].color : M.stemColor ? M.stemColor : u, thickness: T[g].stemThickness ? T[g].stemThickness : M.stemThickness, dashType: T[g].stemDashType ? T[g].stemDashType : M.stemDashType }; if (A.thickness = "number" === typeof A.thickness ? 0 > A.thickness ? 0 : Math.round(A.thickness) : 2, !((c = T[g].getTime ? T[g].x.getTime() : T[g].x) < t.axisX.dataInfo.viewPortMin || c > t.axisX.dataInfo.viewPortMax) && !p(T[g].y) && T[g].y.length && "number" === typeof T[g].y[0] && "number" === typeof T[g].y[1]) { var E = t.axisX.convertValueToPixel(c); i ? s = E : n = E, E = t.axisY.convertValueToPixel(T[g].y[0]), i ? o = E : l = E, E = t.axisY.convertValueToPixel(T[g].y[1]), i ? r = E : h = E, i ? (l = t.axisX.reversed ? s + (w ? y : 1) * f / 2 - (w ? P - 1 : 0) * f << 0 : s - (w ? y : 1) * f / 2 + (w ? P - 1 : 0) * f << 0, h = t.axisX.reversed ? l - f << 0 : l + f << 0) : (o = t.axisX.reversed ? n + (w ? y : 1) * f / 2 - (w ? P - 1 : 0) * f << 0 : n - (w ? y : 1) * f / 2 + (w ? P - 1 : 0) * f << 0, r = t.axisX.reversed ? o - f << 0 : o + f << 0), !i && l > h && (E = l, l = h, h = E), i && o > r && (E = o, o = r, r = E), E = M.dataPointIds[g], this._eventManager.objectMap[E] = { id: E, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: g, x1: Math.min(o, r), y1: Math.min(l, h), x2: Math.max(r, o), y2: Math.max(h, l), isXYSwapped: i, stemProperties: A, whiskerProperties: S }, d(a, Math.min(o, r), Math.min(l, h), Math.max(r, o), Math.max(h, l), u, S, A, i), Y && d(this._eventManager.ghostCtx, o, l, r, h, u, S, A, i), (T[g].indexLabel || M.indexLabel || T[g].indexLabelFormatter || M.indexLabelFormatter) && (this._indexLabels.push({ chartType: "error", dataPoint: T[g], dataSeries: M, indexKeyword: 0, point: { x: i ? T[g].y[1] >= T[g].y[0] ? o : r : o + (r - o) / 2, y: i ? l + (h - l) / 2 : T[g].y[1] >= T[g].y[0] ? h : l }, direction: T[g].y[1] >= T[g].y[0] ? -1 : 1, bounds: { x1: i ? Math.min(o, r) : o, y1: i ? l : Math.min(l, h), x2: i ? Math.max(o, r) : r, y2: i ? h : Math.max(l, h) }, color: u, axisSwapped: i }), this._indexLabels.push({ chartType: "error", dataPoint: T[g], dataSeries: M, indexKeyword: 1, point: { x: i ? T[g].y[1] >= T[g].y[0] ? r : o : o + (r - o) / 2, y: i ? l + (h - l) / 2 : T[g].y[1] >= T[g].y[0] ? l : h }, direction: T[g].y[1] >= T[g].y[0] ? 1 : -1, bounds: { x1: i ? Math.min(o, r) : o, y1: i ? l : Math.min(l, h), x2: i ? Math.max(o, r) : r, y2: i ? h : Math.max(l, h) }, color: u, axisSwapped: i })) } } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(x.x1, x.y1, x.width, x.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderRangeBar = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s, o, r = null, l = this.plotArea, h = 0; h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; i = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, this.plotArea.height / t.plotType.totalDataSeries * .9) << 0; var d = t.axisX.dataInfo.minDiff; isFinite(d) || (d = .3 * Math.abs(t.axisX.range)), d = this.options.dataPointWidth ? this.dataPointWidth : l.height * (t.axisX.logarithmic ? Math.log(d) / Math.log(t.axisX.range) : Math.abs(d) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && h > i && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, i)), !this.dataPointMaxWidth && this.dataPointMinWidth && i < h && (i = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, h)), d < h && (d = h), d > i && (d = i), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(l.x1, l.y1, l.width, l.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.clip()); for (var u = 0; u < t.dataSeriesIndexes.length; u++) { var m = t.dataSeriesIndexes[u], x = this.data[m], g = x.dataPoints; if (0 < g.length) { var b = !!(5 < d && x.bevelEnabled); for (a.strokeStyle = "#4572A7 ", h = 0; h < g.length; h++)if (!((o = g[h].getTime ? g[h].x.getTime() : g[h].x) < t.axisX.dataInfo.viewPortMin || o > t.axisX.dataInfo.viewPortMax) && !p(g[h].y) && g[h].y.length && "number" === typeof g[h].y[0] && "number" === typeof g[h].y[1]) { i = t.axisY.convertValueToPixel(g[h].y[0]), n = t.axisY.convertValueToPixel(g[h].y[1]), s = t.axisX.convertValueToPixel(o), s = t.axisX.reversed ? s + t.plotType.totalDataSeries * d / 2 - (t.previousDataSeriesCount + u) * d << 0 : s - t.plotType.totalDataSeries * d / 2 + (t.previousDataSeriesCount + u) * d << 0; var y = t.axisX.reversed ? s - d << 0 : s + d << 0; i > n && (r = i, i = n, n = r), r = g[h].color ? g[h].color : x._colorSet[h % x._colorSet.length], dt(a, i, s, n, y, r, 0, null, b, !1, !1, !1, x.fillOpacity), r = x.dataPointIds[h], this._eventManager.objectMap[r] = { id: r, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: h, x1: i, y1: s, x2: n, y2: y }, r = c(r), Y && dt(this._eventManager.ghostCtx, i, s, n, y, r, 0, null, !1, !1, !1, !1), (g[h].indexLabel || x.indexLabel || g[h].indexLabelFormatter || x.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeBar", dataPoint: g[h], dataSeries: x, indexKeyword: 0, point: { x: g[h].y[1] >= g[h].y[0] ? i : n, y: s + (y - s) / 2 }, direction: g[h].y[1] >= g[h].y[0] ? -1 : 1, bounds: { x1: Math.min(i, n), y1: s, x2: Math.max(i, n), y2: y }, color: r }), this._indexLabels.push({ chartType: "rangeBar", dataPoint: g[h], dataSeries: x, indexKeyword: 1, point: { x: g[h].y[1] >= g[h].y[0] ? n : i, y: s + (y - s) / 2 }, direction: g[h].y[1] >= g[h].y[0] ? 1 : -1, bounds: { x1: Math.min(i, n), y1: s, x2: Math.max(i, n), y2: y }, color: r })) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }, a.prototype.renderRangeArea = function (t) { function e() { if (v) { var t = null; 0 < d.lineThickness && i.stroke(); for (var e = l.length - 1; 0 <= e; e--)t = l[e], i.lineTo(t.x, t.y), n.lineTo(t.x, t.y); if (i.closePath(), i.globalAlpha = d.fillOpacity, i.fill(), i.globalAlpha = 1, n.fill(), 0 < d.lineThickness) { for (i.beginPath(), i.moveTo(t.x, t.y), e = 0; e < l.length; e++)t = l[e], i.lineTo(t.x, t.y); i.stroke() } i.beginPath(), i.moveTo(u, m), n.beginPath(), n.moveTo(u, m), v = { x: u, y: m }, (l = []).push({ x: u, y: x }) } } var a = t.targetCanvasCtx || this.plotArea.ctx, i = Y ? this._preRenderCtx : a; if (!(0 >= t.dataSeriesIndexes.length)) { var n = this._eventManager.ghostCtx, s = [], o = this.plotArea; i.save(), Y && n.save(), i.beginPath(), i.rect(o.x1, o.y1, o.width, o.height), i.clip(), Y && (n.beginPath(), n.rect(o.x1, o.y1, o.width, o.height), n.clip()); for (var r = 0; r < t.dataSeriesIndexes.length; r++) { var l = [], h = t.dataSeriesIndexes[r], d = this.data[h], p = d.dataPoints; s = d.id; this._eventManager.objectMap[s] = { objectType: "dataSeries", dataSeriesIndex: h }, s = c(s), n.fillStyle = s; s = []; var u, m, x, b, y = !0, f = 0, v = null; if (0 < p.length) { var k = d._colorSet[f % d._colorSet.length], M = d.lineColor = d.options.lineColor || k, T = M; i.fillStyle = k, i.strokeStyle = M, i.lineWidth = d.lineThickness; var w = "solid"; if (i.setLineDash) { var P = g(d.nullDataLineDashType, d.lineThickness), C = g(w = d.lineDashType, d.lineThickness); i.setLineDash(C) } for (var S = !0; f < p.length; f++)if (!((b = p[f].x.getTime ? p[f].x.getTime() : p[f].x) < t.axisX.dataInfo.viewPortMin || b > t.axisX.dataInfo.viewPortMax && (!d.connectNullData || !S))) if (null !== p[f].y && p[f].y.length && "number" === typeof p[f].y[0] && "number" === typeof p[f].y[1]) { if (u = t.axisX.convertValueToPixel(b), m = t.axisY.convertValueToPixel(p[f].y[0]), x = t.axisY.convertValueToPixel(p[f].y[1]), y || S ? (d.connectNullData && !y ? (i.setLineDash && (d.options.nullDataLineDashType || w === d.lineDashType && d.lineDashType !== d.nullDataLineDashType) && (l[l.length - 1].newLineDashArray = C, w = d.nullDataLineDashType, i.setLineDash(P)), i.lineTo(u, m), Y && n.lineTo(u, m), l.push({ x: u, y: x })) : (i.beginPath(), i.moveTo(u, m), v = { x: u, y: m }, (l = []).push({ x: u, y: x }), Y && (n.beginPath(), n.moveTo(u, m))), S = y = !1) : (i.lineTo(u, m), l.push({ x: u, y: x }), Y && n.lineTo(u, m), 0 == f % 250 && e()), b = d.dataPointIds[f], this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: f, x1: u, y1: m, y2: x }, f < p.length - 1 && (T !== (p[f].lineColor || M) || w !== (p[f].lineDashType || d.lineDashType)) && (e(), T = p[f].lineColor || M, l[l.length - 1].newStrokeStyle = T, i.strokeStyle = T, i.setLineDash && (p[f].lineDashType ? (w = p[f].lineDashType, l[l.length - 1].newLineDashArray = g(w, d.lineThickness), i.setLineDash(l[l.length - 1].newLineDashArray)) : (w = d.lineDashType, l[l.length - 1].newLineDashArray = C, i.setLineDash(C)))), 0 !== p[f].markerSize && (0 < p[f].markerSize || 0 < d.markerSize)) { var A = d.getMarkerProperties(f, u, x, i); s.push(A); var E = c(b); Y && s.push({ x: u, y: x, ctx: n, type: A.type, size: A.size, color: E, borderColor: E, borderThickness: A.borderThickness }), A = d.getMarkerProperties(f, u, m, i), s.push(A), E = c(b), Y && s.push({ x: u, y: m, ctx: n, type: A.type, size: A.size, color: E, borderColor: E, borderThickness: A.borderThickness }) } (p[f].indexLabel || d.indexLabel || p[f].indexLabelFormatter || d.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeArea", dataPoint: p[f], dataSeries: d, indexKeyword: 0, point: { x: u, y: m }, direction: p[f].y[0] > p[f].y[1] === t.axisY.reversed ? -1 : 1, color: k }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: p[f], dataSeries: d, indexKeyword: 1, point: { x: u, y: x }, direction: p[f].y[0] > p[f].y[1] === t.axisY.reversed ? 1 : -1, color: k })) } else S || y || e(), S = !0; e(), et.drawMarkers(s) } } return Y && (a.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), i.restore(), { source: a, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderRangeSplineArea = function (t) { function e(t, e) { var a = s(y, 2); if (0 < a.length) { if (0 < d.lineThickness) { i.strokeStyle = e, i.setLineDash && i.setLineDash(t), i.beginPath(), i.moveTo(a[0].x, a[0].y); for (var o = 0; o < a.length - 3; o += 3)(a[o].newStrokeStyle || a[o].newLineDashArray) && (i.stroke(), i.beginPath(), i.moveTo(a[o].x, a[o].y), a[o].newStrokeStyle && (i.strokeStyle = a[o].newStrokeStyle), a[o].newLineDashArray && i.setLineDash(a[o].newLineDashArray)), i.bezierCurveTo(a[o + 1].x, a[o + 1].y, a[o + 2].x, a[o + 2].y, a[o + 3].x, a[o + 3].y); i.stroke() } for (i.beginPath(), i.moveTo(a[0].x, a[0].y), Y && (n.beginPath(), n.moveTo(a[0].x, a[0].y)), o = 0; o < a.length - 3; o += 3)i.bezierCurveTo(a[o + 1].x, a[o + 1].y, a[o + 2].x, a[o + 2].y, a[o + 3].x, a[o + 3].y), Y && n.bezierCurveTo(a[o + 1].x, a[o + 1].y, a[o + 2].x, a[o + 2].y, a[o + 3].x, a[o + 3].y); for (a = s(f, 2), i.lineTo(f[f.length - 1].x, f[f.length - 1].y), o = a.length - 1; 2 < o; o -= 3)i.bezierCurveTo(a[o - 1].x, a[o - 1].y, a[o - 2].x, a[o - 2].y, a[o - 3].x, a[o - 3].y), Y && n.bezierCurveTo(a[o - 1].x, a[o - 1].y, a[o - 2].x, a[o - 2].y, a[o - 3].x, a[o - 3].y); if (i.closePath(), i.globalAlpha = d.fillOpacity, i.fill(), Y && (n.closePath(), n.fill()), i.globalAlpha = 1, 0 < d.lineThickness) { i.strokeStyle = e, i.setLineDash && i.setLineDash(t), i.beginPath(), i.moveTo(a[0].x, a[0].y); for (var r = o = 0; o < a.length - 3; o += 3, r++)(y[r].newStrokeStyle || y[r].newLineDashArray) && (i.stroke(), i.beginPath(), i.moveTo(a[o].x, a[o].y), y[r].newStrokeStyle && (i.strokeStyle = y[r].newStrokeStyle), y[r].newLineDashArray && i.setLineDash(y[r].newLineDashArray)), i.bezierCurveTo(a[o + 1].x, a[o + 1].y, a[o + 2].x, a[o + 2].y, a[o + 3].x, a[o + 3].y); i.stroke() } i.beginPath() } } var a = t.targetCanvasCtx || this.plotArea.ctx, i = Y ? this._preRenderCtx : a; if (!(0 >= t.dataSeriesIndexes.length)) { var n = this._eventManager.ghostCtx, o = [], r = this.plotArea; i.save(), Y && n.save(), i.beginPath(), i.rect(r.x1, r.y1, r.width, r.height), i.clip(), Y && (n.beginPath(), n.rect(r.x1, r.y1, r.width, r.height), n.clip()); for (var l = 0; l < t.dataSeriesIndexes.length; l++) { var h = t.dataSeriesIndexes[l], d = this.data[h], p = d.dataPoints; o = d.id; this._eventManager.objectMap[o] = { objectType: "dataSeries", dataSeriesIndex: h }, o = c(o), n.fillStyle = o; o = []; var u, m, x, b = 0, y = [], f = []; if (0 < p.length) { var v = d._colorSet[b % d._colorSet.length], k = d.lineColor = d.options.lineColor || v, M = k; i.fillStyle = v, i.lineWidth = d.lineThickness; var T, w = "solid"; if (i.setLineDash) { var P = g(d.nullDataLineDashType, d.lineThickness); T = g(w = d.lineDashType, d.lineThickness) } for (m = !1; b < p.length; b++)if (!((u = p[b].x.getTime ? p[b].x.getTime() : p[b].x) < t.axisX.dataInfo.viewPortMin || u > t.axisX.dataInfo.viewPortMax && (!d.connectNullData || !m))) if (null !== p[b].y && p[b].y.length && "number" === typeof p[b].y[0] && "number" === typeof p[b].y[1]) { u = t.axisX.convertValueToPixel(u), m = t.axisY.convertValueToPixel(p[b].y[0]), x = t.axisY.convertValueToPixel(p[b].y[1]); var C = d.dataPointIds[b]; if (this._eventManager.objectMap[C] = { id: C, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: b, x1: u, y1: m, y2: x }, y[y.length] = { x: u, y: m }, f[f.length] = { x: u, y: x }, b < p.length - 1 && (M !== (p[b].lineColor || k) || w !== (p[b].lineDashType || d.lineDashType)) && (M = p[b].lineColor || k, y[y.length - 1].newStrokeStyle = M, i.setLineDash && (p[b].lineDashType ? (w = p[b].lineDashType, y[y.length - 1].newLineDashArray = g(w, d.lineThickness)) : (w = d.lineDashType, y[y.length - 1].newLineDashArray = T))), 0 !== p[b].markerSize && (0 < p[b].markerSize || 0 < d.markerSize)) { var S = d.getMarkerProperties(b, u, m, i); o.push(S); var A = c(C); Y && o.push({ x: u, y: m, ctx: n, type: S.type, size: S.size, color: A, borderColor: A, borderThickness: S.borderThickness }), S = d.getMarkerProperties(b, u, x, i), o.push(S), A = c(C), Y && o.push({ x: u, y: x, ctx: n, type: S.type, size: S.size, color: A, borderColor: A, borderThickness: S.borderThickness }) } (p[b].indexLabel || d.indexLabel || p[b].indexLabelFormatter || d.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: p[b], dataSeries: d, indexKeyword: 0, point: { x: u, y: m }, direction: p[b].y[0] <= p[b].y[1] ? -1 : 1, color: v }), this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: p[b], dataSeries: d, indexKeyword: 1, point: { x: u, y: x }, direction: p[b].y[0] <= p[b].y[1] ? 1 : -1, color: v })), m = !1 } else 0 < b && !m && (d.connectNullData ? i.setLineDash && 0 < y.length && (d.options.nullDataLineDashType || !p[b - 1].lineDashType) && (y[y.length - 1].newLineDashArray = P, w = d.nullDataLineDashType) : (e(T, k), y = [], f = [])), m = !0; e(T, k), et.drawMarkers(o) } } return Y && (a.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore()), i.restore(), { source: a, dest: this.plotArea.ctx, animationCallback: tt.xClipAnimation, easingFunction: tt.easing.linear, animationBase: 0 } } }, a.prototype.renderWaterfall = function (t) { var e = t.targetCanvasCtx || this.plotArea.ctx, a = Y ? this._preRenderCtx : e; if (!(0 >= t.dataSeriesIndexes.length)) { var i, n, s, o, r = this._eventManager.ghostCtx, l = null, h = this.plotArea, d = 0, p = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0); d = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, this.plotArea.width / t.plotType.totalDataSeries * .9) << 0; var u = t.axisX.dataInfo.minDiff; isFinite(u) || (u = .3 * Math.abs(t.axisX.range)), u = this.options.dataPointWidth ? this.dataPointWidth : h.width * (t.axisX.logarithmic ? Math.log(u) / Math.log(t.axisX.range) : Math.abs(u) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .6 << 0, this.dataPointMaxWidth && d > n && (d = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, n)), !this.dataPointMaxWidth && this.dataPointMinWidth && n < d && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, d)), u < d && (u = d), u > n && (u = n), a.save(), Y && this._eventManager.ghostCtx.save(), a.beginPath(), a.rect(h.x1, h.y1, h.width, h.height), a.clip(), Y && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip()); for (var m = 0; m < t.dataSeriesIndexes.length; m++) { var x = t.dataSeriesIndexes[m], b = this.data[x], y = b.dataPoints; l = b._colorSet[0]; b.risingColor = b.options.risingColor ? b.options.risingColor : l, b.fallingColor = b.options.fallingColor ? b.options.fallingColor : "#e40a0a"; var f = "number" === typeof b.options.lineThickness ? Math.round(b.lineThickness) : 1, v = 1 === Math.round(f) % 2 ? -.5 : 0; if (0 < y.length) { var k = !!(5 < u && b.bevelEnabled), M = !1, T = null, w = null; for (d = 0; d < y.length; d++)if (o = y[d].getTime ? y[d].x.getTime() : y[d].x, "number" !== typeof y[d].y) { if (0 < d && !M && b.connectNullData) var P = b.options.nullDataLineDashType || !y[d - 1].lineDashType ? b.nullDataLineDashType : y[d - 1].lineDashType; M = !0 } else { i = t.axisX.convertValueToPixel(o), n = 0 === b.dataPointEOs[d].cumulativeSum ? p : t.axisY.convertValueToPixel(b.dataPointEOs[d].cumulativeSum), s = 0 === b.dataPointEOs[d].cumulativeSumYStartValue ? p : t.axisY.convertValueToPixel(b.dataPointEOs[d].cumulativeSumYStartValue), i = t.axisX.reversed ? i + t.plotType.totalDataSeries * u / 2 - (t.previousDataSeriesCount + m) * u << 0 : i - t.plotType.totalDataSeries * u / 2 + (t.previousDataSeriesCount + m) * u << 0; var C = t.axisX.reversed ? i - u << 0 : i + u << 0; n > s && (l = n, n = s, s = l), t.axisY.reversed && (l = n, n = s, s = l), l = b.dataPointIds[d], this._eventManager.objectMap[l] = { id: l, objectType: "dataPoint", dataSeriesIndex: x, dataPointIndex: d, x1: i, y1: n, x2: C, y2: s }; var S = y[d].color ? y[d].color : 0 < y[d].y ? b.risingColor : b.fallingColor; dt(a, i, n, C, s, S, 0, S, k, k, !1, !1, b.fillOpacity), l = c(l), Y && dt(this._eventManager.ghostCtx, i, n, C, s, l, 0, null, !1, !1, !1, !1); var A; S = i; A = "undefined" !== typeof y[d].isIntermediateSum && !0 === y[d].isIntermediateSum || "undefined" !== typeof y[d].isCumulativeSum && !0 === y[d].isCumulativeSum ? 0 < y[d].y ? n : s : 0 < y[d].y ? s : n, 0 < d && T && (!M || b.connectNullData) && (M && a.setLineDash && a.setLineDash(g(P, f)), a.beginPath(), a.moveTo(T, w - v), a.lineTo(S, A - v), 0 < f && a.stroke(), Y && (r.beginPath(), r.moveTo(T, w - v), r.lineTo(S, A - v), 0 < f && r.stroke())), M = !1, T = C, w = 0 < y[d].y ? n : s, S = y[d].lineDashType ? y[d].lineDashType : b.options.lineDashType ? b.options.lineDashType : "shortDash", a.strokeStyle = y[d].lineColor ? y[d].lineColor : b.options.lineColor ? b.options.lineColor : "#9e9e9e", a.lineWidth = f, a.setLineDash && (S = g(S, f), a.setLineDash(S)), (y[d].indexLabel || b.indexLabel || y[d].indexLabelFormatter || b.indexLabelFormatter) && this._indexLabels.push({ chartType: "waterfall", dataPoint: y[d], dataSeries: b, point: { x: i + (C - i) / 2, y: 0 <= y[d].y ? n : s }, direction: 0 > y[d].y === t.axisY.reversed ? 1 : -1, bounds: { x1: i, y1: Math.min(n, s), x2: C, y2: Math.max(n, s) }, color: l }) } } } return Y && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore()), a.restore(), { source: e, dest: this.plotArea.ctx, animationCallback: tt.fadeInAnimation, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } }; var J = function (t, e, a, i, n, s, o, r, l) { if (!(0 > a)) { if ("undefined" === typeof r && (r = 1), !Y) { var h = Number((o % (2 * Math.PI)).toFixed(8)); Number((s % (2 * Math.PI)).toFixed(8)) === h && (o -= 1e-4) } t.save(), t.globalAlpha = r, "pie" === n ? (t.beginPath(), t.moveTo(e.x, e.y), t.arc(e.x, e.y, a, s, o, !1), t.fillStyle = i, t.strokeStyle = "white", t.lineWidth = 2, t.closePath(), t.fill()) : "doughnut" === n && (t.beginPath(), t.arc(e.x, e.y, a, s, o, !1), 0 <= l && t.arc(e.x, e.y, l * a, o, s, !0), t.closePath(), t.fillStyle = i, t.strokeStyle = "white", t.lineWidth = 2, t.fill()), t.globalAlpha = 1, t.restore() } }; a.prototype.renderPie = function (t) { function e(t) { var e = r.plotArea.ctx; for (e.clearRect(u.x1, u.y1, u.width, u.height), e.fillStyle = r.backgroundColor, e.fillRect(u.x1, u.y1, u.width, u.height), e = 0; e < c.length; e++) { var a = m[e].startAngle, i = m[e].endAngle; if (i > a) { var n = .07 * T * Math.cos(m[e].midAngle), s = .07 * T * Math.sin(m[e].midAngle), o = !1; c[e].exploded ? (1e-9 < Math.abs(m[e].center.x - (v.x + n)) || 1e-9 < Math.abs(m[e].center.y - (v.y + s))) && (m[e].center.x = v.x + n * t, m[e].center.y = v.y + s * t, o = !0) : (0 < Math.abs(m[e].center.x - v.x) || 0 < Math.abs(m[e].center.y - v.y)) && (m[e].center.x = v.x + n * (1 - t), m[e].center.y = v.y + s * (1 - t), o = !0), o && ((n = {}).dataSeries = h, n.dataPoint = h.dataPoints[e], n.index = e, r.toolTip.highlightObjects([n])), J(r.plotArea.ctx, m[e].center, m[e].radius, c[e].color ? c[e].color : h._colorSet[e % h._colorSet.length], h.type, a, i, h.fillOpacity, m[e].percentInnerRadius) } } for ((t = r.plotArea.ctx).save(), t.fillStyle = "black", t.strokeStyle = "grey", t.textBaseline = "middle", t.lineJoin = "round", e = e = 0; e < c.length; e++)(a = m[e]).indexLabelText && (a.indexLabelTextBlock.y -= a.indexLabelTextBlock.height / 2, i = 0, i = "left" === a.hemisphere ? "inside" !== h.indexLabelPlacement ? -(a.indexLabelTextBlock.width + d) : -a.indexLabelTextBlock.width / 2 : "inside" !== h.indexLabelPlacement ? d : -a.indexLabelTextBlock.width / 2, a.indexLabelTextBlock.x += i, a.indexLabelTextBlock.render(!0), a.indexLabelTextBlock.x -= i, a.indexLabelTextBlock.y += a.indexLabelTextBlock.height / 2, "inside" !== a.indexLabelPlacement && 0 < a.indexLabelLineThickness && (i = a.center.x + T * Math.cos(a.midAngle), n = a.center.y + T * Math.sin(a.midAngle), t.strokeStyle = a.indexLabelLineColor, t.lineWidth = a.indexLabelLineThickness, t.setLineDash && t.setLineDash(g(a.indexLabelLineDashType, a.indexLabelLineThickness)), t.beginPath(), t.moveTo(i, n), t.lineTo(a.indexLabelTextBlock.x, a.indexLabelTextBlock.y), t.lineTo(a.indexLabelTextBlock.x + ("left" === a.hemisphere ? -d : d), a.indexLabelTextBlock.y), t.stroke()), t.lineJoin = "miter"); t.save() } function a(t, e) { var a = 0, i = (a = t.indexLabelTextBlock.y - t.indexLabelTextBlock.height / 2, t.indexLabelTextBlock.y + t.indexLabelTextBlock.height / 2), n = e.indexLabelTextBlock.y - e.indexLabelTextBlock.height / 2, s = e.indexLabelTextBlock.y + e.indexLabelTextBlock.height / 2; return e.indexLabelTextBlock.y > t.indexLabelTextBlock.y ? n - i : a - s } function i(t) { for (var e = null, i = 1; i < c.length; i++) { if (e = (t + i + m.length) % m.length, m[e].hemisphere !== m[t].hemisphere) { e = null; break } if (m[e].indexLabelText && e !== t && (0 > a(m[e], m[t]) || ("right" === m[t].hemisphere ? m[e].indexLabelTextBlock.y >= m[t].indexLabelTextBlock.y : m[e].indexLabelTextBlock.y <= m[t].indexLabelTextBlock.y))) break; e = null } return e } function n(t, e, s) { if (1e3 < (s = (s || 0) + 1)) return 0; e = e || 0; var o = 0, r = v.y - 1 * l, h = v.y + 1 * l; if (0 <= t && t < c.length) { var d = m[t]; if (0 > e && d.indexLabelTextBlock.y < r || 0 < e && d.indexLabelTextBlock.y > h) return 0; var p = 0, u = 0; u = p = p = 0; for (0 > e ? d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 > r && d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 + e < r && (e = -(r - (d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 + e))) : d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 < r && d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 + e > h && (e = d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 + e - h), e = d.indexLabelTextBlock.y + e, r = 0, r = "right" === d.hemisphere ? v.x + Math.sqrt(Math.pow(l, 2) - Math.pow(e - v.y, 2)) : v.x - Math.sqrt(Math.pow(l, 2) - Math.pow(e - v.y, 2)), u = v.x + T * Math.cos(d.midAngle), p = v.y + T * Math.sin(d.midAngle), p = Math.sqrt(Math.pow(r - u, 2) + Math.pow(e - p, 2)), u = Math.acos(T / l), e = (p = Math.acos((l * l + T * T - p * p) / (2 * T * l))) < u ? e - d.indexLabelTextBlock.y : 0, r = null, h = 1; h < c.length; h++) { if (r = (t - h + m.length) % m.length, m[r].hemisphere !== m[t].hemisphere) { r = null; break } if (m[r].indexLabelText && m[r].hemisphere === m[t].hemisphere && r !== t && (0 > a(m[r], m[t]) || ("right" === m[t].hemisphere ? m[r].indexLabelTextBlock.y <= m[t].indexLabelTextBlock.y : m[r].indexLabelTextBlock.y >= m[t].indexLabelTextBlock.y))) break; r = null } u = r, p = i(t), h = r = 0, 0 > e ? (o = e, null !== (h = "right" === d.hemisphere ? u : p) && (u = -e, (e = d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 - (m[h].indexLabelTextBlock.y + m[h].indexLabelTextBlock.height / 2)) - u < x && (+(h = n(h, r = -u, s + 1)).toFixed(f) > +r.toFixed(f) && (o = e > x ? -(e - x) : -(u - (h - r)))))) : 0 < e && (o = e, null !== (h = "right" === d.hemisphere ? p : u) && (u = e, (e = m[h].indexLabelTextBlock.y - m[h].indexLabelTextBlock.height / 2 - (d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2)) - u < x && (+(h = n(h, r = u, s + 1)).toFixed(f) < +r.toFixed(f) && (o = e > x ? e - x : u - (r - h))))), o && (s = d.indexLabelTextBlock.y + o, e = 0, e = "right" === d.hemisphere ? v.x + Math.sqrt(Math.pow(l, 2) - Math.pow(s - v.y, 2)) : v.x - Math.sqrt(Math.pow(l, 2) - Math.pow(s - v.y, 2)), d.midAngle > Math.PI / 2 - y && d.midAngle < Math.PI / 2 + y ? (r = (t - 1 + m.length) % m.length, r = m[r], t = m[(t + 1 + m.length) % m.length], "left" === d.hemisphere && "right" === r.hemisphere && e > r.indexLabelTextBlock.x ? e = r.indexLabelTextBlock.x - 15 : "right" === d.hemisphere && "left" === t.hemisphere && e < t.indexLabelTextBlock.x && (e = t.indexLabelTextBlock.x + 15)) : d.midAngle > 3 * Math.PI / 2 - y && d.midAngle < 3 * Math.PI / 2 + y && (r = (t - 1 + m.length) % m.length, r = m[r], t = m[(t + 1 + m.length) % m.length], "right" === d.hemisphere && "left" === r.hemisphere && e < r.indexLabelTextBlock.x ? e = r.indexLabelTextBlock.x + 15 : "left" === d.hemisphere && "right" === t.hemisphere && e > t.indexLabelTextBlock.x && (e = t.indexLabelTextBlock.x - 15)), d.indexLabelTextBlock.y = s, d.indexLabelTextBlock.x = e, d.indexLabelAngle = Math.atan2(d.indexLabelTextBlock.y - v.y, d.indexLabelTextBlock.x - v.x)) } return o } function s() { (g = r.plotArea.ctx).fillStyle = "grey", g.strokeStyle = "grey", g.font = "16px Arial", g.textBaseline = "middle"; var t = g = 0, e = 0, s = !0; for (t = 0; 10 > t && (1 > t || 0 < e); t++) { if ((h.radius || !h.radius && "undefined" !== typeof h.innerRadius && null !== h.innerRadius && T - e <= w) && (s = !1), s && (T -= e), e = 0, "inside" !== h.indexLabelPlacement) { for (l = T * b, g = 0; g < c.length; g++) { (y = m[g]).indexLabelTextBlock.x = v.x + l * Math.cos(y.midAngle), y.indexLabelTextBlock.y = v.y + l * Math.sin(y.midAngle), y.indexLabelAngle = y.midAngle, y.radius = T, y.percentInnerRadius = P } for (var o, p, g = 0; g < c.length; g++) { var y = m[g], k = i(g); if (null !== k) { o = m[g], p = m[k]; var M = 0; if (0 > (M = a(o, p) - x)) { for (var C = p = 0, S = 0; S < c.length; S++)S !== g && m[S].hemisphere === y.hemisphere && (m[S].indexLabelTextBlock.y < y.indexLabelTextBlock.y ? p++ : C++); C = -1 * (M - (p = M / (p + C || 1) * C)); var A = S = 0; "right" === y.hemisphere ? (S = n(g, p), +(A = n(k, C = -1 * (M - S))).toFixed(f) < +C.toFixed(f) && +S.toFixed(f) <= +p.toFixed(f) && n(g, -(C - A))) : (S = n(k, p), +(A = n(g, C = -1 * (M - S))).toFixed(f) < +C.toFixed(f) && +S.toFixed(f) <= +p.toFixed(f) && n(k, -(C - A))) } } } } else for (g = 0; g < c.length; g++)y = m[g], l = "pie" === h.type ? .7 * T : .8 * T, k = v.x + l * Math.cos(y.midAngle), p = v.y + l * Math.sin(y.midAngle), y.indexLabelTextBlock.x = k, y.indexLabelTextBlock.y = p; for (g = 0; g < c.length; g++)0 !== (k = (y = m[g]).indexLabelTextBlock.measureText()).height && 0 !== k.width && (k = k = 0, "right" === y.hemisphere ? (k = u.x2 - (y.indexLabelTextBlock.x + y.indexLabelTextBlock.width + d), k *= -1) : k = u.x1 - (y.indexLabelTextBlock.x - y.indexLabelTextBlock.width - d), 0 < k && (!s && y.indexLabelText && (p = "right" === y.hemisphere ? u.x2 - y.indexLabelTextBlock.x : y.indexLabelTextBlock.x - u.x1, .3 * y.indexLabelTextBlock.maxWidth > p ? y.indexLabelText = "" : y.indexLabelTextBlock.maxWidth = .85 * p, .3 * y.indexLabelTextBlock.maxWidth < p && (y.indexLabelTextBlock.x -= "right" === y.hemisphere ? 2 : -2)), Math.abs(y.indexLabelTextBlock.y - y.indexLabelTextBlock.height / 2 - v.y) < T || Math.abs(y.indexLabelTextBlock.y + y.indexLabelTextBlock.height / 2 - v.y) < T) && (9 < (k /= Math.abs(Math.cos(y.indexLabelAngle))) && (k *= .3), k > e && (e = k)), k = k = 0, 0 < y.indexLabelAngle && y.indexLabelAngle < Math.PI ? (k = u.y2 - (y.indexLabelTextBlock.y + y.indexLabelTextBlock.height / 2 + 5), k *= -1) : k = u.y1 - (y.indexLabelTextBlock.y - y.indexLabelTextBlock.height / 2 - 5), 0 < k && (!s && y.indexLabelText && (0 === n(g, k * (p = 0 < y.indexLabelAngle && y.indexLabelAngle < Math.PI ? -1 : 1)) && n(g, 2 * p)), Math.abs(y.indexLabelTextBlock.x - v.x) < T && (9 < (k /= Math.abs(Math.sin(y.indexLabelAngle))) && (k *= .3), k > e && (e = k)))); var E = function (t, e, a) { for (var i = [], n = 0; i.push(m[e]), e !== a; e = (e + 1 + c.length) % c.length); for (i.sort((function (t, e) { return t.y - e.y })), e = 0; e < i.length && (a = i[e], n < .7 * t); e++)n += a.indexLabelTextBlock.height, a.indexLabelTextBlock.text = "", a.indexLabelText = "", a.indexLabelTextBlock.measureText() }; !function () { for (var t = -1, e = -1, n = 0, s = !1, r = 0; r < c.length; r++)if (s = !1, (o = m[r]).indexLabelText) { var l = i(r); if (null !== l) { var h, p = m[l]; if (M = 0, h = 0 > (M = a(o, p))) { h = o.indexLabelTextBlock.x; var u = o.indexLabelTextBlock.y - o.indexLabelTextBlock.height / 2, x = o.indexLabelTextBlock.y + o.indexLabelTextBlock.height / 2, g = p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2, b = p.indexLabelTextBlock.x + p.indexLabelTextBlock.width, y = p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2; h = !(o.indexLabelTextBlock.x + o.indexLabelTextBlock.width < p.indexLabelTextBlock.x - d || h > b + d || u > y + d || x < g - d) } h ? (0 > t && (t = r), l !== t && (e = l, n += -M), 0 === r % Math.max(c.length / 10, 3) && (s = !0)) : s = !0, s && 0 < n && 0 <= t && 0 <= e && (E(n, t, e), e = t = -1, n = 0) } } 0 < n && E(n, t, e) }() } } function o() { if (r.plotArea.layoutManager.reset(), r.title && (r.title.dockInsidePlotArea || "center" === r.title.horizontalAlign && "center" === r.title.verticalAlign) && r.title.render(), r.subtitles) for (var t = 0; t < r.subtitles.length; t++) { var e = r.subtitles[t]; (e.dockInsidePlotArea || "center" === e.horizontalAlign && "center" === e.verticalAlign) && e.render() } r.legend && (r.legend.dockInsidePlotArea || "center" === r.legend.horizontalAlign && "center" === r.legend.verticalAlign) && (r.legend.setLayout(), r.legend.render()) } var r = this; if (!(0 >= t.dataSeriesIndexes.length)) { var l, h = this.data[t.dataSeriesIndexes[0]], c = h.dataPoints, d = 10, u = this.plotArea, m = h.dataPointEOs, x = 2, b = 1.3, y = 20 / 180 * Math.PI, f = 6, v = { x: (u.x2 + u.x1) / 2, y: (u.y2 + u.y1) / 2 }, k = 0; t = !1; for (var M = 0; M < c.length; M++)k += Math.abs(c[M].y), !t && "undefined" !== typeof c[M].indexLabel && null !== c[M].indexLabel && 0 < c[M].indexLabel.toString().length && (t = !0), !t && "undefined" !== typeof c[M].label && null !== c[M].label && 0 < c[M].label.toString().length && (t = !0); if (0 !== k) { t = t || "undefined" !== typeof h.indexLabel && null !== h.indexLabel && 0 < h.indexLabel.toString().length; var T = "inside" !== h.indexLabelPlacement && t ? .75 * Math.min(u.width, u.height) / 2 : .92 * Math.min(u.width, u.height) / 2; h.radius && (T = D(h.radius, T)); var w = "undefined" !== typeof h.innerRadius && null !== h.innerRadius ? D(h.innerRadius, T) : .7 * T; h.radius = T, "doughnut" === h.type && (h.innerRadius = w); var P = Math.min(w / T, (T - 1) / T); this.pieDoughnutClickHandler = function (t) { r.isAnimating || !p(t.dataSeries.explodeOnClick) && !t.dataSeries.explodeOnClick || ((t = t.dataPoint).exploded = !t.exploded, 1 < this.dataPoints.length && r._animator.animate(0, 500, (function (t) { e(t), o() }))) }, function () { if (h && c) { for (var t = 0, e = 0, a = 0, i = 0, n = 0; n < c.length; n++) { var s = c[n], o = h.dataPointIds[n]; m[n].id = o, m[n].objectType = "dataPoint", m[n].dataPointIndex = n, m[n].dataSeriesIndex = 0; var l = m[n], d = { percent: null, total: null }, x = null; d = r.getPercentAndTotal(h, s); (h.indexLabelFormatter || s.indexLabelFormatter) && (x = { chart: r.options, dataSeries: h, dataPoint: s, total: d.total, percent: d.percent }), d = s.indexLabelFormatter ? s.indexLabelFormatter(x) : s.indexLabel ? r.replaceKeywordsWithValue(s.indexLabel, s, h, n) : h.indexLabelFormatter ? h.indexLabelFormatter(x) : h.indexLabel ? r.replaceKeywordsWithValue(h.indexLabel, s, h, n) : s.label ? s.label : "", r._eventManager.objectMap[o] = l, l.center = { x: v.x, y: v.y }, l.y = s.y, l.radius = T, l.percentInnerRadius = P, l.indexLabelText = d, l.indexLabelPlacement = h.indexLabelPlacement, l.indexLabelLineColor = s.indexLabelLineColor ? s.indexLabelLineColor : h.options.indexLabelLineColor ? h.options.indexLabelLineColor : s.color ? s.color : h._colorSet[n % h._colorSet.length], l.indexLabelLineThickness = p(s.indexLabelLineThickness) ? h.indexLabelLineThickness : s.indexLabelLineThickness, l.indexLabelLineDashType = s.indexLabelLineDashType ? s.indexLabelLineDashType : h.indexLabelLineDashType, l.indexLabelFontColor = s.indexLabelFontColor ? s.indexLabelFontColor : h.indexLabelFontColor, l.indexLabelFontStyle = s.indexLabelFontStyle ? s.indexLabelFontStyle : h.indexLabelFontStyle, l.indexLabelFontWeight = s.indexLabelFontWeight ? s.indexLabelFontWeight : h.indexLabelFontWeight, l.indexLabelFontSize = p(s.indexLabelFontSize) ? h.indexLabelFontSize : s.indexLabelFontSize, l.indexLabelFontFamily = s.indexLabelFontFamily ? s.indexLabelFontFamily : h.indexLabelFontFamily, l.indexLabelBackgroundColor = s.indexLabelBackgroundColor ? s.indexLabelBackgroundColor : h.options.indexLabelBackgroundColor ? h.options.indexLabelBackgroundColor : h.indexLabelBackgroundColor, l.indexLabelMaxWidth = s.indexLabelMaxWidth ? s.indexLabelMaxWidth : h.indexLabelMaxWidth ? h.indexLabelMaxWidth : .33 * u.width, l.indexLabelWrap = "undefined" !== typeof s.indexLabelWrap ? s.indexLabelWrap : h.indexLabelWrap, l.startAngle = 0 === n ? h.startAngle ? h.startAngle / 180 * Math.PI : 0 : m[n - 1].endAngle, l.startAngle = (l.startAngle + 2 * Math.PI) % (2 * Math.PI), l.endAngle = l.startAngle + 2 * Math.PI / k * Math.abs(s.y), s = ((s = (l.endAngle + l.startAngle) / 2) + 2 * Math.PI) % (2 * Math.PI), l.midAngle = s, l.midAngle > Math.PI / 2 - y && l.midAngle < Math.PI / 2 + y ? ((0 === t || m[a].midAngle > l.midAngle) && (a = n), t++) : l.midAngle > 3 * Math.PI / 2 - y && l.midAngle < 3 * Math.PI / 2 + y && ((0 === e || m[i].midAngle > l.midAngle) && (i = n), e++), l.hemisphere = s > Math.PI / 2 && s <= 3 * Math.PI / 2 ? "left" : "right", l.indexLabelTextBlock = new E(r.plotArea.ctx, { fontSize: l.indexLabelFontSize, fontFamily: l.indexLabelFontFamily, fontColor: l.indexLabelFontColor, fontStyle: l.indexLabelFontStyle, fontWeight: l.indexLabelFontWeight, horizontalAlign: "left", backgroundColor: l.indexLabelBackgroundColor, maxWidth: l.indexLabelMaxWidth, maxHeight: l.indexLabelWrap ? 5 * l.indexLabelFontSize : 1.5 * l.indexLabelFontSize, text: l.indexLabelText, padding: 0, textBaseline: "top" }), l.indexLabelTextBlock.measureText() } for (o = s = 0, d = !1, n = 0; n < c.length; n++)l = m[(a + n) % c.length], 1 < t && l.midAngle > Math.PI / 2 - y && l.midAngle < Math.PI / 2 + y && (s <= t / 2 && !d ? (l.hemisphere = "right", s++) : (l.hemisphere = "left", d = !0)); for (d = !1, n = 0; n < c.length; n++)l = m[(i + n) % c.length], 1 < e && l.midAngle > 3 * Math.PI / 2 - y && l.midAngle < 3 * Math.PI / 2 + y && (o <= e / 2 && !d ? (l.hemisphere = "left", o++) : (l.hemisphere = "right", d = !0)) } }(), s(), s(), s(), s(), this.disableToolTip = !0, this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, (function (t) { var e = r.plotArea.ctx; for (e.clearRect(u.x1, u.y1, u.width, u.height), e.fillStyle = r.backgroundColor, e.fillRect(u.x1, u.y1, u.width, u.height), t = m[0].startAngle + 2 * Math.PI * t, e = 0; e < c.length; e++) { var a = 0 === e ? m[e].startAngle : i, i = a + (m[e].endAngle - m[e].startAngle), n = !1; i > t && (i = t, n = !0); var s = c[e].color ? c[e].color : h._colorSet[e % h._colorSet.length]; if (i > a && J(r.plotArea.ctx, m[e].center, m[e].radius, s, h.type, a, i, h.fillOpacity, m[e].percentInnerRadius), n) break } o() }), (function () { r.disableToolTip = !1, r._animator.animate(0, r.animatedRender ? 500 : 0, (function (t) { e(t), o() })) })) } } }; var K = function (t, e, a, i) { "undefined" === typeof a && (a = 1), 0 >= Math.round(e.y4 - e.y1) || (t.save(), t.globalAlpha = a, t.beginPath(), t.moveTo(Math.round(e.x1), Math.round(e.y1)), t.lineTo(Math.round(e.x2), Math.round(e.y2)), t.lineTo(Math.round(e.x3), Math.round(e.y3)), t.lineTo(Math.round(e.x4), Math.round(e.y4)), "undefined" !== e.x5 && (t.lineTo(Math.round(e.x5), Math.round(e.y5)), t.lineTo(Math.round(e.x6), Math.round(e.y6))), t.closePath(), t.fillStyle = i || e.color, t.fill(), t.globalAplha = 1, t.restore()) }; a.prototype.renderFunnel = function (t) { function e() { var t, e, a, i; if ("inside" !== m.indexLabelPlacement) for (var n = 0; n < R.length; n++)0 == G[n].textBlock.text.length ? G[n].isDirty = !0 : (a = "undefined" !== typeof (t = R[n]).x5 ? (t.y2 + t.y4) / 2 : (t.y2 + t.y3) / 2, e = m.reversed ? "undefined" !== typeof t.x5 && a > W ? l(a).x2 + 1 : (t.x2 + t.x3) / 2 + 1 : "undefined" !== typeof t.x5 ? a < W ? l(a).x2 + 1 : (t.x4 + t.x3) / 2 + 1 : (t.x2 + t.x3) / 2 + 1, G[n].textBlock.x = e + B, G[n].textBlock.y = a - G[n].height / 2, m.reversed ? (G[n].textBlock.y + G[n].height > D + y && (G[n].textBlock.y = D + y - G[n].height), G[n].textBlock.y < z - y && (G[n].textBlock.y = z - y)) : (G[n].textBlock.y < D - y && (G[n].textBlock.y = D - y), G[n].textBlock.y + G[n].height > z + y && (G[n].textBlock.y = z + y - G[n].height))); else for (n = 0; n < R.length; n++)0 == G[n].textBlock.text.length ? G[n].isDirty = !0 : (e = (t = R[n]).height, a = G[n].height, i = G[n].width, e >= a ? (e = n != O ? (t.x4 + t.x3) / 2 - i / 2 : (t.x5 + t.x4) / 2 - i / 2, a = n != O ? (t.y1 + t.y3) / 2 - a / 2 : (t.y1 + t.y4) / 2 - a / 2, G[n].textBlock.x = e, G[n].textBlock.y = a) : G[n].isDirty = !0) } function a(t, e) { return (e < R.length ? G[e].textBlock.y : m.reversed ? D + y : z + y) - (0 > t ? m.reversed ? z - y : D - y : G[t].textBlock.y + G[t].height + q) } function i(t, a, i) { var s, o, r, l = [], d = y, p = []; if (-1 !== a && (0 <= J.indexOf(a) ? (o = J.indexOf(a), J.splice(o, 1)) : (J.push(a), J = J.sort((function (t, e) { return t - e })))), 0 === J.length) l = Q; else { o = y * (1 != J.length || 0 != J[0] && J[0] != R.length - 1 ? 2 : 1) / function () { for (var t = 0, e = 0; e < R.length - 1; e++)(0 <= J.indexOf(e) || 0 <= J.indexOf(e + 1)) && t++; return t }(); for (var u = 0; u < R.length; u++) { if (1 == J.length && 0 == J[0]) { if (0 === u) { l.push(Q[u]), s = d; continue } } else 0 === u && (s = -1 * d); l.push(Q[u] + s), (0 <= J.indexOf(u) || u < R.length && 0 <= J.indexOf(u + 1)) && (s += o) } } r = function () { for (var t = [], e = 0; e < R.length; e++)t.push(l[e] - R[e].y1); return t }(); (new Date).getTime(); var g = function (t) { for (var e, a, i = 0; i < R.length; i++)e = r[i], a = R[i], e *= t, "undefined" === typeof p[i] && (p[i] = 0), 0 > p && (p *= -1), a.y1 += e - p[i], a.y2 += e - p[i], a.y3 += e - p[i], a.y4 += e - p[i], a.y5 && (a.y5 += e - p[i], a.y6 += e - p[i]), p[i] = e }; t._animator.animate(0, i, (function (i) { var s = t.plotArea.ctx || t.ctx; Z = !0, s.clearRect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1), s.fillStyle = t.backgroundColor, s.fillRect(b.x1, b.y1, b.width, b.height), g(i, a); var o = {}; for (o.dataSeries = m, o.dataPoint = m.reversed ? m.dataPoints[x.length - 1 - a] : m.dataPoints[a], o.index = m.reversed ? x.length - 1 - a : a, t.toolTip.highlightObjects([o]), o = 0; o < R.length; o++)K(s, R[o], m.fillOpacity); c(s), T && ("inside" !== m.indexLabelPlacement ? n(s) : e(), h(s)), 1 <= i && (Z = !1) }), null, tt.easing.easeOutQuart) } function n(t) { for (var e, a, i, n, s = 0; s < R.length; s++)n = 1 === G[s].lineThickness % 2 ? .5 : 0, e = l(a = ((R[s].y2 + R[s].y4) / 2 << 0) + n).x2 - 1, i = G[s].textBlock.x, n = (G[s].textBlock.y + G[s].height / 2 << 0) + n, G[s].isDirty || 0 == G[s].lineThickness || (t.strokeStyle = G[s].lineColor, t.lineWidth = G[s].lineThickness, t.setLineDash && t.setLineDash(g(G[s].lineDashType, G[s].lineThickness)), t.beginPath(), t.moveTo(e, a), t.lineTo(i, n), t.stroke()) } function s(t) { for (t -= 1; -1 <= t && -1 != t && G[t].isDirty; t--); return t } function o(t) { for (t += 1; t <= R.length && t != R.length && G[t].isDirty; t++); return t } function l(t) { for (var e, a = 0; a < x.length; a++)if (R[a].y1 < t && R[a].y4 > t) { e = R[a]; break } return e ? { x1: t = e.y6 && t > e.y6 ? e.x3 + (e.x4 - e.x3) / (e.y4 - e.y3) * (t - e.y3) : e.x2 + (e.x3 - e.x2) / (e.y3 - e.y2) * (t - e.y2), x2: t } : -1 } function h(t) { for (var e = 0; e < R.length; e++)G[e].isDirty || (t && (G[e].textBlock.ctx = t), G[e].textBlock.render(!0)) } function c(t) { if (d.plotArea.layoutManager.reset(), t.roundRect || r(t), d.title && (d.title.dockInsidePlotArea || "center" === d.title.horizontalAlign && "center" === d.title.verticalAlign) && (d.title.ctx = t, d.title.render()), d.subtitles) for (var e = 0; e < d.subtitles.length; e++) { var a = d.subtitles[e]; (a.dockInsidePlotArea || "center" === a.horizontalAlign && "center" === a.verticalAlign) && (d.subtitles.ctx = t, a.render()) } d.legend && (d.legend.dockInsidePlotArea || "center" === d.legend.horizontalAlign && "center" === d.legend.verticalAlign) && (d.legend.ctx = t, d.legend.setLayout(), d.legend.render()), X.fNg && X.fNg(d) } var d = this; if (!(0 >= t.dataSeriesIndexes.length)) { for (var m = this.data[t.dataSeriesIndexes[0]], x = m.dataPoints, b = this.plotArea, y = .025 * b.width, f = .01 * b.width, v = 0, k = b.height - 2 * y, M = Math.min(b.width - 2 * f, 2.8 * b.height), T = !1, w = 0; w < x.length; w++)!T && "undefined" !== typeof x[w].indexLabel && null !== x[w].indexLabel && 0 < x[w].indexLabel.toString().length && (T = !0), !T && "undefined" !== typeof x[w].label && null !== x[w].label && 0 < x[w].label.toString().length && (T = !0), (!T && "function" === typeof m.indexLabelFormatter || "function" === typeof x[w].indexLabelFormatter) && (T = !0); T = T || "undefined" !== typeof m.indexLabel && null !== m.indexLabel && 0 < m.indexLabel.toString().length, "inside" !== m.indexLabelPlacement && T || (f = (b.width - .75 * M) / 2); w = b.x1 + f; var P = b.x2 - f, C = b.y1 + y, S = b.y2 - y, A = t.targetCanvasCtx || this.plotArea.ctx || this.ctx; if (0 != m.length && m.dataPoints && m.visible && 0 !== x.length) { var _, F, B = 30 * (P - (t = 75 * M / 100)) / 100; "funnel" === m.type ? (_ = p(m.options.neckHeight) ? .35 * k : m.neckHeight, F = p(m.options.neckWidth) ? .25 * t : m.neckWidth, "string" === typeof _ && _.match(/%$/) ? _ = (_ = parseInt(_)) * k / 100 : _ = parseInt(_), "string" === typeof F && F.match(/%$/) ? F = (F = parseInt(F)) * t / 100 : F = parseInt(F), _ > k ? _ = k : 0 >= _ && (_ = 0), F > t ? F = t - .5 : 0 >= F && (F = 0)) : "pyramid" === m.type && (F = _ = 0, m.reversed = !m.reversed); f = w + t / 2; var L = w, I = w + t, D = m.reversed ? S : C, N = f - F / 2, V = f + F / 2, W = m.reversed ? C + _ : S - _, z = m.reversed ? C : S; t = []; f = []; var O, R = [], j = (M = [], C), U = (W - D) / (N - L), H = -U; if (-1 !== (w = "area" === (m.valueRepresents ? m.valueRepresents : "height") ? function () { var t, e, a = L, i = I, n = N, s = V; t = C, e = S - _, s = Math.abs((e - t) * (i - a + (s - n)) / 2), t = e - t, e = (n = V - N) * (e - S), e = s + (e = Math.abs(e)), s = []; for (var o = 0, r = 0; r < x.length; r++) { if ("undefined" === typeof x[r].y) return -1; x[r].y = "number" === typeof x[r].y ? x[r].y : 0, o += Math.abs(x[r].y) } if (0 === o) return -1; var l, h, c = s[0] = 0, d = 0; for (i = i - a, c = !1, r = 0; r < x.length; r++)a = Math.abs(x[r].y) * e / o, c ? l = 0 == Number(n.toFixed(3)) ? 0 : a / n : 0 > (h = U * U * i * i - 4 * Math.abs(U) * a) ? (a -= c = (i + (h = n)) * (t - d) / 2, l = t - d, d += t - d, l += 0 == h ? 0 : a / h, d += a / h, c = !0) : (h = i - 2 * (l = (Math.abs(U) * i - Math.sqrt(h)) / 2) / Math.abs(U), (d += l) > t && (c = (i + (h = n)) * (t - (d -= l)) / 2, l = t - d, d += t - d, l += (a -= c) / h, d += a / h, c = !0), i = h), s.push(l); return s }() : function () { for (var t = 0, e = [], a = 0; a < x.length; a++) { if ("undefined" === typeof x[a].y) return -1; x[a].y = "number" === typeof x[a].y ? x[a].y : 0, t += Math.abs(x[a].y) } if (0 === t) return -1; for (a = e[0] = 0; a < x.length; a++)e.push(Math.abs(x[a].y) * k / t); return e }())) { if (m.reversed) for (M.push(j), F = w.length - 1; 0 < F; F--)j += w[F], M.push(j); else for (F = 0; F < w.length; F++)j += w[F], M.push(j); if (m.reversed) for (F = 0; F < w.length; F++)M[F] < W ? (t.push(N), f.push(V), O = F) : (t.push((M[F] - D + U * L) / U), f.push((M[F] - D + H * I) / H)); else for (F = 0; F < w.length; F++)M[F] < W ? (t.push((M[F] - D + U * L) / U), f.push((M[F] - D + H * I) / H), O = F) : (t.push(N), f.push(V)); for (F = 0; F < w.length - 1; F++)j = m.reversed ? x[x.length - 1 - F].color ? x[x.length - 1 - F].color : m._colorSet[(x.length - 1 - F) % m._colorSet.length] : x[F].color ? x[F].color : m._colorSet[F % m._colorSet.length], F === O ? R.push({ x1: t[F], y1: M[F], x2: f[F], y2: M[F], x3: V, y3: W, x4: f[F + 1], y4: M[F + 1], x5: t[F + 1], y5: M[F + 1], x6: N, y6: W, id: F, height: M[F + 1] - M[F], color: j }) : R.push({ x1: t[F], y1: M[F], x2: f[F], y2: M[F], x3: f[F + 1], y3: M[F + 1], x4: t[F + 1], y4: M[F + 1], id: F, height: M[F + 1] - M[F], color: j }); var q = 2, G = [], Z = !1, J = [], Q = []; w = !1; for (t = t = 0, u(J), F = 0; F < x.length; F++)x[F].exploded && (w = !0, m.reversed ? J.push(x.length - 1 - F) : J.push(F)); if (A.clearRect(b.x1, b.y1, b.width, b.height), A.fillStyle = d.backgroundColor, A.fillRect(b.x1, b.y1, b.width, b.height), T && m.visible && (function () { if (m && x) { for (var t, e, a, i, n, s, o, h, c, u, g, b, y, f, v = [], k = [], M = { percent: null, total: null }, T = null, w = 0; w < x.length; w++)f = l(f = "undefined" !== typeof (f = R[w]).x5 ? (f.y2 + f.y4) / 2 : (f.y2 + f.y3) / 2).x2 + 1, v[w] = P - f - B; f = .5 * B; w = 0; for (var C = x.length - 1; w < x.length || 0 <= C; w++, C--)t = (e = m.reversed ? x[C] : x[w]).color ? e.color : m.reversed ? m._colorSet[(x.length - 1 - w) % m._colorSet.length] : m._colorSet[w % m._colorSet.length], a = e.indexLabelPlacement || m.indexLabelPlacement || "outside", i = e.indexLabelBackgroundColor || m.indexLabelBackgroundColor || (Y ? "transparent" : null), n = e.indexLabelFontColor || m.indexLabelFontColor || "#979797", s = p(e.indexLabelFontSize) ? m.indexLabelFontSize : e.indexLabelFontSize, o = e.indexLabelFontStyle || m.indexLabelFontStyle || "normal", h = e.indexLabelFontFamily || m.indexLabelFontFamily || "arial", c = e.indexLabelFontWeight || m.indexLabelFontWeight || "normal", t = e.indexLabelLineColor || m.options.indexLabelLineColor || t, u = "number" === typeof e.indexLabelLineThickness ? e.indexLabelLineThickness : "number" === typeof m.indexLabelLineThickness ? m.indexLabelLineThickness : 2, g = e.indexLabelLineDashType || m.indexLabelLineDashType || "solid", b = "undefined" !== typeof e.indexLabelWrap ? e.indexLabelWrap : "undefined" === typeof m.indexLabelWrap || m.indexLabelWrap, y = m.dataPointIds[w], d._eventManager.objectMap[y] = { id: y, objectType: "dataPoint", dataPointIndex: w, dataSeriesIndex: 0, funnelSection: R[m.reversed ? x.length - 1 - w : w] }, "inside" === m.indexLabelPlacement && (v[w] = w !== O ? m.reversed ? R[w].x2 - R[w].x1 : R[w].x3 - R[w].x4 : R[w].x3 - R[w].x6, 20 > v[w] && (v[w] = w !== O && m.reversed ? R[w].x3 - R[w].x4 : R[w].x2 - R[w].x1, v[w] /= 2)), ((y = e.indexLabelMaxWidth ? e.indexLabelMaxWidth : m.options.indexLabelMaxWidth ? m.indexLabelMaxWidth : v[w]) > v[w] || 0 > y) && (y = v[w]), k[w] = "inside" === m.indexLabelPlacement && R[w].height, M = d.getPercentAndTotal(m, e), (m.indexLabelFormatter || e.indexLabelFormatter) && (T = { chart: d.options, dataSeries: m, dataPoint: e, total: M.total, percent: M.percent }), e = e.indexLabelFormatter ? e.indexLabelFormatter(T) : e.indexLabel ? d.replaceKeywordsWithValue(e.indexLabel, e, m, w) : m.indexLabelFormatter ? m.indexLabelFormatter(T) : m.indexLabel ? d.replaceKeywordsWithValue(m.indexLabel, e, m, w) : e.label ? e.label : "", 0 >= u && (u = 0), 1e3 > y && 1e3 - y < f && (y += 1e3 - y), A.roundRect || r(A), (a = new E(A, { fontSize: s, fontFamily: h, fontColor: n, fontStyle: o, fontWeight: c, horizontalAlign: a, backgroundColor: i, maxWidth: y, maxHeight: !1 === k[w] ? b ? 4.28571429 * s : 1.5 * s : k[w], text: e, padding: q })).measureText(), G.push({ textBlock: a, id: m.reversed ? C : w, isDirty: !1, lineColor: t, lineThickness: u, lineDashType: g, height: a.height < a.maxHeight ? a.height : a.maxHeight, width: a.width < a.maxWidth ? a.width : a.maxWidth }) } }(), e(), function () { var t, e, a, i, n, s = []; n = !1, a = 0; for (var r, l = P - I - B / 2, h = (l = m.options.indexLabelMaxWidth ? m.indexLabelMaxWidth > l ? l : m.indexLabelMaxWidth : l, G.length - 1); 0 <= h; h--)r = x[G[h].id], i = (a = G[h]).textBlock, e = (t = o(h) < R.length ? G[o(h)] : null) ? t.textBlock : null, a = a.height, t && i.y + a + q > e.y && (n = !0), ((a = r.indexLabelMaxWidth || l) > l || 0 > a) && (a = l), s.push(a); if (n) for (h = G.length - 1; 0 <= h; h--)t = R[h], G[h].textBlock.maxWidth = s[s.length - (h + 1)], G[h].textBlock.measureText(), G[h].textBlock.x = P - l, a = G[h].textBlock.height < G[h].textBlock.maxHeight ? G[h].textBlock.height : G[h].textBlock.maxHeight, n = G[h].textBlock.width < G[h].textBlock.maxWidth ? G[h].textBlock.width : G[h].textBlock.maxWidth, G[h].height = a, G[h].width = n, a = "undefined" !== typeof t.x5 ? (t.y2 + t.y4) / 2 : (t.y2 + t.y3) / 2, G[h].textBlock.y = a - G[h].height / 2, m.reversed ? (G[h].textBlock.y + G[h].height > D + y && (G[h].textBlock.y = D + y - G[h].height), G[h].textBlock.y < z - y && (G[h].textBlock.y = z - y)) : (G[h].textBlock.y < D - y && (G[h].textBlock.y = D - y), G[h].textBlock.y + G[h].height > z + y && (G[h].textBlock.y = z + y - G[h].height)) }(), "inside" !== m.indexLabelPlacement)) { for (function () { function t(e, i) { var n; if (0 > e || e >= G.length) return 0; var r, l = G[e].textBlock; return 0 > i ? (i *= -1, (n = a(r = s(e), e)) >= i ? (l.y -= i, i) : 0 == e ? (0 < n && (l.y -= n), n) : (0 < (n += t(r, -(i - n))) && (l.y -= n), n)) : (n = a(e, r = o(e))) >= i ? (l.y += i, i) : e == R.length - 1 ? (0 < n && (l.y += n), n) : (0 < (n += t(r, i - n)) && (l.y += n), n) } function e() { var t, e, a, n, r, l = 0; n = (S - C + 2 * y) / p, r = p; for (var h, c = 1; c < r; c++) { a = c * n; for (var d = G.length - 1; 0 <= d; d--)!G[d].isDirty && G[d].textBlock.y < a && G[d].textBlock.y + G[d].height > a && (!((h = o(d)) >= G.length - 1) && G[d].textBlock.y + G[d].height + q > G[h].textBlock.y && (G[d].textBlock.y = G[d].textBlock.y + G[d].height - a > a - G[d].textBlock.y ? a + 1 : a - G[d].height - 1)) } for (h = R.length - 1; 0 < h; h--)if (!G[h].isDirty) { if (0 > (a = s(h)) && G[a = 0].isDirty) break; if (G[h].textBlock.y < G[a].textBlock.y + G[a].height) { for (e = e || h, n = h, r = 0; G[n].textBlock.y < G[a].textBlock.y + G[a].height + q;) { if (t = t || G[n].textBlock.y + G[n].height, r += G[n].height, r += q, 0 >= (n = a)) { r += G[n = 0].height; break } if (0 > (a = s(n))) { r += G[n = 0].height; break } } if (n != h) { l = i(t = r - (t -= l = G[n].textBlock.y), e, n); break } } } return l } function i(t, e, a) { var i = [], n = 0, s = 0; for (t = Math.abs(t); a <= e; a++)i.push(R[a]); for (i.sort((function (t, e) { return t.height - e.height })), a = 0; a < i.length && (e = i[a], n < t); a++)s++, n += G[e.id].height + q, G[e.id].textBlock.text = "", G[e.id].indexLabelText = "", G[e.id].isDirty = !0, G[e.id].textBlock.measureText(); return s } for (var n, r, l, h, c, d, p = 1, u = 0; u < 2 * p; u++) { for (var m = G.length - 1; 0 <= m && (0 <= s(m) && s(m), h = (l = G[m]).textBlock, d = (c = o(m) < R.length ? G[o(m)] : null) ? c.textBlock : null, n = +l.height.toFixed(6), r = +h.y.toFixed(6), !(!l.isDirty && c && r + n + q > +d.y.toFixed(6) && (n = h.y + n + q - d.y, r = t(m, -n), r < n && (0 < r && (n -= r), r = t(o(m), n), r != n)))); m--); e() } }(), F = 0; F < x.length; F++)G[F].isDirty || (t = G[F].textBlock.x + G[F].width, t = (P - t) / 2, 0 == F && (v = t), v > t && (v = t)); for (F = 0; F < R.length; F++)R[F].x1 += v, R[F].x2 += v, R[F].x3 += v, R[F].x4 += v, R[F].x5 && (R[F].x5 += v, R[F].x6 += v), G[F].textBlock.x += v } for (F = 0; F < R.length; F++)v = R[F], K(A, v, m.fillOpacity), Q.push(v.y1); if (c(A), T && m.visible && ("inside" === m.indexLabelPlacement || d.animationEnabled || n(A), d.animationEnabled || h()), !T) for (F = 0; F < x.length; F++)t = { id: v = m.dataPointIds[F], objectType: "dataPoint", dataPointIndex: F, dataSeriesIndex: 0, funnelSection: R[m.reversed ? x.length - 1 - F : F] }, d._eventManager.objectMap[v] = t; return (!d.animationEnabled && w || d.animationEnabled && !d.animatedRender) && i(d, -1, 0), this.funnelPyramidClickHandler = function (t) { var e = -1; !Z && !d.isAnimating && (p(t.dataSeries.explodeOnClick) || t.dataSeries.explodeOnClick) && 0 <= (e = m.reversed ? x.length - 1 - t.dataPointIndex : t.dataPointIndex) && (t = e, "funnel" !== m.type && "pyramid" !== m.type || (m.reversed ? x[x.length - 1 - t].exploded = !x[x.length - 1 - t].exploded : x[t].exploded = !x[t].exploded), i(d, e, 500)) }, { source: A, dest: this.plotArea.ctx, animationCallback: function (t, e) { tt.fadeInAnimation(t, e), 1 <= t && (i(d, -1, 500), c(d.plotArea.ctx || d.ctx)) }, easingFunction: tt.easing.easeInQuad, animationBase: 0 } } } } }, a.prototype.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { window.setTimeout(t, 1e3 / 60) }, a.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout, a.prototype.set = function (t, e, i) { i = "undefined" === typeof i || i, "options" === t ? (this.options = e, i && this.render()) : a.base.set.call(this, t, e, i) }, a.prototype.exportChart = function (t) { var e = (t = "undefined" === typeof t ? {} : t).format ? t.format : "png", a = t.fileName ? t.fileName : this.exportFileName; if (t.toDataURL) return this.canvas.toDataURL("image/" + e); h(this.canvas, e, a) }, a.prototype.print = function () { var t = this.exportChart({ toDataURL: !0 }), e = document.createElement("iframe"); e.setAttribute("class", "canvasjs-chart-print-frame"), e.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;"), e.style.height = this.height + "px", this._canvasJSContainer.appendChild(e); var a = this, i = e.contentWindow || e.contentDocument.document || e.contentDocument; i.document.open(), i.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' + t + '"/><body/></html>'), i.document.close(), setTimeout((function () { i.focus(), i.print(), setTimeout((function () { a._canvasJSContainer.removeChild(e) }), 1e3) }), 500) }, a.prototype.getPercentAndTotal = function (t, e) { var a = null, i = null, n = null; if (0 <= t.type.indexOf("stacked")) i = 0, (a = e.x.getTime ? e.x.getTime() : e.x) in t.plotUnit.yTotals && (i = t.plotUnit.yTotals[a], n = isNaN(e.y) ? 0 : e.y / i * 100); else if ("pie" === t.type || "doughnut" === t.type || "funnel" === t.type || "pyramid" === t.type) { for (a = i = 0; a < t.dataPoints.length; a++)isNaN(t.dataPoints[a].y) || (i += t.dataPoints[a].y); n = isNaN(e.y) ? 0 : e.y / i * 100 } return { percent: n, total: i } }, a.prototype.replaceKeywordsWithValue = function (t, e, a, i, n) { var s = this; if (n = "undefined" === typeof n ? 0 : n, (0 <= a.type.indexOf("stacked") || "pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) && (0 <= t.indexOf("#percent") || 0 <= t.indexOf("#total"))) { var r = "#percent", l = "#total", h = this.getPercentAndTotal(a, e); l = isNaN(h.total) ? l : h.total, r = isNaN(h.percent) ? r : h.percent; do { if (h = "", a.percentFormatString) h = a.percentFormatString; else { h = "#,##0."; var c = Math.max(Math.ceil(Math.log(1 / Math.abs(r)) / Math.LN10), 2); !isNaN(c) && isFinite(c) || (c = 2); for (var d = 0; d < c; d++)h += "#"; a.percentFormatString = h } t = (t = t.replace("#percent", st(r, h, s._cultureInfo))).replace("#total", st(l, a.yValueFormatString ? a.yValueFormatString : "#,##0.########", s._cultureInfo)) } while (0 <= t.indexOf("#percent") || 0 <= t.indexOf("#total")) } return t.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, (function (t) { if ('"' === t[0] && '"' === t[t.length - 1] || "'" === t[0] && "'" === t[t.length - 1]) return t.slice(1, t.length - 1); t = (t = o(t.slice(1, t.length - 1))).replace("#index", n); var r = null; try { var h = t.match(/(.*?)\s*\[\s*(.*?)\s*\]/); h && 0 < h.length && (r = o(h[2]), t = o(h[1])) } catch (l) { } if (h = null, "color" === t) return "waterfall" === a.type ? e.color ? e.color : 0 < e.y ? a.risingColor : a.fallingColor : "error" === a.type ? a.color ? a.color : a._colorSet[r % a._colorSet.length] : e.color ? e.color : a.color ? a.color : a._colorSet[i % a._colorSet.length]; if (e.hasOwnProperty(t)) h = e; else { if (!a.hasOwnProperty(t)) return ""; h = a } return h = h[t], null !== r && (h = h[r]), "x" !== t ? "y" === t ? st(h, e.yValueFormatString ? e.yValueFormatString : a.yValueFormatString ? a.yValueFormatString : a.yValueFormatString = "#,##0.########", s._cultureInfo) : "z" === t ? st(h, e.zValueFormatString ? e.zValueFormatString : a.zValueFormatString ? a.zValueFormatString : a.zValueFormatString = "#,##0.########", s._cultureInfo) : h : "dateTime" === a.axisX.valueType || "dateTime" === a.xValueType || e.x && e.x.getTime ? s.plotInfo.plotTypes[0].plotUnits[0].axisX && !s.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic ? nt(h, e.xValueFormatString ? e.xValueFormatString : a.xValueFormatString ? a.xValueFormatString : a.xValueFormatString = s.axisX && s.axisX.autoValueFormatString ? s.axisX.autoValueFormatString : "DD MMM YY", s._cultureInfo) : void 0 : st(h, e.xValueFormatString ? e.xValueFormatString : a.xValueFormatString ? a.xValueFormatString : a.xValueFormatString = "#,##0.########", s._cultureInfo) })) }, i(N, S), N.prototype.setLayout = function () { var t = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, e = t.layoutManager.getFreeSpace(), a = null, i = 0, n = 0, s = 0, o = 0, r = this.markerMargin = this.chart.options.legend && !p(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : .3 * this.fontSize; this.height = 0; var l = [], h = []; "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", a = this.verticalAlign, s = this.maxWidth = null !== this.maxWidth ? this.maxWidth : e.width, o = this.maxHeight = null !== this.maxHeight ? this.maxHeight : .5 * e.height) : "center" === this.verticalAlign && (this.orientation = "vertical", a = this.horizontalAlign, s = this.maxWidth = null !== this.maxWidth ? this.maxWidth : .5 * e.width, o = this.maxHeight = null !== this.maxHeight ? this.maxHeight : e.height), this.errorMarkerColor = []; for (var c = 0; c < this.dataSeries.length; c++) { var d = this.dataSeries[c]; if (d.dataPoints && d.dataPoints.length) if ("pie" !== d.type && "doughnut" !== d.type && "funnel" !== d.type && "pyramid" !== d.type) { var u = d.legendMarkerType = d.legendMarkerType ? d.legendMarkerType : "line" !== d.type && "stepLine" !== d.type && "spline" !== d.type && "scatter" !== d.type && "bubble" !== d.type || !d.markerType ? "error" === d.type && d._linkedSeries ? d._linkedSeries.legendMarkerType ? d._linkedSeries.legendMarkerType : V.getDefaultLegendMarker(d._linkedSeries.type) : V.getDefaultLegendMarker(d.type) : d.markerType, m = d.legendText ? d.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: d, dataPoint: null }) : d.name, x = d.legendMarkerColor = d.legendMarkerColor ? d.legendMarkerColor : d.markerColor ? d.markerColor : "error" === d.type ? p(d.whiskerColor) ? d._colorSet[0] : d.whiskerColor : d._colorSet[0], g = d.markerSize || "line" !== d.type && "stepLine" !== d.type && "spline" !== d.type ? .75 * this.lineHeight : 0, b = d.legendMarkerBorderColor ? d.legendMarkerBorderColor : d.markerBorderColor, y = d.legendMarkerBorderThickness ? d.legendMarkerBorderThickness : d.markerBorderThickness ? Math.max(1, Math.round(.2 * g)) : 0; "error" === d.type && this.errorMarkerColor.push(x), u = { markerType: u, markerColor: x, text: m = this.chart.replaceKeywordsWithValue(m, d.dataPoints[0], d, c), textBlock: null, chartType: d.type, markerSize: g, lineColor: d._colorSet[0], dataSeriesIndex: d.index, dataPointIndex: null, markerBorderColor: b, markerBorderThickness: y }, l.push(u) } else for (var f = 0; f < d.dataPoints.length; f++) { var v = d.dataPoints[f]; u = v.legendMarkerType ? v.legendMarkerType : d.legendMarkerType ? d.legendMarkerType : V.getDefaultLegendMarker(d.type), m = v.legendText ? v.legendText : d.legendText ? d.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: d, dataPoint: v }) : v.name ? v.name : "DataPoint: " + (f + 1), x = v.legendMarkerColor ? v.legendMarkerColor : d.legendMarkerColor ? d.legendMarkerColor : v.color ? v.color : d.color ? d.color : d._colorSet[f % d._colorSet.length], g = .75 * this.lineHeight, b = v.legendMarkerBorderColor ? v.legendMarkerBorderColor : d.legendMarkerBorderColor ? d.legendMarkerBorderColor : v.markerBorderColor ? v.markerBorderColor : d.markerBorderColor, y = v.legendMarkerBorderThickness ? v.legendMarkerBorderThickness : d.legendMarkerBorderThickness ? d.legendMarkerBorderThickness : v.markerBorderThickness || d.markerBorderThickness ? Math.max(1, Math.round(.2 * g)) : 0, u = { markerType: u, markerColor: x, text: m = this.chart.replaceKeywordsWithValue(m, v, d, f), textBlock: null, chartType: d.type, markerSize: g, dataSeriesIndex: c, dataPointIndex: f, markerBorderColor: b, markerBorderThickness: y }; (v.showInLegend || d.showInLegend && !1 !== v.showInLegend) && l.push(u) } } if (!0 === this.reversed && l.reverse(), 0 < l.length) { for (d = null, x = m = v = f = 0, v = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, s) : this.itemMaxWidth = Math.min(this.itemWidth, s) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, s) : this.itemMaxWidth = s, v -= (g = 0 === g ? .75 * this.lineHeight : g) + r, c = 0; c < l.length; c++)b = v, "line" !== (u = l[c]).chartType && "spline" !== u.chartType && "stepLine" !== u.chartType || (b -= .2 * this.lineHeight), 0 >= o || "undefined" === typeof o || 0 >= b || "undefined" === typeof b || ("horizontal" === this.orientation ? (u.textBlock = new E(this.ctx, { x: 0, y: 0, maxWidth: b, maxHeight: this.itemWrap ? o : this.lineHeight, angle: 0, text: u.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }), u.textBlock.measureText(), null !== this.itemWidth && (u.textBlock.width = this.itemWidth - (g + r + ("line" === u.chartType || "spline" === u.chartType || "stepLine" === u.chartType ? .2 * this.lineHeight : 0))), (!d || d.width + Math.round(u.textBlock.width + g + r + (0 === d.width ? 0 : this.horizontalSpacing) + ("line" === u.chartType || "spline" === u.chartType || "stepLine" === u.chartType ? .2 * this.lineHeight : 0)) > s) && (d = { items: [], width: 0 }, h.push(d), this.height += m, m = 0), m = Math.max(m, u.textBlock.height)) : (u.textBlock = new E(this.ctx, { x: 0, y: 0, maxWidth: v, maxHeight: !0 === this.itemWrap ? o : 1.5 * this.fontSize, angle: 0, text: u.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }), u.textBlock.measureText(), null !== this.itemWidth && (u.textBlock.width = this.itemWidth - (g + r + ("line" === u.chartType || "spline" === u.chartType || "stepLine" === u.chartType ? .2 * this.lineHeight : 0))), this.height < o - this.lineHeight ? (d = { items: [], width: 0 }, h.push(d)) : (d = h[f], f = (f + 1) % h.length), this.height += u.textBlock.height), u.textBlock.x = d.width, u.textBlock.y = 0, d.width += Math.round(u.textBlock.width + g + r + (0 === d.width ? 0 : this.horizontalSpacing) + ("line" === u.chartType || "spline" === u.chartType || "stepLine" === u.chartType ? .2 * this.lineHeight : 0)), d.items.push(u), this.width = Math.max(d.width, this.width), x = u.textBlock.width + (g + r + ("line" === u.chartType || "spline" === u.chartType || "stepLine" === u.chartType ? .2 * this.lineHeight : 0))); this.itemWidth = x, this.height = !1 === this.itemWrap ? h.length * this.lineHeight : this.height + m, this.height = Math.min(o, this.height), this.width = Math.min(s, this.width) } for ("top" === this.verticalAlign ? (n = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, i = e.y1) : "center" === this.verticalAlign ? (n = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, i = e.y1 + e.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (n = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, i = e.y2 - this.height), this.items = l, c = 0; c < this.items.length; c++)(u = l[c]).id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[u.id] = { id: u.id, objectType: "legendItem", legendItemIndex: c, dataSeriesIndex: u.dataSeriesIndex, dataPointIndex: u.dataPointIndex }; this.markerSize = g, this.rows = h, 0 < l.length && t.layoutManager.registerSpace(a, { width: this.width + 2 + 2, height: this.height + 5 + 5 }), this.bounds = { x1: n, y1: i, x2: n + this.width, y2: i + this.height } }, N.prototype.render = function () { var t = this.bounds.x1, e = this.bounds.y1, a = this.markerMargin, i = this.maxWidth, n = this.maxHeight, s = this.markerSize, o = this.rows; (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(t, e, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor); for (var r = 0, l = 0; l < o.length; l++) { for (var h = o[l], d = 0, p = 0; p < h.items.length; p++) { var u = h.items[p], m = u.textBlock.x + t + (0 === p ? .2 * s : this.horizontalSpacing), x = e + r, g = m; if (this.chart.data[u.dataSeriesIndex].visible || (this.ctx.globalAlpha = .5), this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(t, e, i, Math.max(n - n % this.lineHeight, 0)), this.ctx.clip(), "line" !== u.chartType && "stepLine" !== u.chartType && "spline" !== u.chartType || (this.ctx.strokeStyle = u.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(m - .1 * this.lineHeight, x + this.lineHeight / 2), this.ctx.lineTo(m + .85 * this.lineHeight, x + this.lineHeight / 2), this.ctx.stroke(), g -= .1 * this.lineHeight), "error" === u.chartType) { this.ctx.strokeStyle = this.errorMarkerColor[0], this.ctx.lineWidth = s / 8, this.ctx.beginPath(); var b = m - .08 * this.lineHeight + .1 * this.lineHeight, y = x + .15 * this.lineHeight, f = .7 * this.lineHeight, v = f + .02 * this.lineHeight; this.ctx.moveTo(b, y), this.ctx.lineTo(b + f, y), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(b + f / 2, y), this.ctx.lineTo(b + f / 2, y + v), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(b, y + v), this.ctx.lineTo(b + f, y + v), this.ctx.stroke(), this.errorMarkerColor.shift() } et.drawMarker(m + s / 2, x + this.lineHeight / 2, this.ctx, u.markerType, "error" === u.chartType || "line" === u.chartType || "spline" === u.chartType ? u.markerSize / 2 : u.markerSize, u.markerColor, u.markerBorderColor, u.markerBorderThickness), u.textBlock.x = m + a + s, "line" !== u.chartType && "stepLine" !== u.chartType && "spline" !== u.chartType || (u.textBlock.x += .1 * this.lineHeight), u.textBlock.y = Math.round(x + this.lineHeight / 2), u.textBlock.render(!0), this.ctx.restore(), d = 0 < p ? Math.max(d, u.textBlock.height) : u.textBlock.height, this.chart.data[u.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1), m = c(u.id), this.ghostCtx.fillStyle = m, this.ghostCtx.beginPath(), this.ghostCtx.fillRect(g, u.textBlock.y - this.lineHeight / 2, u.textBlock.x + u.textBlock.width - g, u.textBlock.height), u.x1 = this.chart._eventManager.objectMap[u.id].x1 = g, u.y1 = this.chart._eventManager.objectMap[u.id].y1 = u.textBlock.y - this.lineHeight / 2, u.x2 = this.chart._eventManager.objectMap[u.id].x2 = u.textBlock.x + u.textBlock.width, u.y2 = this.chart._eventManager.objectMap[u.id].y2 = u.textBlock.y + u.textBlock.height - this.lineHeight / 2 } r += d } }, i(V, S), V.prototype.getDefaultAxisPlacement = function () { var t = this.type; return "column" === t || "line" === t || "stepLine" === t || "spline" === t || "area" === t || "stepArea" === t || "splineArea" === t || "stackedColumn" === t || "stackedLine" === t || "bubble" === t || "scatter" === t || "stackedArea" === t || "stackedColumn100" === t || "stackedLine100" === t || "stackedArea100" === t || "candlestick" === t || "ohlc" === t || "rangeColumn" === t || "rangeArea" === t || "rangeSplineArea" === t || "boxAndWhisker" === t || "waterfall" === t ? "normal" : "bar" === t || "stackedBar" === t || "stackedBar100" === t || "rangeBar" === t ? "xySwapped" : "pie" === t || "doughnut" === t || "funnel" === t || "pyramid" === t ? "none" : ("error" !== t && window.console.log("Unknown Chart Type: " + t), null) }, V.getDefaultLegendMarker = function (t) { return "column" === t || "stackedColumn" === t || "stackedLine" === t || "bar" === t || "stackedBar" === t || "stackedBar100" === t || "bubble" === t || "scatter" === t || "stackedColumn100" === t || "stackedLine100" === t || "stepArea" === t || "candlestick" === t || "ohlc" === t || "rangeColumn" === t || "rangeBar" === t || "rangeArea" === t || "rangeSplineArea" === t || "boxAndWhisker" === t || "waterfall" === t ? "square" : "line" === t || "stepLine" === t || "spline" === t || "pie" === t || "doughnut" === t ? "circle" : "area" === t || "splineArea" === t || "stackedArea" === t || "stackedArea100" === t || "funnel" === t || "pyramid" === t ? "triangle" : "error" === t ? "none" : (window.console.log("Unknown Chart Type: " + t), null) }, V.prototype.getDataPointAtX = function (t, e) { if (!this.dataPoints || 0 === this.dataPoints.length) return null; var a = { dataPoint: null, distance: 1 / 0, index: NaN }, i = null, n = 0, s = 0, o = 1, r = 1 / 0, l = 0, h = 0, c = 0; for ("none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? c = 1 < (c = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x)) ? Math.min(Math.max((this.dataPoints.length - 1) / c * Math.log(t / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0 : c = 0 < (c = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) ? Math.min(Math.max((this.dataPoints.length - 1) / c * (t - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0); ;) { if (0 <= (s = 0 < o ? c + n : c - n) && s < this.dataPoints.length) { i = this.dataPoints[s]; var d = this.axisX.logarithmic ? i.x > t ? i.x / t : t / i.x : Math.abs(i.x - t); if (d < a.distance && (a.dataPoint = i, a.distance = d, a.index = s), (i = d) <= r ? r = i : 0 < o ? l++ : h++, 1e3 < l && 1e3 < h) break } else if (0 > c - n && c + n >= this.dataPoints.length) break; -1 === o ? (n++, o = 1) : o = -1 } return e || a.dataPoint.x !== t ? e && null !== a.dataPoint ? a : null : a }, V.prototype.getDataPointAtXY = function (t, e, a) { if (!this.dataPoints || 0 === this.dataPoints.length || t < this.chart.plotArea.x1 || t > this.chart.plotArea.x2 || e < this.chart.plotArea.y1 || e > this.chart.plotArea.y2) return null; a = a || !1; var i = [], n = 0, s = 0, o = 1, r = !1, l = 1 / 0, h = 0, c = 0, d = 0; if ("none" !== this.chart.plotInfo.axisPlacement) if (d = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: t, y: e }), this.axisX.logarithmic) d = 1 < (p = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x)) ? Math.min(Math.max((this.dataPoints.length - 1) / p * Math.log(d / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0; else d = 0 < (p = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) ? Math.min(Math.max((this.dataPoints.length - 1) / p * (d - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0; for (; ;) { if (0 <= (s = 0 < o ? d + n : d - n) && s < this.dataPoints.length) { var p = this.chart._eventManager.objectMap[this.dataPointIds[s]], u = this.dataPoints[s], m = null; if (p) { switch (this.type) { case "column": case "stackedColumn": case "stackedColumn100": case "bar": case "stackedBar": case "stackedBar100": case "rangeColumn": case "rangeBar": case "waterfall": case "error": t >= p.x1 && t <= p.x2 && e >= p.y1 && e <= p.y2 && (i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: Math.min(Math.abs(p.x1 - t), Math.abs(p.x2 - t), Math.abs(p.y1 - e), Math.abs(p.y2 - e)) }), r = !0); break; case "line": case "stepLine": case "spline": case "area": case "stepArea": case "stackedArea": case "stackedArea100": case "splineArea": case "scatter": var x = f("markerSize", u, this) || 4, g = a ? 20 : x; (m = Math.sqrt(Math.pow(p.x1 - t, 2) + Math.pow(p.y1 - e, 2))) <= g && i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: m }), (p = Math.abs(p.x1 - t)) <= l ? l = p : 0 < o ? h++ : c++, m <= x / 2 && (r = !0); break; case "rangeArea": case "rangeSplineArea": x = f("markerSize", u, this) || 4, g = a ? 20 : x, (m = Math.min(Math.sqrt(Math.pow(p.x1 - t, 2) + Math.pow(p.y1 - e, 2)), Math.sqrt(Math.pow(p.x1 - t, 2) + Math.pow(p.y2 - e, 2)))) <= g && i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: m }), (p = Math.abs(p.x1 - t)) <= l ? l = p : 0 < o ? h++ : c++, m <= x / 2 && (r = !0); break; case "bubble": x = p.size, (m = Math.sqrt(Math.pow(p.x1 - t, 2) + Math.pow(p.y1 - e, 2))) <= x / 2 && (i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: m }), r = !0); break; case "pie": case "doughnut": x = p.center, g = "doughnut" === this.type ? p.percentInnerRadius * p.radius : 0, (m = Math.sqrt(Math.pow(x.x - t, 2) + Math.pow(x.y - e, 2))) < p.radius && m > g && (0 > (m = Math.atan2(e - x.y, t - x.x)) && (m += 2 * Math.PI), m = Number(((m / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), x = Number(((p.startAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), 0 === (g = Number(((p.endAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12))) && 1 < p.endAngle && (g = 360), x >= g && 0 !== u.y && (g += 360, m < x && (m += 360)), m > x && m < g && (i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: 0 }), r = !0)); break; case "funnel": case "pyramid": e > (m = p.funnelSection).y1 && e < m.y4 && (m.y6 ? e > m.y6 ? (s = m.x6 + (m.x5 - m.x6) / (m.y5 - m.y6) * (e - m.y6), m = m.x3 + (m.x4 - m.x3) / (m.y4 - m.y3) * (e - m.y3)) : (s = m.x1 + (m.x6 - m.x1) / (m.y6 - m.y1) * (e - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (e - m.y2)) : (s = m.x1 + (m.x4 - m.x1) / (m.y4 - m.y1) * (e - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (e - m.y2)), t > s && t < m && (i.push({ dataPoint: u, dataPointIndex: p.dataPointIndex, dataSeries: this, distance: 0 }), r = !0)); break; case "boxAndWhisker": (t >= p.x1 - p.borderThickness / 2 && t <= p.x2 + p.borderThickness / 2 && e >= p.y4 - p.borderThickness / 2 && e <= p.y1 + p.borderThickness / 2 || Math.abs(p.x2 - t + p.x1 - t) < p.borderThickness && e >= p.y1 && e <= p.y4) && (i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: Math.min(Math.abs(p.x1 - t), Math.abs(p.x2 - t), Math.abs(p.y2 - e), Math.abs(p.y3 - e)) }), r = !0); break; case "candlestick": (t >= p.x1 - p.borderThickness / 2 && t <= p.x2 + p.borderThickness / 2 && e >= p.y2 - p.borderThickness / 2 && e <= p.y3 + p.borderThickness / 2 || Math.abs(p.x2 - t + p.x1 - t) < p.borderThickness && e >= p.y1 && e <= p.y4) && (i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: Math.min(Math.abs(p.x1 - t), Math.abs(p.x2 - t), Math.abs(p.y2 - e), Math.abs(p.y3 - e)) }), r = !0); break; case "ohlc": (Math.abs(p.x2 - t + p.x1 - t) < p.borderThickness && e >= p.y2 && e <= p.y3 || t >= p.x1 && t <= (p.x2 + p.x1) / 2 && e >= p.y1 - p.borderThickness / 2 && e <= p.y1 + p.borderThickness / 2 || t >= (p.x1 + p.x2) / 2 && t <= p.x2 && e >= p.y4 - p.borderThickness / 2 && e <= p.y4 + p.borderThickness / 2) && (i.push({ dataPoint: u, dataPointIndex: s, dataSeries: this, distance: Math.min(Math.abs(p.x1 - t), Math.abs(p.x2 - t), Math.abs(p.y2 - e), Math.abs(p.y3 - e)) }), r = !0) }if (r || 1e3 < h && 1e3 < c) break } } else if (0 > d - n && d + n >= this.dataPoints.length) break; -1 === o ? (n++, o = 1) : o = -1 } for (t = null, e = 0; e < i.length; e++)t ? i[e].distance <= t.distance && (t = i[e]) : t = i[e]; return t }, V.prototype.getMarkerProperties = function (t, e, a, i) { var n = this.dataPoints; return { x: e, y: a, ctx: i, type: n[t].markerType ? n[t].markerType : this.markerType, size: n[t].markerSize ? n[t].markerSize : this.markerSize, color: n[t].markerColor ? n[t].markerColor : this.markerColor ? this.markerColor : n[t].color ? n[t].color : this.color ? this.color : this._colorSet[t % this._colorSet.length], borderColor: n[t].markerBorderColor ? n[t].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: n[t].markerBorderThickness ? n[t].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null } }, i(W, S), W.prototype.createExtraLabelsForLog = function (t) { if (!(5 < (t = (t || 0) + 1))) { var e = this.logLabelValues[0] || this.intervalStartPosition; if (Math.log(this.range) / Math.log(e / this.viewportMinimum) < this.noTicks - 1) { for (var a = W.getNiceNumber((e - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), i = Math.ceil(this.viewportMinimum / a) * a; i < e; i += a)i < this.viewportMinimum || this.logLabelValues.push(i); this.logLabelValues.sort(l), this.createExtraLabelsForLog(t) } } }, W.prototype.createLabels = function () { var t, a, i, s, o, r = 0, l = 0, h = 0, c = 0, d = (l = 0, l = this.interval, 0), u = .6 * this.chart.height; t = !1; var m = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], x = m.length ? p(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0; if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) { if (i = this.viewportMaximum, this.labels) { t = Math.ceil(l); var g = !1; for (r = l = Math.ceil(this.intervalStartPosition); r < this.viewportMaximum; r += t) { if (!this.labels[r]) { g = !1; break } g = !0 } g && (this.interval = t, this.intervalStartPosition = l) } if (this.logarithmic && !this.equidistantInterval) for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), l = 0, g = x; l < this.logLabelValues.length; l++)if ((r = this.logLabelValues[l]) < this.viewportMinimum) l++; else { for (; g < m.length && r > m[g].endValue; g++); o = r, (t = g < m.length && r >= m[g].startValue && r <= m[g].endValue) || (t = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: o, label: this.labels[o] ? this.labels[o] : null }) : "axisX" === this.type && this.labels[o] ? this.labels[o] : st(o, this.valueFormatString, this.chart._cultureInfo), t = new E(this.ctx, Object(e.a)({ x: 0, y: 0, maxWidth: h, maxHeight: c, angle: this.labelAngle, text: this.prefix + t + this.suffix, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }, "borderThickness", 0)), this._labels.push({ position: o, textBlock: t, effectiveHeight: null })) } for (g = x, r = this.intervalStartPosition; r <= i; r = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? r * Math.pow(this.logarithmBase, this.interval) : r + this.interval : (this.logarithmic && this.equidistantInterval ? r * Math.pow(this.logarithmBase, this.interval) : r + this.interval).toFixed(12))) { for (; g < m.length && r > m[g].endValue; g++); o = r, (t = g < m.length && r >= m[g].startValue && r <= m[g].endValue) || (t = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: o, label: this.labels[o] ? this.labels[o] : null }) : "axisX" === this.type && this.labels[o] ? this.labels[o] : st(o, this.valueFormatString, this.chart._cultureInfo), t = new E(this.ctx, { x: 0, y: 0, maxWidth: h, maxHeight: c, angle: this.labelAngle, text: this.prefix + t + this.suffix, horizontalAlign: "left", backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this._labels.push({ position: o, textBlock: t, effectiveHeight: null })) } } else for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), i = n(new Date(this.viewportMaximum), this.interval, this.intervalType), g = x, r = this.intervalStartPosition; r < i; n(r, l, this.intervalType)) { for (t = r.getTime(); g < m.length && t > m[g].endValue; g++); o = t, (t = g < m.length && t >= m[g].startValue && t <= m[g].endValue) || (t = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(o), label: this.labels[o] ? this.labels[o] : null }) : "axisX" === this.type && this.labels[o] ? this.labels[o] : nt(o, this.valueFormatString, this.chart._cultureInfo), t = new E(this.ctx, { x: 0, y: 0, maxWidth: h, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxHeight: c, angle: this.labelAngle, text: this.prefix + t + this.suffix, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this._labels.push({ position: o, textBlock: t, effectiveHeight: null, breaksLabelType: void 0 })) } for ("bottom" === this._position || "top" === this._position ? (d = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * $[this.intervalType + "Duration"] * this.interval, h = "undefined" === typeof this.options.labelMaxWidth ? .5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (c = "undefined" === typeof this.options.labelWrap || this.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize)) : "left" !== this._position && "right" !== this._position || (d = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * $[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (h = "undefined" === typeof this.options.labelMaxWidth ? .3 * this.chart.width >> 0 : this.options.labelMaxWidth), c = "undefined" === typeof this.options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize), l = 0; l < this._labels.length; l++) { (t = this._labels[l].textBlock).maxWidth = h, t.maxHeight = c; var b = t.measureText(); s = b.height } if (i = [], x = m = 0, this.labelAutoFit || this.options.labelAutoFit) if (p(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position) if (h = .9 * d >> 0, x = 0, !this.chart.panEnabled && 1 <= this._labels.length) { for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, r = 0; r < this._labels.length; r++)if (!this._labels[r].breaksLabelType) { var y; for (g = (t = this._labels[r].textBlock).text.split(" "), l = 0; l < g.length; l++)o = g[l], this.ctx.font = t.fontStyle + " " + t.fontWeight + " " + t.fontSize + "px " + t.fontFamily, (o = this.ctx.measureText(o)).width > x && (y = r, x = o.width) } for (r = 0, r = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; r < this._labels.length; r++)if (!this._labels[r].breaksLabelType) { for (b = (t = this._labels[r].textBlock).measureText(), g = r + 1; g < this._labels.length; g++)if (!this._labels[g].breaksLabelType) { a = (a = this._labels[g].textBlock).measureText(); break } if (i.push(t.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, i), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), l = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c - t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), p(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle) if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? c : Math.min((l - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), l), o = (u - (s + t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), p(this.options.labelWrap)) { if (p(this.options.labelWrap)) if (p(this.options.labelMaxWidth)) { if (!p(a)) if (l = b.width + a.width >> 0, g = this.labelFontSize, x < h) l - 2 * h > m && (m = l - 2 * h, l >= 2 * h && l < 2.2 * h ? (this.sessionVariables.labelMaxWidth = h, p(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), t.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : l >= 2.2 * h && l < 2.8 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = o, this.sessionVariables.labelFontSize = g) : l >= 2.8 * h && l < 3.2 * h ? (this.sessionVariables.labelMaxWidth = Math.max(h, x), this.sessionVariables.labelWrap = !0, p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : l >= 3.2 * h && l < 3.6 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = o, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * h && l < 5 * h ? (p(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), t.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = o) : l > 5 * h && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelFontSize = g, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelAngle = this.labelAngle)); else if (y === r && (0 === y && x + this._labels[y + 1].textBlock.measureText().width - 2 * h > m || y === this._labels.length - 1 && x + this._labels[y - 1].textBlock.measureText().width - 2 * h > m || 0 < y && y < this._labels.length - 1 && x + this._labels[y + 1].textBlock.measureText().width - 2 * h > m && x + this._labels[y - 1].textBlock.measureText().width - 2 * h > m)) m = 0 === y ? x + this._labels[y + 1].textBlock.measureText().width - 2 * h : x + this._labels[y - 1].textBlock.measureText().width - 2 * h, this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = o; else if (0 === m) for (this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, l = 0; l < this._labels.length; l++)(t = this._labels[l].textBlock).maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, x), o), b = t.measureText(), l < this._labels.length - 1 && (g = l + 1, (a = this._labels[g].textBlock).maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, x), o), a = a.measureText(), b.width + a.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) } else this.options.labelMaxWidth < h ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = l) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c) } else this.labelWrap ? p(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, x), o), this.sessionVariables.labelWrap = this.labelWrap, b.width + a.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle) : p(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelMaxWidth = h, b.width + a.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = o)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = this.labelWrap); else this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? c : Math.min((l - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), l), o = 0 != this.labelAngle ? (u - (s + t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : h, this.sessionVariables.labelMaxHeight = c = this.labelWrap ? (u - o * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, p(this.options.labelWrap) ? p(this.options.labelWrap) && (this.labelWrap && !p(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : o, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = o, this.sessionVariables.labelMaxHeight = l < .9 * d ? .9 * d : l, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : o) : (p(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : o, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = c) } for (l = 0; l < this._labels.length; l++)(t = this._labels[l].textBlock).maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, t.fontSize = this.sessionVariables.labelFontSize, t.angle = this.labelAngle = this.sessionVariables.labelAngle, t.wrap = this.labelWrap = this.sessionVariables.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText() } else for (r = 0; r < this._labels.length; r++)(t = this._labels[r].textBlock).maxWidth = this.labelMaxWidth = p(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, t.fontSize = this.labelFontSize = p(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, t.angle = this.labelAngle = p(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, t.wrap = this.labelWrap = p(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText(); else if ("left" === this._position || "right" === this._position) if (h = p(this.options.labelMaxWidth) ? .3 * this.chart.width >> 0 : this.options.labelMaxWidth, c = "undefined" === typeof this.options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) { for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, r = 0; r < this._labels.length; r++)if (!this._labels[r].breaksLabelType) { for (b = (t = this._labels[r].textBlock).measureText(), g = r + 1; g < this._labels.length; g++)if (!this._labels[g].breaksLabelType) { a = (a = this._labels[g].textBlock).measureText(); break } i.push(t.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, i), l = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c - t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), p(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? p(this.options.labelWrap) ? p(this.options.labelWrap) && (p(this.options.labelMaxWidth) ? p(a) || (d = b.height + a.height >> 0) - 2 * c > x && (x = d - 2 * c, d >= 2 * c && d < 2.4 * c ? (p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : d >= 2.4 * c && d < 2.8 * c ? (this.sessionVariables.labelMaxHeight = l, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : d >= 2.8 * c && d < 3.2 * c ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = !0, p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : d >= 3.2 * c && d < 3.6 * c ? (this.sessionVariables.labelMaxHeight = l, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : d > 3.6 * c && d < 10 * c ? (p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : d > 10 * c && d < 50 * c && (p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle)) : (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap || this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? h : Math.min((l - c * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), c), p(this.options.labelWrap) ? p(this.options.labelWrap) && (this.labelWrap && !p(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = l) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? c : l, p(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? c : l, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = h) : (this.sessionVariables.labelMaxHeight = c, p(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap)) } for (l = 0; l < this._labels.length; l++)(t = this._labels[l].textBlock).maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, t.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, t.angle = this.labelAngle = this.sessionVariables.labelAngle, t.wrap = this.labelWrap = this.sessionVariables.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText() } else for (r = 0; r < this._labels.length; r++)(t = this._labels[r].textBlock).maxWidth = this.labelMaxWidth = p(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, t.fontSize = this.labelFontSize = p(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, t.angle = this.labelAngle = p(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, t.wrap = this.labelWrap = p(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText(); for (r = 0; r < this.stripLines.length; r++) { var f; "outside" === (h = this.stripLines[r]).labelPlacement ? (c = this.sessionVariables.labelMaxWidth, "bottom" !== this._position && "top" !== this._position || (f = p(h.options.labelWrap) ? this.sessionVariables.labelMaxHeight : h.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize), "left" !== this._position && "right" !== this._position || (f = p(h.options.labelWrap) ? this.sessionVariables.labelMaxHeight : h.labelWrap ? .8 * this.chart.width >> 0 : 1.5 * this.labelFontSize), p(h.labelBackgroundColor) && (h.labelBackgroundColor = "#EEEEEE")) : (c = "bottom" === this._position || "top" === this._position ? .9 * this.chart.width >> 0 : .9 * this.chart.height >> 0, f = p(h.options.labelWrap) || h.labelWrap ? "bottom" === this._position || "top" === this._position ? .8 * this.chart.width >> 0 : .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, p(h.labelBackgroundColor) && (p(h.startValue) && 0 !== h.startValue ? h.labelBackgroundColor = Y ? "transparent" : null : h.labelBackgroundColor = "#EEEEEE")), t = new E(this.ctx, { x: 0, y: 0, backgroundColor: h.labelBackgroundColor, borderColor: h.labelBorderColor, borderThickness: h.labelBorderThickness, cornerRadius: h.labelCornerRadius, maxWidth: h.options.labelMaxWidth ? h.options.labelMaxWidth : c, maxHeight: f, angle: this.labelAngle, text: h.labelFormatter ? h.labelFormatter({ chart: this.chart, axis: this, stripLine: h }) : h.label, horizontalAlign: "left", fontSize: "outside" === h.labelPlacement ? h.options.labelFontSize ? h.labelFontSize : this.labelFontSize : h.labelFontSize, fontFamily: "outside" === h.labelPlacement ? h.options.labelFontFamily ? h.labelFontFamily : this.labelFontFamily : h.labelFontFamily, fontWeight: "outside" === h.labelPlacement ? h.options.labelFontWeight ? h.labelFontWeight : this.labelFontWeight : h.labelFontWeight, fontColor: h.labelFontColor || h.color, fontStyle: "outside" === h.labelPlacement ? h.options.labelFontStyle ? h.labelFontStyle : this.fontWeight : h.labelFontStyle, textBaseline: "middle" }), this._stripLineLabels.push({ position: h.value, textBlock: t, effectiveHeight: null, stripLine: h }) } }, W.prototype.createLabelsAndCalculateWidth = function () { var t = 0, e = 0; this._labels = [], this._stripLineLabels = []; var a = this.chart.isNavigator ? 0 : 5; if ("left" === this._position || "right" === this._position) { for (this.createLabels(), e = 0; e < this._labels.length; e++) { var i = this._labels[e].textBlock, n = i.measureText(), s = 0; t < (s = 0 === this.labelAngle ? n.width : n.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (n.height - i.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = s), this._labels[e].effectiveWidth = s } for (e = 0; e < this._stripLineLabels.length; e++)"outside" === this._stripLineLabels[e].stripLine.labelPlacement && this._stripLineLabels[e].stripLine.value >= this.viewportMinimum && this._stripLineLabels[e].stripLine.value <= this.viewportMaximum && (n = (i = this._stripLineLabels[e].textBlock).measureText(), t < (s = 0 === this.labelAngle ? n.width : n.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (n.height - i.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = s), this._stripLineLabels[e].effectiveWidth = s) } return e = this.title ? this._titleTextBlock.measureText().height + 2 : 0, "inside" === this.labelPlacement ? i = e + a : e + t + this.tickLength + a }, W.prototype.createLabelsAndCalculateHeight = function () { var t = 0; this._labels = [], this._stripLineLabels = []; var e, a = 0, i = this.chart.isNavigator ? 0 : 5; if (this.createLabels(), "bottom" === this._position || "top" === this._position) { for (a = 0; a < this._labels.length; a++) { var n = (e = this._labels[a].textBlock).measureText(), s = 0; t < (s = 0 === this.labelAngle ? n.height : n.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (n.height - e.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = s), this._labels[a].effectiveHeight = s } for (a = 0; a < this._stripLineLabels.length; a++)"outside" === this._stripLineLabels[a].stripLine.labelPlacement && this._stripLineLabels[a].stripLine.value >= this.viewportMinimum && this._stripLineLabels[a].stripLine.value <= this.viewportMaximum && (n = (e = this._stripLineLabels[a].textBlock).measureText(), t < (s = 0 === this.labelAngle ? n.height : n.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (n.height - e.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = s), this._stripLineLabels[a].effectiveHeight = s) } return e = this.title ? this._titleTextBlock.measureText().height + 2 : 0, "inside" === this.labelPlacement ? a = e + i : e + t + this.tickLength + i }, W.setLayout = function (t, e, a, i, n, s) { var o, r, l, h, c = t[0] ? t[0].chart : e[0].chart, d = c.isNavigator ? 0 : 10, u = c._axes; if (t && 0 < t.length) for (var m = 0; m < t.length; m++)t[m] && t[m].calculateAxisParameters(); if (e && 0 < e.length) for (m = 0; m < e.length; m++)e[m].calculateAxisParameters(); if (a && 0 < a.length) for (m = 0; m < a.length; m++)a[m].calculateAxisParameters(); if (i && 0 < i.length) for (m = 0; m < i.length; m++)i[m].calculateAxisParameters(); for (m = 0; m < u.length; m++)if (u[m] && u[m].scaleBreaks && u[m].scaleBreaks._appliedBreaks.length) for (var x = u[m].scaleBreaks._appliedBreaks, g = 0; g < x.length && !(x[g].startValue > u[m].viewportMaximum); g++)x[g].endValue < u[m].viewportMinimum || (p(u[m].scaleBreaks.firstBreakIndex) && (u[m].scaleBreaks.firstBreakIndex = g), x[g].startValue >= u[m].viewPortMinimum && (u[m].scaleBreaks.lastBreakIndex = g)); var b, y, f, v, k, M = g = 0, T = 0, w = 0, P = 0, C = 0, S = 0, A = r = 0; for (x = f = v = k = !1, m = 0; m < u.length; m++)u[m] && u[m].title && (u[m]._titleTextBlock = new E(u[m].ctx, { text: u[m].title, horizontalAlign: "center", fontSize: u[m].titleFontSize, fontFamily: u[m].titleFontFamily, fontWeight: u[m].titleFontWeight, fontColor: u[m].titleFontColor, fontStyle: u[m].titleFontStyle, borderColor: u[m].titleBorderColor, borderThickness: u[m].titleBorderThickness, backgroundColor: u[m].titleBackgroundColor, cornerRadius: u[m].titleCornerRadius, textBaseline: "top" })); for (m = 0; m < u.length; m++)if (u[m].title) switch (u[m]._position) { case "left": u[m]._titleTextBlock.maxWidth = u[m].titleMaxWidth || s.height, u[m]._titleTextBlock.maxHeight = u[m].titleWrap ? .8 * s.width : 1.5 * u[m].titleFontSize, u[m]._titleTextBlock.angle = -90; break; case "right": u[m]._titleTextBlock.maxWidth = u[m].titleMaxWidth || s.height, u[m]._titleTextBlock.maxHeight = u[m].titleWrap ? .8 * s.width : 1.5 * u[m].titleFontSize, u[m]._titleTextBlock.angle = 90; break; default: u[m]._titleTextBlock.maxWidth = u[m].titleMaxWidth || s.width, u[m]._titleTextBlock.maxHeight = u[m].titleWrap ? .8 * s.height : 1.5 * u[m].titleFontSize, u[m]._titleTextBlock.angle = 0 }if ("normal" === n) { w = [], P = [], C = [], S = []; for (var _ = [], F = [], B = [], L = []; 4 > g;) { var I = 0, D = 0, N = 0, V = 0, W = n = 0, z = 0, O = 0, X = 0, Y = 0, R = 0, j = 0; if (a && 0 < a.length) for (C = [], m = R = 0; m < a.length; m++)C.push(Math.ceil(a[m] ? a[m].createLabelsAndCalculateWidth() : 0)), R += C[m], z += a[m] && !c.isNavigator ? a[m].margin : 0; else C.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0)); if (B.push(C), i && 0 < i.length) for (S = [], m = j = 0; m < i.length; m++)S.push(Math.ceil(i[m] ? i[m].createLabelsAndCalculateWidth() : 0)), j += S[m], O += i[m] ? i[m].margin : 0; else S.push(Math.ceil(i[0] ? i[0].createLabelsAndCalculateWidth() : 0)); if (L.push(S), o = Math.round(s.x1 + R + z), l = Math.round(s.x2 - j - O > c.width - d ? c.width - d : s.x2 - j - O), t && 0 < t.length) for (w = [], m = X = 0; m < t.length; m++)t[m] && (t[m].lineCoordinates = {}), t[m].lineCoordinates.width = Math.abs(l - o), t[m].title && (t[m]._titleTextBlock.maxWidth = 0 < t[m].titleMaxWidth && t[m].titleMaxWidth < t[m].lineCoordinates.width ? t[m].titleMaxWidth : t[m].lineCoordinates.width), w.push(Math.ceil(t[m] ? t[m].createLabelsAndCalculateHeight() : 0)), X += w[m], n += t[m] && !c.isNavigator ? t[m].margin : 0; else w.push(Math.ceil(t[0] ? t[0].createLabelsAndCalculateHeight() : 0)); if (_.push(w), e && 0 < e.length) for (P = [], m = Y = 0; m < e.length; m++)e[m] && (e[m].lineCoordinates = {}), e[m].lineCoordinates.width = Math.abs(l - o), e[m].title && (e[m]._titleTextBlock.maxWidth = 0 < e[m].titleMaxWidth && e[m].titleMaxWidth < e[m].lineCoordinates.width ? e[m].titleMaxWidth : e[m].lineCoordinates.width), P.push(Math.ceil(e[m] ? e[m].createLabelsAndCalculateHeight() : 0)), Y += P[m], W += e[m] && !c.isNavigator ? e[m].margin : 0; else P.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateHeight() : 0)); if (F.push(P), t && 0 < t.length) for (m = 0; m < t.length; m++)t[m] && (t[m].lineCoordinates.x1 = o, l = Math.round(s.x2 - j - O > c.width - d ? c.width - d : s.x2 - j - O), t[m]._labels && 1 < t[m]._labels.length && (r = h = 0, h = t[m]._labels[1], r = "dateTime" === t[m].valueType ? t[m]._labels[t[m]._labels.length - 2] : t[m]._labels[t[m]._labels.length - 1], M = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), T = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle))), !t[m] || !t[m].labelAutoFit || p(b) || p(y) || c.isNavigator || (r = 0, 0 < t[m].labelAngle ? y + T > l && (r += 0 < t[m].labelAngle ? y + T - l - j : 0) : 0 > t[m].labelAngle ? b - M < o && b - M < t[m].viewportMinimum && (A = o - (z + t[m].tickLength + C + b - M + t[m].labelFontSize / 2)) : 0 === t[m].labelAngle && (y + T > l && (r = y + T / 2 - l - j), b - M < o && b - M < t[m].viewportMinimum && (A = o - z - t[m].tickLength - C - b + M / 2)), t[m].viewportMaximum === t[m].maximum && t[m].viewportMinimum === t[m].minimum && 0 < t[m].labelAngle && 0 < r ? l -= r : t[m].viewportMaximum === t[m].maximum && t[m].viewportMinimum === t[m].minimum && 0 > t[m].labelAngle && 0 < A ? o += A : t[m].viewportMaximum === t[m].maximum && t[m].viewportMinimum === t[m].minimum && 0 === t[m].labelAngle && (0 < A && (o += A), 0 < r && (l -= r))), c.panEnabled ? X = c.sessionVariables.axisX.height : c.sessionVariables.axisX.height = X, r = Math.round(s.y2 - X - n + I), h = Math.round(s.y2), t[m].lineCoordinates.x2 = l, t[m].lineCoordinates.width = l - o, t[m].lineCoordinates.y1 = r, t[m].lineCoordinates.y2 = r, t[m].bounds = { x1: o, y1: r, x2: l, y2: h - (X + n - w[m] - I), width: l - o, height: h - r }), I += w[m] + t[m].margin; if (e && 0 < e.length) for (m = 0; m < e.length; m++)e[m].lineCoordinates.x1 = Math.round(s.x1 + R + z), e[m].lineCoordinates.x2 = Math.round(s.x2 - j - O > c.width - d ? c.width - d : s.x2 - j - O), e[m].lineCoordinates.width = Math.abs(l - o), e[m]._labels && 1 < e[m]._labels.length && (h = e[m]._labels[1], r = "dateTime" === e[m].valueType ? e[m]._labels[e[m]._labels.length - 2] : e[m]._labels[e[m]._labels.length - 1], M = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), T = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle))), c.panEnabled ? Y = c.sessionVariables.axisX2.height : c.sessionVariables.axisX2.height = Y, r = Math.round(s.y1), h = Math.round(s.y2 + e[m].margin), e[m].lineCoordinates.y1 = r + Y + W - D, e[m].lineCoordinates.y2 = r, e[m].bounds = { x1: o, y1: r + (Y + W - P[m] - D), x2: l, y2: h, width: l - o, height: h - r }, D += P[m] + e[m].margin; if (a && 0 < a.length) for (m = 0; m < a.length; m++)z = c.isNavigator ? 0 : 10, a[m] && (o = Math.round(t[0] ? t[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), z = a[m]._labels && 0 < a[m]._labels.length ? a[m]._labels[a[m]._labels.length - 1].textBlock.height / 2 : d, r = Math.round(s.y1 + Y + W < Math.max(z, d) ? Math.max(z, d) : s.y1 + Y + W), l = Math.round(t[0] ? t[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), z = 0 < t.length ? 0 : a[m]._labels && 0 < a[m]._labels.length ? a[m]._labels[0].textBlock.height / 2 : d, h = Math.round(s.y2 - X - n - z), a[m].lineCoordinates = { x1: l - N, y1: r, x2: l - N, y2: h, height: Math.abs(h - r) }, a[m].bounds = { x1: o - (C[m] + N), y1: r, x2: l, y2: h, width: l - o, height: h - r }, a[m].title && (a[m]._titleTextBlock.maxWidth = 0 < a[m].titleMaxWidth && a[m].titleMaxWidth < a[m].lineCoordinates.height ? a[m].titleMaxWidth : a[m].lineCoordinates.height), N += C[m] + a[m].margin); if (i && 0 < i.length) for (m = 0; m < i.length; m++)i[m] && (o = Math.round(t[0] ? t[0].lineCoordinates.x2 : e[0].lineCoordinates.x2), l = Math.round(o), z = i[m]._labels && 0 < i[m]._labels.length ? i[m]._labels[i[m]._labels.length - 1].textBlock.height / 2 : 0, r = Math.round(s.y1 + Y + W < Math.max(z, d) ? Math.max(z, d) : s.y1 + Y + W), z = 0 < t.length ? 0 : i[m]._labels && 0 < i[m]._labels.length ? i[m]._labels[0].textBlock.height / 2 : 0, h = Math.round(s.y2 - (X + n + z)), i[m].lineCoordinates = { x1: o + V, y1: r, x2: o + V, y2: h, height: Math.abs(h - r) }, i[m].bounds = { x1: o, y1: r, x2: l + (S[m] + V), y2: h, width: l - o, height: h - r }, i[m].title && (i[m]._titleTextBlock.maxWidth = 0 < i[m].titleMaxWidth && i[m].titleMaxWidth < i[m].lineCoordinates.height ? i[m].titleMaxWidth : i[m].lineCoordinates.height), V += S[m] + i[m].margin); if (t && 0 < t.length) for (m = 0; m < t.length; m++)t[m] && (t[m].calculateValueToPixelConversionParameters(), t[m].calculateBreaksSizeInValues(), t[m]._labels && 1 < t[m]._labels.length && (b = (t[m].logarithmic ? Math.log(t[m]._labels[1].position / t[m].viewportMinimum) / t[m].conversionParameters.lnLogarithmBase : t[m]._labels[1].position - t[m].viewportMinimum) * Math.abs(t[m].conversionParameters.pixelPerUnit) + t[m].lineCoordinates.x1, o = t[m]._labels[t[m]._labels.length - ("dateTime" === t[m].valueType ? 2 : 1)].position, o = t[m].getApparentDifference(t[m].viewportMinimum, o), y = t[m].logarithmic ? (1 < o ? Math.log(o) / t[m].conversionParameters.lnLogarithmBase * Math.abs(t[m].conversionParameters.pixelPerUnit) : 0) + t[m].lineCoordinates.x1 : (0 < o ? o * Math.abs(t[m].conversionParameters.pixelPerUnit) : 0) + t[m].lineCoordinates.x1)); if (e && 0 < e.length) for (m = 0; m < e.length; m++)e[m].calculateValueToPixelConversionParameters(), e[m].calculateBreaksSizeInValues(), e[m]._labels && 1 < e[m]._labels.length && (b = (e[m].logarithmic ? Math.log(e[m]._labels[1].position / e[m].viewportMinimum) / e[m].conversionParameters.lnLogarithmBase : e[m]._labels[1].position - e[m].viewportMinimum) * Math.abs(e[m].conversionParameters.pixelPerUnit) + e[m].lineCoordinates.x1, o = e[m]._labels[e[m]._labels.length - ("dateTime" === e[m].valueType ? 2 : 1)].position, o = e[m].getApparentDifference(e[m].viewportMinimum, o), y = e[m].logarithmic ? (1 < o ? Math.log(o) / e[m].conversionParameters.lnLogarithmBase * Math.abs(e[m].conversionParameters.pixelPerUnit) : 0) + e[m].lineCoordinates.x1 : (0 < o ? o * Math.abs(e[m].conversionParameters.pixelPerUnit) : 0) + e[m].lineCoordinates.x1); for (m = 0; m < u.length; m++)"axisY" === u[m].type && (u[m].calculateValueToPixelConversionParameters(), u[m].calculateBreaksSizeInValues()); if (0 < g) { if (t && 0 < t.length) for (m = 0; m < t.length; m++)x = _[g - 1][m] === _[g][m]; else x = !0; if (e && 0 < e.length) for (m = 0; m < e.length; m++)f = F[g - 1][m] === F[g][m]; else f = !0; if (a && 0 < a.length) for (m = 0; m < a.length; m++)v = B[g - 1][m] === B[g][m]; else v = !0; if (i && 0 < i.length) for (m = 0; m < i.length; m++)k = L[g - 1][m] === L[g][m]; else k = !0 } if (x && f && v && k) break; g++ } if (t && 0 < t.length) for (m = 0; m < t.length; m++)t[m].calculateStripLinesThicknessInValues(), t[m].calculateBreaksInPixels(); if (e && 0 < e.length) for (m = 0; m < e.length; m++)e[m].calculateStripLinesThicknessInValues(), e[m].calculateBreaksInPixels(); if (a && 0 < a.length) for (m = 0; m < a.length; m++)a[m].calculateStripLinesThicknessInValues(), a[m].calculateBreaksInPixels(); if (i && 0 < i.length) for (m = 0; m < i.length; m++)i[m].calculateStripLinesThicknessInValues(), i[m].calculateBreaksInPixels() } else { for (d = [], b = [], A = [], M = [], y = [], T = [], _ = [], F = []; 4 > g;) { if (X = V = D = N = O = z = W = n = L = B = I = Y = 0, t && 0 < t.length) for (A = [], m = V = 0; m < t.length; m++)A.push(Math.ceil(t[m] ? t[m].createLabelsAndCalculateWidth() : 0)), V += A[m], n += t[m] && !c.isNavigator ? t[m].margin : 0; else A.push(Math.ceil(t[0] ? t[0].createLabelsAndCalculateWidth() : 0)); if (_.push(A), e && 0 < e.length) for (M = [], m = X = 0; m < e.length; m++)M.push(Math.ceil(e[m] ? e[m].createLabelsAndCalculateWidth() : 0)), X += M[m], W += e[m] ? e[m].margin : 0; else M.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateWidth() : 0)); if (F.push(M), a && 0 < a.length) for (m = 0; m < a.length; m++)a[m].lineCoordinates = {}, o = Math.round(s.x1 + V + n), l = Math.round(s.x2 - X - W > c.width - 10 ? c.width - 10 : s.x2 - X - W), a[m].labelAutoFit && !p(w) && (0 < !t.length && (o = 0 > a[m].labelAngle ? Math.max(o, w) : 0 === a[m].labelAngle ? Math.max(o, w / 2) : o), 0 < !e.length && (l = 0 < a[m].labelAngle || 0 === a[m].labelAngle ? l - P / 2 : l)), a[m].lineCoordinates.x1 = o, a[m].lineCoordinates.x2 = l, a[m].lineCoordinates.width = Math.abs(l - o), a[m].title && (a[m]._titleTextBlock.maxWidth = 0 < a[m].titleMaxWidth && a[m].titleMaxWidth < a[m].lineCoordinates.width ? a[m].titleMaxWidth : a[m].lineCoordinates.width); if (i && 0 < i.length) for (m = 0; m < i.length; m++)i[m].lineCoordinates = {}, o = Math.round(s.x1 + V + n), l = Math.round(s.x2 - X - W > i[m].chart.width - 10 ? i[m].chart.width - 10 : s.x2 - X - W), i[m] && i[m].labelAutoFit && !p(C) && (0 < !t.length && (o = 0 < i[m].labelAngle ? Math.max(o, C) : 0 === i[m].labelAngle ? Math.max(o, C / 2) : o), 0 < !e.length && (l -= S / 2)), i[m].lineCoordinates.x1 = o, i[m].lineCoordinates.x2 = l, i[m].lineCoordinates.width = Math.abs(l - o), i[m].title && (i[m]._titleTextBlock.maxWidth = 0 < i[m].titleMaxWidth && i[m].titleMaxWidth < i[m].lineCoordinates.width ? i[m].titleMaxWidth : i[m].lineCoordinates.width); if (a && 0 < a.length) for (d = [], m = N = 0; m < a.length; m++)d.push(Math.ceil(a[m] ? a[m].createLabelsAndCalculateHeight() : 0)), N += d[m] + a[m].margin, z += a[m].margin; else d.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0)); if (y.push(d), i && 0 < i.length) for (b = [], m = D = 0; m < i.length; m++)b.push(Math.ceil(i[m] ? i[m].createLabelsAndCalculateHeight() : 0)), D += b[m], O += i[m].margin; else b.push(Math.ceil(i[0] ? i[0].createLabelsAndCalculateHeight() : 0)); if (T.push(b), a && 0 < a.length) for (m = 0; m < a.length; m++)0 < a[m]._labels.length && (h = a[m]._labels[0], r = a[m]._labels[a[m]._labels.length - 1], w = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), P = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle))); if (i && 0 < i.length) for (m = 0; m < i.length; m++)i[m] && 0 < i[m]._labels.length && (h = i[m]._labels[0], r = i[m]._labels[i[m]._labels.length - 1], C = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), S = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle))); if (c.panEnabled) for (m = 0; m < a.length; m++)d[m] = c.sessionVariables.axisY.height; else for (m = 0; m < a.length; m++)c.sessionVariables.axisY.height = d[m]; if (a && 0 < a.length) for (m = a.length - 1; 0 <= m; m--)r = Math.round(s.y2), h = Math.round(s.y2 > a[m].chart.height - 10 ? a[m].chart.height - 10 : s.y2), a[m].lineCoordinates.y1 = r - (d[m] + a[m].margin + Y), a[m].lineCoordinates.y2 = r - (d[m] + a[m].margin + Y), a[m].bounds = { x1: o, y1: r - (d[m] + Y + a[m].margin), x2: l, y2: h - (Y + a[m].margin), width: l - o, height: d[m] }, a[m].title && (a[m]._titleTextBlock.maxWidth = 0 < a[m].titleMaxWidth && a[m].titleMaxWidth < a[m].lineCoordinates.width ? a[m].titleMaxWidth : a[m].lineCoordinates.width), Y += d[m] + a[m].margin; if (i && 0 < i.length) for (m = i.length - 1; 0 <= m; m--)i[m] && (r = Math.round(s.y1), h = Math.round(s.y1 + (b[m] + i[m].margin + I)), i[m].lineCoordinates.y1 = h, i[m].lineCoordinates.y2 = h, i[m].bounds = { x1: o, y1: r + (i[m].margin + I), x2: l, y2: h, width: l - o, height: D }, i[m].title && (i[m]._titleTextBlock.maxWidth = 0 < i[m].titleMaxWidth && i[m].titleMaxWidth < i[m].lineCoordinates.width ? i[m].titleMaxWidth : i[m].lineCoordinates.width), I += b[m] + i[m].margin); if (t && 0 < t.length) for (m = 0; m < t.length; m++) { if (z = t[m]._labels && 0 < t[m]._labels.length ? t[m]._labels[0].textBlock.fontSize / 2 : 0, o = Math.round(s.x1 + n), r = i && 0 < i.length ? Math.round(i[0] ? i[0].lineCoordinates.y2 : s.y1 < Math.max(z, 10) ? Math.max(z, 10) : s.y1) : s.y1 < Math.max(z, 10) ? Math.max(z, 10) : s.y1, l = Math.round(s.x1 + V + n), h = a && 0 < a.length ? Math.round(a[0] ? a[0].lineCoordinates.y1 : s.y2 - N > c.height - Math.max(z, 10) ? c.height - Math.max(z, 10) : s.y2 - N) : s.y2 > c.height - Math.max(z, 10) ? c.height - Math.max(z, 10) : s.y2, a && 0 < a.length) for (z = 0; z < a.length; z++)a[z] && a[z].labelAutoFit && (l = 0 > a[z].labelAngle ? Math.max(l, w) : 0 === a[z].labelAngle ? Math.max(l, w / 2) : l, o = 0 > a[z].labelAngle || 0 === a[z].labelAngle ? l - V : o); if (i && 0 < i.length) for (z = 0; z < i.length; z++)i[z] && i[z].labelAutoFit && (o = (l = i[z].lineCoordinates.x1) - V); t[m].lineCoordinates = { x1: l - B, y1: r, x2: l - B, y2: h, height: Math.abs(h - r) }, t[m].bounds = { x1: l - (A[m] + B), y1: r, x2: l, y2: h, width: l - o, height: h - r }, t[m].title && (t[m]._titleTextBlock.maxWidth = 0 < t[m].titleMaxWidth && t[m].titleMaxWidth < t[m].lineCoordinates.height ? t[m].titleMaxWidth : t[m].lineCoordinates.height), t[m].calculateValueToPixelConversionParameters(), t[m].calculateBreaksSizeInValues(), B += A[m] + t[m].margin } if (e && 0 < e.length) for (m = 0; m < e.length; m++) { if (z = e[m]._labels && 0 < e[m]._labels.length ? e[m]._labels[0].textBlock.fontSize / 2 : 0, o = Math.round(s.x1 - n), r = i && 0 < i.length ? Math.round(i[0] ? i[0].lineCoordinates.y2 : s.y1 < Math.max(z, 10) ? Math.max(z, 10) : s.y1) : s.y1 < Math.max(z, 10) ? Math.max(z, 10) : s.y1, l = Math.round(s.x2 - X - W), h = a && 0 < a.length ? Math.round(a[0] ? a[0].lineCoordinates.y1 : s.y2 - N > c.height - Math.max(z, 10) ? c.height - Math.max(z, 10) : s.y2 - N) : s.y2 > c.height - Math.max(z, 10) ? c.height - Math.max(z, 10) : s.y2, a && 0 < a.length) for (z = 0; z < a.length; z++)a[z] && a[z].labelAutoFit && (l = 0 > a[z].labelAngle ? Math.max(l, w) : 0 === a[z].labelAngle ? Math.max(l, w / 2) : l, o = 0 > a[z].labelAngle || 0 === a[z].labelAngle ? l - X : o); if (i && 0 < i.length) for (z = 0; z < i.length; z++)i[z] && i[z].labelAutoFit && (o = (l = i[z].lineCoordinates.x2) - X); e[m].lineCoordinates = { x1: l + L, y1: r, x2: l + L, y2: h, height: Math.abs(h - r) }, e[m].bounds = { x1: o, y1: r, x2: l + M[m] + L, y2: h, width: l - o, height: h - r }, e[m].title && (e[m]._titleTextBlock.maxWidth = 0 < e[m].titleMaxWidth && e[m].titleMaxWidth < e[m].lineCoordinates.height ? e[m].titleMaxWidth : e[m].lineCoordinates.height), e[m].calculateValueToPixelConversionParameters(), e[m].calculateBreaksSizeInValues(), L += M[m] + e[m].margin } for (m = 0; m < u.length; m++)"axisY" === u[m].type && (u[m].calculateValueToPixelConversionParameters(), u[m].calculateBreaksSizeInValues()); if (0 < g) { if (t && 0 < t.length) for (m = 0; m < t.length; m++)x = _[g - 1][m] === _[g][m]; else x = !0; if (e && 0 < e.length) for (m = 0; m < e.length; m++)f = F[g - 1][m] === F[g][m]; else f = !0; if (a && 0 < a.length) for (m = 0; m < a.length; m++)v = y[g - 1][m] === y[g][m]; else v = !0; if (i && 0 < i.length) for (m = 0; m < i.length; m++)k = T[g - 1][m] === T[g][m]; else k = !0 } if (x && f && v && k) break; g++ } if (a && 0 < a.length) for (m = 0; m < a.length; m++)a[m].calculateStripLinesThicknessInValues(), a[m].calculateBreaksInPixels(); if (i && 0 < i.length) for (m = 0; m < i.length; m++)i[m].calculateStripLinesThicknessInValues(), i[m].calculateBreaksInPixels(); if (t && 0 < t.length) for (m = 0; m < t.length; m++)t[m].calculateStripLinesThicknessInValues(), t[m].calculateBreaksInPixels(); if (e && 0 < e.length) for (m = 0; m < e.length; m++)e[m].calculateStripLinesThicknessInValues(), e[m].calculateBreaksInPixels() } }, W.render = function (t, e, a, i, n) { var s = t[0] ? t[0].chart : e[0].chart; n = s.ctx; var o = s._axes; if (s.alignVerticalAxes && s.alignVerticalAxes(), n.save(), n.beginPath(), t[0] && n.rect(5, t[0].bounds.y1, t[0].chart.width - 10, t[0].bounds.height), e[0] && n.rect(5, e[e.length - 1].bounds.y1, e[0].chart.width - 10, e[0].bounds.height), n.clip(), t && 0 < t.length) for (var r = 0; r < t.length; r++)t[r].renderLabelsTicksAndTitle(); if (e && 0 < e.length) for (r = 0; r < e.length; r++)e[r].renderLabelsTicksAndTitle(); if (n.restore(), a && 0 < a.length) for (r = 0; r < a.length; r++)a[r].renderLabelsTicksAndTitle(); if (i && 0 < i.length) for (r = 0; r < i.length; r++)i[r].renderLabelsTicksAndTitle(); if (s.preparePlotArea(), s = s.plotArea, n.save(), n.beginPath(), n.rect(s.x1, s.y1, Math.abs(s.x2 - s.x1), Math.abs(s.y2 - s.y1)), n.clip(), t && 0 < t.length) for (r = 0; r < o.length; r++)o[r].renderStripLinesOfThicknessType("value"); if (e && 0 < e.length) for (r = 0; r < e.length; r++)e[r].renderStripLinesOfThicknessType("value"); if (a && 0 < a.length) for (r = 0; r < a.length; r++)a[r].renderStripLinesOfThicknessType("value"); if (i && 0 < i.length) for (r = 0; r < i.length; r++)i[r].renderStripLinesOfThicknessType("value"); if (t && 0 < t.length) for (r = 0; r < t.length; r++)t[r].renderInterlacedColors(); if (e && 0 < e.length) for (r = 0; r < e.length; r++)e[r].renderInterlacedColors(); if (a && 0 < a.length) for (r = 0; r < a.length; r++)a[r].renderInterlacedColors(); if (i && 0 < i.length) for (r = 0; r < i.length; r++)i[r].renderInterlacedColors(); if (n.restore(), t && 0 < t.length) for (r = 0; r < t.length; r++)t[r].renderGrid(), Y && (t[r].createMask(), t[r].renderBreaksBackground()); if (e && 0 < e.length) for (r = 0; r < e.length; r++)e[r].renderGrid(), Y && (e[r].createMask(), e[r].renderBreaksBackground()); if (a && 0 < a.length) for (r = 0; r < a.length; r++)a[r].renderGrid(), Y && (a[r].createMask(), a[r].renderBreaksBackground()); if (i && 0 < i.length) for (r = 0; r < i.length; r++)i[r].renderGrid(), Y && (i[r].createMask(), i[r].renderBreaksBackground()); if (t && 0 < t.length) for (r = 0; r < t.length; r++)t[r].renderAxisLine(); if (e && 0 < e.length) for (r = 0; r < e.length; r++)e[r].renderAxisLine(); if (a && 0 < a.length) for (r = 0; r < a.length; r++)a[r].renderAxisLine(); if (i && 0 < i.length) for (r = 0; r < i.length; r++)i[r].renderAxisLine(); if (t && 0 < t.length) for (r = 0; r < t.length; r++)t[r].renderStripLinesOfThicknessType("pixel"); if (e && 0 < e.length) for (r = 0; r < e.length; r++)e[r].renderStripLinesOfThicknessType("pixel"); if (a && 0 < a.length) for (r = 0; r < a.length; r++)a[r].renderStripLinesOfThicknessType("pixel"); if (i && 0 < i.length) for (r = 0; r < i.length; r++)i[r].renderStripLinesOfThicknessType("pixel") }, W.prototype.calculateStripLinesThicknessInValues = function () { for (var t = 0; t < this.stripLines.length; t++)if (null !== this.stripLines[t].startValue && null !== this.stripLines[t].endValue) { var e = Math.min(this.stripLines[t].startValue, this.stripLines[t].endValue), a = Math.max(this.stripLines[t].startValue, this.stripLines[t].endValue); e = this.getApparentDifference(e, a); this.stripLines[t].value = this.logarithmic ? this.stripLines[t].value * Math.sqrt(Math.log(this.stripLines[t].endValue / this.stripLines[t].startValue) / Math.log(e)) : this.stripLines[t].value + (Math.abs(this.stripLines[t].endValue - this.stripLines[t].startValue) - e) / 2, this.stripLines[t].thickness = e, this.stripLines[t]._thicknessType = "value" } }, W.prototype.calculateBreaksSizeInValues = function () { for (var t, e = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], i = this.conversionParameters.pixelPerUnit || e / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), n = this.scaleBreaks && !p(this.scaleBreaks.options.spacing), s = 0; s < a.length; s++)t = n || !p(a[s].options.spacing), a[s].spacing = D(a[s].spacing, e, 8, t ? .1 * e : 8, t ? 0 : 3) << 0, a[s].size = 0 > a[s].spacing ? 0 : Math.abs(a[s].spacing / i), this.logarithmic && (a[s].size = Math.pow(this.logarithmBase, a[s].size)) }, W.prototype.calculateBreaksInPixels = function () { if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) { var t = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []; t.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null); for (var e = 0; e < t.length && !(t[e].startValue > this.conversionParameters.maximum); e++)t[e].endValue < this.conversionParameters.minimum || (p(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = e), t[e].startValue >= this.conversionParameters.minimum && (t[e].startPixel = this.convertValueToPixel(t[e].startValue), this.scaleBreaks.lastBreakIndex = e), t[e].endValue <= this.conversionParameters.maximum && (t[e].endPixel = this.convertValueToPixel(t[e].endValue))) } }, W.prototype.renderLabelsTicksAndTitle = function () { var t = this, e = !1, a = 0, i = 0, n = 1, s = 0; if (0 !== this.labelAngle && 360 !== this.labelAngle && (n = 1.2), "undefined" === typeof this.options.interval) { if ("bottom" === this._position || "top" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) { a = [], n = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2; for (var o, r = this.viewportMaximum, l = this.lineCoordinates.width / Math.log(this.range), h = this._labels.length - 1; 0 <= h && !((d = this._labels[h]).position < this.viewportMinimum); h--)d.position > this.viewportMaximum || !(h === this._labels.length - 1 || o < Math.log(r / d.position) * l / n) || (a.push(d), r = d.position, o = d.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + d.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))); this._labels = a } else { for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || (a += o = d.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + d.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))); a > this.lineCoordinates.width * n && this.labelAutoFit && (e = !0) } if ("left" === this._position || "right" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) { var c; for (a = [], r = this.viewportMaximum, l = this.lineCoordinates.height / Math.log(this.range), h = this._labels.length - 1; 0 <= h && !((d = this._labels[h]).position < this.viewportMinimum); h--)d.position > this.viewportMaximum || !(h === this._labels.length - 1 || c < Math.log(r / d.position) * l) || (a.push(d), r = d.position, c = d.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + d.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))); this._labels = a } else { for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || (i += c = d.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + d.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))); i > this.lineCoordinates.height * n && this.labelAutoFit && (e = !0) } } this.logarithmic && !this.equidistantInterval && this.labelAutoFit && this._labels.sort((function (t, e) { return t.position - e.position })); var d, p; h = 0; if ("bottom" === this._position) { for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || d.position > this.viewportMaximum || e && 0 !== s++ % 2 && this.labelAutoFit || (p = this.getPixelCoordinatesOnAxis(d.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, i = 1 === this.ctx.lineWidth % 2 ? .5 + (p.x << 0) : p.x << 0, this.ctx.beginPath(), this.ctx.moveTo(i, p.y << 0), this.ctx.lineTo(i, p.y + this.tickLength << 0), this.ctx.stroke()), 0 === d.textBlock.angle ? (p.x -= d.textBlock.width / 2, p.y = "inside" === this.labelPlacement ? p.y - (this.tickLength + d.textBlock.fontSize / 2) : p.y + this.tickLength + d.textBlock.fontSize / 2) : (p.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? p.x : p.x - d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : p.x - (0 > this.labelAngle ? d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), p.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? p.y - this.tickLength - 5 : p.y - this.tickLength - Math.abs(d.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : p.y + this.tickLength + Math.abs(0 > this.labelAngle ? d.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), d.textBlock.x = p.x, d.textBlock.y = p.y); "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (h = 0; h < t._labels.length; h++)if (!((d = t._labels[h]).position < t.viewportMinimum || d.position > t.viewportMaximum || e && 0 !== s++ % 2 && t.labelAutoFit) && (p = t.getPixelCoordinatesOnAxis(d.position), t.tickThickness)) { t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor; var a = 1 === t.ctx.lineWidth % 2 ? .5 + (p.x << 0) : p.x << 0; t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(a, p.y << 0), t.ctx.lineTo(a, p.y - t.tickLength << 0), t.ctx.stroke(), t.ctx.restore() } }), this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0)) } else if ("top" === this._position) { for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || d.position > this.viewportMaximum || e && 0 !== s++ % 2 && this.labelAutoFit || (p = this.getPixelCoordinatesOnAxis(d.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, i = 1 === this.ctx.lineWidth % 2 ? .5 + (p.x << 0) : p.x << 0, this.ctx.beginPath(), this.ctx.moveTo(i, p.y << 0), this.ctx.lineTo(i, p.y - this.tickLength << 0), this.ctx.stroke()), 0 === d.textBlock.angle ? (p.x -= d.textBlock.width / 2, p.y = "inside" === this.labelPlacement ? p.y + this.labelFontSize / 2 + this.tickLength + 5 : p.y - (this.tickLength + d.textBlock.height - d.textBlock.fontSize / 2)) : (p.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? p.x : p.x - d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : p.x + (d.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), p.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? p.y + this.tickLength + 5 : p.y - d.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength + 5 : p.y - (this.tickLength + ((d.textBlock.height - d.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? d.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), d.textBlock.x = p.x, d.textBlock.y = p.y); "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (h = 0; h < t._labels.length; h++)if (!((d = t._labels[h]).position < t.viewportMinimum || d.position > t.viewportMaximum || e && 0 !== s++ % 2 && t.labelAutoFit) && (p = t.getPixelCoordinatesOnAxis(d.position), t.tickThickness)) { t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor; var a = 1 === this.ctx.lineWidth % 2 ? .5 + (p.x << 0) : p.x << 0; t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(a, p.y << 0), t.ctx.lineTo(a, p.y + t.tickLength << 0), t.ctx.stroke(), t.ctx.restore() } }), this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0)) } else if ("left" === this._position) { for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || d.position > this.viewportMaximum || e && 0 !== s++ % 2 && this.labelAutoFit || (p = this.getPixelCoordinatesOnAxis(d.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, i = 1 === this.ctx.lineWidth % 2 ? .5 + (p.y << 0) : p.y << 0, this.ctx.beginPath(), this.ctx.moveTo(p.x << 0, i), this.ctx.lineTo(p.x - this.tickLength << 0, i), this.ctx.stroke()), 0 === this.labelAngle ? (d.textBlock.y = p.y, d.textBlock.x = "inside" === this.labelPlacement ? p.x + this.tickLength + 5 : p.x - d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (d.textBlock.y = "inside" === this.labelPlacement ? p.y : p.y - d.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), d.textBlock.x = "inside" === this.labelPlacement ? p.x + this.tickLength + 5 : 0 < this.labelAngle ? p.x - d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : p.x - d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (d.textBlock.height - d.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)); "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (h = 0; h < t._labels.length; h++)if (!((d = t._labels[h]).position < t.viewportMinimum || d.position > t.viewportMaximum || e && 0 !== s++ % 2 && t.labelAutoFit) && (p = t.getPixelCoordinatesOnAxis(d.position), t.tickThickness)) { t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor; var a = 1 === t.ctx.lineWidth % 2 ? .5 + (p.y << 0) : p.y << 0; t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(p.x << 0, a), t.ctx.lineTo(p.x + t.tickLength << 0, a), t.ctx.stroke(), t.ctx.restore() } }), this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0)) } else if ("right" === this._position) { for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || d.position > this.viewportMaximum || e && 0 !== s++ % 2 && this.labelAutoFit || (p = this.getPixelCoordinatesOnAxis(d.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, i = 1 === this.ctx.lineWidth % 2 ? .5 + (p.y << 0) : p.y << 0, this.ctx.beginPath(), this.ctx.moveTo(p.x << 0, i), this.ctx.lineTo(p.x + this.tickLength << 0, i), this.ctx.stroke()), 0 === this.labelAngle ? (d.textBlock.y = p.y, d.textBlock.x = "inside" === this.labelPlacement ? p.x - d.textBlock.width - this.tickLength - 5 : p.x + this.tickLength + 5) : (d.textBlock.y = "inside" === this.labelPlacement ? p.y - d.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? p.y : p.y - (d.textBlock.height - d.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), d.textBlock.x = "inside" === this.labelPlacement ? p.x - d.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? p.x + (d.textBlock.height - d.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : p.x + this.tickLength + 5)); "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (h = 0; h < t._labels.length; h++)if (!((d = t._labels[h]).position < t.viewportMinimum || d.position > t.viewportMaximum || e && 0 !== s++ % 2 && t.labelAutoFit) && (p = t.getPixelCoordinatesOnAxis(d.position), t.tickThickness)) { t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor; var a = 1 === t.ctx.lineWidth % 2 ? .5 + (p.y << 0) : p.y << 0; t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(p.x << 0, a), t.ctx.lineTo(p.x - t.tickLength << 0, a), t.ctx.stroke(), t.ctx.restore() } }), this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0)) } if (s = 0, "inside" === this.labelPlacement) this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (h = 0; h < t._labels.length; h++)(d = t._labels[h]).position < t.viewportMinimum || d.position > t.viewportMaximum || e && 0 !== s++ % 2 && t.labelAutoFit || (t.ctx.save(), t.ctx.beginPath(), d.textBlock.render(!0), t.ctx.restore()) }), this); else for (h = 0; h < this._labels.length; h++)(d = this._labels[h]).position < this.viewportMinimum || d.position > this.viewportMaximum || e && 0 !== s++ % 2 && this.labelAutoFit || d.textBlock.render(!0) }, W.prototype.renderInterlacedColors = function () { var t, e, a = this.chart.plotArea.ctx, i = this.chart.plotArea, n = 0; if (t = !0, "bottom" !== this._position && "top" !== this._position || !this.interlacedColor) { if (("left" === this._position || "right" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, n = 0; n < this._labels.length; n++)t ? (e = this.getPixelCoordinatesOnAxis(this._labels[n].position), t = n + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[n + 1].position), a.fillRect(i.x1, Math.min(e.y, t.y), Math.abs(i.x1 - i.x2), Math.abs(t.y - e.y)), t = !1) : t = !0 } else for (a.fillStyle = this.interlacedColor, n = 0; n < this._labels.length; n++)t ? (t = this.getPixelCoordinatesOnAxis(this._labels[n].position), e = n + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[n + 1].position), a.fillRect(Math.min(e.x, t.x), i.y1, Math.abs(e.x - t.x), Math.abs(i.y1 - i.y2)), t = !1) : t = !0; a.beginPath() }, W.prototype.renderStripLinesOfThicknessType = function (t) { if (this.stripLines && 0 < this.stripLines.length && t) { var e, a = this, i = 0, n = 0, s = !1, o = !1, r = [], l = []; for (o = !1, i = 0; i < this.stripLines.length; i++) { var h = this.stripLines[i]; h._thicknessType === t && ("pixel" === t && (h.value < this.viewportMinimum || h.value > this.viewportMaximum || p(h.value) || isNaN(this.range)) || r.push(h)) } for (i = 0; i < this._stripLineLabels.length; i++)if (h = this.stripLines[i], !((e = this._stripLineLabels[i]).position < this.viewportMinimum || e.position > this.viewportMaximum || isNaN(this.range))) { if (t = this.getPixelCoordinatesOnAxis(e.position), "outside" === e.stripLine.labelPlacement) if (h && (this.ctx.strokeStyle = h.color, "pixel" === h._thicknessType && (this.ctx.lineWidth = h.thickness)), "bottom" === this._position) { var c = 1 === this.ctx.lineWidth % 2 ? .5 + (t.x << 0) : t.x << 0; this.ctx.beginPath(), this.ctx.moveTo(c, t.y << 0), this.ctx.lineTo(c, t.y + this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (t.x -= e.textBlock.width / 2, t.y += this.tickLength + e.textBlock.fontSize / 2) : (t.x -= 0 > this.labelAngle ? e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, t.y += this.tickLength + Math.abs(0 > this.labelAngle ? e.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)) } else "top" === this._position ? (c = 1 === this.ctx.lineWidth % 2 ? .5 + (t.x << 0) : t.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, t.y << 0), this.ctx.lineTo(c, t.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (t.x -= e.textBlock.width / 2, t.y -= this.tickLength + e.textBlock.height) : (t.x += (e.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), t.y -= this.tickLength + (e.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? e.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (c = 1 === this.ctx.lineWidth % 2 ? .5 + (t.y << 0) : t.y << 0, this.ctx.beginPath(), this.ctx.moveTo(t.x << 0, c), this.ctx.lineTo(t.x - this.tickLength << 0, c), this.ctx.stroke(), 0 === this.labelAngle ? t.x = t.x - e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (t.y -= e.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), t.x = 0 < this.labelAngle ? t.x - e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : t.x - e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (e.textBlock.height - e.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (c = 1 === this.ctx.lineWidth % 2 ? .5 + (t.y << 0) : t.y << 0, this.ctx.beginPath(), this.ctx.moveTo(t.x << 0, c), this.ctx.lineTo(t.x + this.tickLength << 0, c), this.ctx.stroke(), 0 === this.labelAngle ? t.x = t.x + this.tickLength + 5 : (t.y = 0 > this.labelAngle ? t.y : t.y - (e.textBlock.height - e.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), t.x = 0 < this.labelAngle ? t.x + (e.textBlock.height - e.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : t.x + this.tickLength + 5)); else e.textBlock.angle = -90, "bottom" === this._position ? (e.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.height - 3, e.textBlock.measureText(), t.x - e.textBlock.height > this.chart.plotArea.x1 ? p(h.startValue) ? t.x -= e.textBlock.height - e.textBlock.fontSize / 2 : t.x -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3 : (e.textBlock.angle = 90, p(h.startValue) ? t.x += e.textBlock.height - e.textBlock.fontSize / 2 : t.x += e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3), t.y = -90 === e.textBlock.angle ? "near" === e.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + e.textBlock.width) / 2 : this.chart.plotArea.y1 + e.textBlock.width + 3 : "near" === e.stripLine.labelAlign ? this.chart.plotArea.y2 - e.textBlock.width - 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - e.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (e.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.height - 3, e.textBlock.measureText(), t.x - e.textBlock.height > this.chart.plotArea.x1 ? p(h.startValue) ? t.x -= e.textBlock.height - e.textBlock.fontSize / 2 : t.x -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3 : (e.textBlock.angle = 90, p(h.startValue) ? t.x += e.textBlock.height - e.textBlock.fontSize / 2 : t.x += e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3), t.y = -90 === e.textBlock.angle ? "near" === e.stripLine.labelAlign ? this.chart.plotArea.y1 + e.textBlock.width + 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + e.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === e.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - e.textBlock.width) / 2 : this.chart.plotArea.y2 - e.textBlock.width - 3) : "left" === this._position ? (e.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.width - 3, e.textBlock.angle = 0, e.textBlock.measureText(), t.y - e.textBlock.height > this.chart.plotArea.y1 ? p(h.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize + 3 : t.y - e.textBlock.height < this.chart.plotArea.y2 ? t.y += e.textBlock.fontSize / 2 + 3 : p(h.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize + 3, t.x = "near" === e.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - e.textBlock.width / 2 : this.chart.plotArea.x2 - e.textBlock.width - 3) : "right" === this._position && (e.textBlock.maxWidth = this.options.stripLines[i].labelMaxWidth ? this.options.stripLines[i].labelMaxWidth : this.chart.plotArea.width - 3, e.textBlock.angle = 0, e.textBlock.measureText(), t.y - +e.textBlock.height > this.chart.plotArea.y1 ? p(h.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 - 3 : t.y - e.textBlock.height < this.chart.plotArea.y2 ? t.y += e.textBlock.fontSize / 2 + 3 : p(h.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3, t.x = "near" === e.stripLine.labelAlign ? this.chart.plotArea.x2 - e.textBlock.width - 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - e.textBlock.width / 2 : this.chart.plotArea.x1 + 3); e.textBlock.x = t.x, e.textBlock.y = t.y, l.push(e) } if (!o) { for (o = !1, this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), i = 0; i < r.length; i++)(h = r[i]).showOnTop ? s || (s = !0, this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), n = 0; n < r.length; n++)(h = r[n]).showOnTop && h.render(); this.ctx.restore() }), h)) : h.render(); for (i = 0; i < l.length; i++)(e = l[i]).stripLine.showOnTop ? o || (o = !0, this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (n = 0; n < l.length; n++)"inside" === (e = l[n]).stripLine.labelPlacement && e.stripLine.showOnTop && (a.ctx.save(), a.ctx.beginPath(), a.ctx.rect(a.chart.plotArea.x1, a.chart.plotArea.y1, a.chart.plotArea.width, a.chart.plotArea.height), a.ctx.clip(), e.textBlock.render(!0), a.ctx.restore()) }), e.textBlock)) : "inside" === e.stripLine.labelPlacement && e.textBlock.render(!0); this.ctx.restore(), o = !0 } if (o) for (o = !1, i = 0; i < l.length; i++)(e = l[i]).stripLine.showOnTop ? o || (o = !0, this.chart.addEventListener("dataAnimationIterationEnd", (function () { for (n = 0; n < l.length; n++)"outside" === (e = l[n]).stripLine.labelPlacement && e.stripLine.showOnTop && e.textBlock.render(!0) }), e.textBlock)) : "outside" === e.stripLine.labelPlacement && e.textBlock.render(!0) } }, W.prototype.renderBreaksBackground = function () { this.chart._breaksCanvas && this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore()) }, W.prototype.createMask = function () { if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) { var t = this.scaleBreaks._appliedBreaks; Y ? (this.maskCanvas = M(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx), this.maskCtx.save(), this.maskCtx.beginPath(), this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.maskCtx.clip(); for (var e = 0; e < t.length; e++)t[e].endValue < this.viewportMinimum || t[e].startValue > this.viewportMaximum || isNaN(this.range) || t[e].render(this.maskCtx); this.maskCtx.restore() } }, W.prototype.renderCrosshair = function (t, e) { this.crosshair.render(t, e) }, W.prototype.renderGrid = function () { if (this.gridThickness && 0 < this.gridThickness) { var t = this.chart.ctx; t.save(); var e, a = this.chart.plotArea; if (t.lineWidth = this.gridThickness, t.strokeStyle = this.gridColor, t.setLineDash && t.setLineDash(g(this.gridDashType, this.gridThickness)), "bottom" === this._position || "top" === this._position) for (i = 0; i < this._labels.length; i++)this._labels[i].position < this.viewportMinimum || this._labels[i].position > this.viewportMaximum || this._labels[i].breaksLabelType || (t.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[i].position), e = 1 === t.lineWidth % 2 ? .5 + (e.x << 0) : e.x << 0, t.moveTo(e, a.y1 << 0), t.lineTo(e, a.y2 << 0), t.stroke()); else if ("left" === this._position || "right" === this._position) for (var i = 0; i < this._labels.length; i++)this._labels[i].position < this.viewportMinimum || this._labels[i].position > this.viewportMaximum || this._labels[i].breaksLabelType || (t.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[i].position), e = 1 === t.lineWidth % 2 ? .5 + (e.y << 0) : e.y << 0, t.moveTo(a.x1 << 0, e), t.lineTo(a.x2 << 0, e), t.stroke()); t.restore() } }, W.prototype.renderAxisLine = function () { var t, e, a = this.chart.ctx, i = Y ? this.chart._preRenderCtx : a, n = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), s = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)); if (i.save(), "bottom" === this._position || "top" === this._position) { if (this.lineThickness) { this.reversed ? (t = this.lineCoordinates.x2, e = this.lineCoordinates.x1) : (t = this.lineCoordinates.x1, e = this.lineCoordinates.x2), i.lineWidth = this.lineThickness, i.strokeStyle = this.lineColor ? this.lineColor : "black", i.setLineDash && i.setLineDash(g(this.lineDashType, this.lineThickness)); var o = 1 === this.lineThickness % 2 ? .5 + (this.lineCoordinates.y1 << 0) : this.lineCoordinates.y1 << 0; if (i.beginPath(), this.scaleBreaks && !p(this.scaleBreaks.firstBreakIndex)) if (p(this.scaleBreaks.lastBreakIndex)) t = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + s; else for (var r = this.scaleBreaks.firstBreakIndex; r <= this.scaleBreaks.lastBreakIndex; r++)i.moveTo(t, o), i.lineTo(this.scaleBreaks._appliedBreaks[r].startPixel + n, o), t = this.scaleBreaks._appliedBreaks[r].endPixel + s; t && (i.moveTo(t, o), i.lineTo(e, o)), i.stroke() } } else if (("left" === this._position || "right" === this._position) && this.lineThickness) { if (this.reversed ? (t = this.lineCoordinates.y1, e = this.lineCoordinates.y2) : (t = this.lineCoordinates.y2, e = this.lineCoordinates.y1), i.lineWidth = this.lineThickness, i.strokeStyle = this.lineColor, i.setLineDash && i.setLineDash(g(this.lineDashType, this.lineThickness)), o = 1 === this.lineThickness % 2 ? .5 + (this.lineCoordinates.x1 << 0) : this.lineCoordinates.x1 << 0, i.beginPath(), this.scaleBreaks && !p(this.scaleBreaks.firstBreakIndex)) if (p(this.scaleBreaks.lastBreakIndex)) t = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + n; else for (r = this.scaleBreaks.firstBreakIndex; r <= this.scaleBreaks.lastBreakIndex; r++)i.moveTo(o, t), i.lineTo(o, this.scaleBreaks._appliedBreaks[r].startPixel + s), t = this.scaleBreaks._appliedBreaks[r].endPixel + n; t && (i.moveTo(o, t), i.lineTo(o, e)), i.stroke() } Y && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), i.clearRect(0, 0, this.chart.width, this.chart.height)), i.restore() }, W.prototype.getPixelCoordinatesOnAxis = function (t) { var e = {}; return "bottom" !== this._position && "top" !== this._position || (e.x = this.convertValueToPixel(t), e.y = this.lineCoordinates.y1), "left" !== this._position && "right" !== this._position || (e.y = this.convertValueToPixel(t), e.x = this.lineCoordinates.x2), e }, W.prototype.convertPixelToValue = function (t) { if ("undefined" === typeof t) return null; var e, a = 0, i = 0, n = (a = !0, this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []); i = "number" === typeof t ? t : "left" === this._position || "right" === this._position ? t.y : t.x; if (this.logarithmic) { if (t = e = Math.pow(this.logarithmBase, (i - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit), i <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) { for (i = 0; i < n.length; i++)if (!(n[i].endValue < this.conversionParameters.minimum)) if (a) if (n[i].startValue < this.conversionParameters.minimum) { if (1 < n[i].size && this.conversionParameters.minimum * Math.pow(n[i].endValue / n[i].startValue, Math.log(e) / Math.log(n[i].size)) < n[i].endValue) { t = Math.pow(n[i].endValue / n[i].startValue, Math.log(e) / Math.log(n[i].size)); break } t *= n[i].endValue / this.conversionParameters.minimum / Math.pow(n[i].size, Math.log(n[i].endValue / this.conversionParameters.minimum) / Math.log(n[i].endValue / n[i].startValue)), e /= Math.pow(n[i].size, Math.log(n[i].endValue / this.conversionParameters.minimum) / Math.log(n[i].endValue / n[i].startValue)), a = !1 } else { if (!(e > n[i].startValue / this.conversionParameters.minimum)) break; if ((e /= n[i].startValue / this.conversionParameters.minimum) < n[i].size) { t *= Math.pow(n[i].endValue / n[i].startValue, 1 === n[i].size ? 1 : Math.log(e) / Math.log(n[i].size)) / e; break } t *= n[i].endValue / n[i].startValue / n[i].size, e /= n[i].size, a = !1 } else { if (!(e > n[i].startValue / n[i - 1].endValue)) break; if ((e /= n[i].startValue / n[i - 1].endValue) < n[i].size) { t *= Math.pow(n[i].endValue / n[i].startValue, 1 === n[i].size ? 1 : Math.log(e) / Math.log(n[i].size)) / e; break } t *= n[i].endValue / n[i].startValue / n[i].size, e /= n[i].size } } else for (i = n.length - 1; 0 <= i; i--)if (!(n[i].startValue > this.conversionParameters.minimum)) if (a) if (n[i].endValue > this.conversionParameters.minimum) { if (1 < n[i].size && this.conversionParameters.minimum * Math.pow(n[i].endValue / n[i].startValue, Math.log(e) / Math.log(n[i].size)) > n[i].startValue) { t = Math.pow(n[i].endValue / n[i].startValue, Math.log(e) / Math.log(n[i].size)); break } t *= n[i].startValue / this.conversionParameters.minimum * Math.pow(n[i].size, Math.log(n[i].startValue / this.conversionParameters.minimum) / Math.log(n[i].endValue / n[i].startValue)) * e, e *= Math.pow(n[i].size, Math.log(this.conversionParameters.minimum / n[i].startValue) / Math.log(n[i].endValue / n[i].startValue)), a = !1 } else { if (!(e < n[i].endValue / this.conversionParameters.minimum)) break; if ((e /= n[i].endValue / this.conversionParameters.minimum) > 1 / n[i].size) { t *= Math.pow(n[i].endValue / n[i].startValue, 1 >= n[i].size ? 1 : Math.log(e) / Math.log(n[i].size)) * e; break } t /= n[i].endValue / n[i].startValue / n[i].size, e *= n[i].size, a = !1 } else { if (!(e < n[i].endValue / n[i + 1].startValue)) break; if ((e /= n[i].endValue / n[i + 1].startValue) > 1 / n[i].size) { t *= Math.pow(n[i].endValue / n[i].startValue, 1 >= n[i].size ? 1 : Math.log(e) / Math.log(n[i].size)) * e; break } t /= n[i].endValue / n[i].startValue / n[i].size, e *= n[i].size } a = t * this.viewportMinimum } else { if (t = e = (i - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit, i <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) { for (i = 0; i < n.length; i++)if (!(n[i].endValue < this.conversionParameters.minimum)) if (a) if (n[i].startValue < this.conversionParameters.minimum) { if (n[i].size && this.conversionParameters.minimum + e * (n[i].endValue - n[i].startValue) / n[i].size < n[i].endValue) { t = 0 >= n[i].size ? 0 : e * (n[i].endValue - n[i].startValue) / n[i].size; break } t += n[i].endValue - this.conversionParameters.minimum - n[i].size * (n[i].endValue - this.conversionParameters.minimum) / (n[i].endValue - n[i].startValue), e -= n[i].size * (n[i].endValue - this.conversionParameters.minimum) / (n[i].endValue - n[i].startValue), a = !1 } else { if (!(e > n[i].startValue - this.conversionParameters.minimum)) break; if ((e -= n[i].startValue - this.conversionParameters.minimum) < n[i].size) { t += (n[i].endValue - n[i].startValue) * (0 === n[i].size ? 1 : e / n[i].size) - e; break } t += n[i].endValue - n[i].startValue - n[i].size, e -= n[i].size, a = !1 } else { if (!(e > n[i].startValue - n[i - 1].endValue)) break; if ((e -= n[i].startValue - n[i - 1].endValue) < n[i].size) { t += (n[i].endValue - n[i].startValue) * (0 === n[i].size ? 1 : e / n[i].size) - e; break } t += n[i].endValue - n[i].startValue - n[i].size, e -= n[i].size } } else for (i = n.length - 1; 0 <= i; i--)if (!(n[i].startValue > this.conversionParameters.minimum)) if (a) if (n[i].endValue > this.conversionParameters.minimum) { if (n[i].size && this.conversionParameters.minimum + e * (n[i].endValue - n[i].startValue) / n[i].size > n[i].startValue) { t = 0 >= n[i].size ? 0 : e * (n[i].endValue - n[i].startValue) / n[i].size; break } t += n[i].startValue - this.conversionParameters.minimum + n[i].size * (this.conversionParameters.minimum - n[i].startValue) / (n[i].endValue - n[i].startValue), e += n[i].size * (this.conversionParameters.minimum - n[i].startValue) / (n[i].endValue - n[i].startValue), a = !1 } else { if (!(e < n[i].endValue - this.conversionParameters.minimum)) break; if ((e -= n[i].endValue - this.conversionParameters.minimum) > -1 * n[i].size) { t += (n[i].endValue - n[i].startValue) * (0 === n[i].size ? 1 : e / n[i].size) + e; break } t -= n[i].endValue - n[i].startValue - n[i].size, e += n[i].size, a = !1 } else { if (!(e < n[i].endValue - n[i + 1].startValue)) break; if ((e -= n[i].endValue - n[i + 1].startValue) > -1 * n[i].size) { t += (n[i].endValue - n[i].startValue) * (0 === n[i].size ? 1 : e / n[i].size) + e; break } t -= n[i].endValue - n[i].startValue - n[i].size, e += n[i].size } a = this.conversionParameters.minimum + t } return a }, W.prototype.convertValueToPixel = function (t) { return t = this.getApparentDifference(this.conversionParameters.minimum, t, t), this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(t / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + .5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (t - this.conversionParameters.minimum) + .5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (t - this.conversionParameters.minimum) + .5 }, W.prototype.getApparentDifference = function (t, e, a, i) { var n = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []; if (this.logarithmic) { a = p(a) ? e / t : a; for (var s = 0; s < n.length && !(e < n[s].startValue); s++)t > n[s].endValue || (t <= n[s].startValue && e >= n[s].endValue ? a = a / n[s].endValue * n[s].startValue * n[s].size : t >= n[s].startValue && e >= n[s].endValue ? a = a / n[s].endValue * t * Math.pow(n[s].size, Math.log(n[s].endValue / t) / Math.log(n[s].endValue / n[s].startValue)) : t <= n[s].startValue && e <= n[s].endValue ? a = a / e * n[s].startValue * Math.pow(n[s].size, Math.log(e / n[s].startValue) / Math.log(n[s].endValue / n[s].startValue)) : !i && t > n[s].startValue && e < n[s].endValue && (a = t * Math.pow(n[s].size, Math.log(e / t) / Math.log(n[s].endValue / n[s].startValue)))) } else for (a = p(a) ? Math.abs(e - t) : a, s = 0; s < n.length && !(e < n[s].startValue); s++)t > n[s].endValue || (t <= n[s].startValue && e >= n[s].endValue ? a = a - n[s].endValue + n[s].startValue + n[s].size : t > n[s].startValue && e >= n[s].endValue ? a = a - n[s].endValue + t + n[s].size * (n[s].endValue - t) / (n[s].endValue - n[s].startValue) : t <= n[s].startValue && e < n[s].endValue ? a = a - e + n[s].startValue + n[s].size * (e - n[s].startValue) / (n[s].endValue - n[s].startValue) : !i && t > n[s].startValue && e < n[s].endValue && (a = t + n[s].size * (e - t) / (n[s].endValue - n[s].startValue))); return a }, W.prototype.setViewPortRange = function (t, e) { this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(t, e), this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(t, e) }, W.prototype.getXValueAt = function (t) { if (!t) return null; var e = null; return "left" === this._position ? e = this.convertPixelToValue(t.y) : "bottom" === this._position && (e = this.convertPixelToValue(t.x)), e }, W.prototype.calculateValueToPixelConversionParameters = function (t) { t = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []; var e = { pixelPerUnit: null, minimum: null, reference: null }, a = this.lineCoordinates.width, i = this.lineCoordinates.height; a = "bottom" === this._position || "top" === this._position ? a : i, i = Math.abs(this.range); if (this.logarithmic) for (var n = 0; n < t.length && !(this.viewportMaximum < t[n].startValue); n++)this.viewportMinimum > t[n].endValue || (this.viewportMinimum >= t[n].startValue && this.viewportMaximum <= t[n].endValue ? a = 0 : this.viewportMinimum <= t[n].startValue && this.viewportMaximum >= t[n].endValue ? (i = i / t[n].endValue * t[n].startValue, a = 0 < t[n].spacing.toString().indexOf("%") ? a * (1 - parseFloat(t[n].spacing) / 100) : a - Math.min(t[n].spacing, .1 * a)) : this.viewportMinimum > t[n].startValue && this.viewportMaximum >= t[n].endValue ? (i = i / t[n].endValue * this.viewportMinimum, a = 0 < t[n].spacing.toString().indexOf("%") ? a * (1 - parseFloat(t[n].spacing) / 100 * Math.log(t[n].endValue / this.viewportMinimum) / Math.log(t[n].endValue / t[n].startValue)) : a - Math.min(t[n].spacing, .1 * a) * Math.log(t[n].endValue / this.viewportMinimum) / Math.log(t[n].endValue / t[n].startValue)) : this.viewportMinimum <= t[n].startValue && this.viewportMaximum < t[n].endValue && (i = i / this.viewportMaximum * t[n].startValue, a = 0 < t[n].spacing.toString().indexOf("%") ? a * (1 - parseFloat(t[n].spacing) / 100 * Math.log(this.viewportMaximum / t[n].startValue) / Math.log(t[n].endValue / t[n].startValue)) : a - Math.min(t[n].spacing, .1 * a) * Math.log(this.viewportMaximum / t[n].startValue) / Math.log(t[n].endValue / t[n].startValue))); else for (n = 0; n < t.length && !(this.viewportMaximum < t[n].startValue); n++)this.viewportMinimum > t[n].endValue || (this.viewportMinimum >= t[n].startValue && this.viewportMaximum <= t[n].endValue ? a = 0 : this.viewportMinimum <= t[n].startValue && this.viewportMaximum >= t[n].endValue ? (i = i - t[n].endValue + t[n].startValue, a = 0 < t[n].spacing.toString().indexOf("%") ? a * (1 - parseFloat(t[n].spacing) / 100) : a - Math.min(t[n].spacing, .1 * a)) : this.viewportMinimum > t[n].startValue && this.viewportMaximum >= t[n].endValue ? (i = i - t[n].endValue + this.viewportMinimum, a = 0 < t[n].spacing.toString().indexOf("%") ? a * (1 - parseFloat(t[n].spacing) / 100 * (t[n].endValue - this.viewportMinimum) / (t[n].endValue - t[n].startValue)) : a - Math.min(t[n].spacing, .1 * a) * (t[n].endValue - this.viewportMinimum) / (t[n].endValue - t[n].startValue)) : this.viewportMinimum <= t[n].startValue && this.viewportMaximum < t[n].endValue && (i = i - this.viewportMaximum + t[n].startValue, a = 0 < t[n].spacing.toString().indexOf("%") ? a * (1 - parseFloat(t[n].spacing) / 100 * (this.viewportMaximum - t[n].startValue) / (t[n].endValue - t[n].startValue)) : a - Math.min(t[n].spacing, .1 * a) * (this.viewportMaximum - t[n].startValue) / (t[n].endValue - t[n].startValue))); e.minimum = this.viewportMinimum, e.maximum = this.viewportMaximum, e.range = i, "bottom" !== this._position && "top" !== this._position || (this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? -1 : 1) * a * e.lnLogarithmBase / Math.log(Math.abs(i))) : e.pixelPerUnit = (this.reversed ? -1 : 1) * a / Math.abs(i), e.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1), "left" !== this._position && "right" !== this._position || (this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? 1 : -1) * a * e.lnLogarithmBase / Math.log(Math.abs(i))) : e.pixelPerUnit = (this.reversed ? 1 : -1) * a / Math.abs(i), e.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2), this.conversionParameters = e }, W.prototype.calculateAxisParameters = function () { if (this.logarithmic) this.calculateLogarithmicAxisParameters(); else { var t = this.chart.layoutManager.getFreeSpace(), e = !1, a = !1; "bottom" === this._position || "top" === this._position ? (this.maxWidth = t.width, this.maxHeight = t.height) : (this.maxWidth = t.height, this.maxHeight = t.width); t = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40; var i = 4; "axisX" === this.type && (i = 600 > this.maxWidth ? 8 : 6); var n, s, o; t = Math.max(i, Math.floor(this.maxWidth / t)), i = 0; if (!p(this.options.viewportMinimum) && !p(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum && (this.viewportMinimum = this.viewportMaximum = null), !p(this.options.viewportMinimum) || p(this.sessionVariables.newViewportMinimum) || isNaN(this.sessionVariables.newViewportMinimum) ? (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum) : this.viewportMinimum = this.sessionVariables.newViewportMinimum, !p(this.options.viewportMaximum) || p(this.sessionVariables.newViewportMaximum) || isNaN(this.sessionVariables.newViewportMaximum) ? (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum) : this.viewportMaximum = this.sessionVariables.newViewportMaximum, this.scaleBreaks) for (i = 0; i < this.scaleBreaks._appliedBreaks.length; i++)if ((!p(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[i].startValue || !p(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[i].startValue || !p(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[i].startValue) && (!p(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[i].endValue || !p(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[i].endValue || !p(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[i].endValue)) { this.scaleBreaks._appliedBreaks.splice(i, 1); break } if ("axisX" === this.type) { if (this.dataSeries && 0 < this.dataSeries.length) for (n = 0; n < this.dataSeries.length; n++)"dateTime" === this.dataSeries[n].xValueType && (a = !0); n = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 0 === (s = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax) - n && (s += i = "undefined" === typeof this.options.interval ? .4 : this.options.interval, n -= i), 1 / 0 !== this.dataInfo.minDiff ? o = this.dataInfo.minDiff : 1 < s - n ? o = .5 * Math.abs(s - n) : (o = 1, a && (e = !0)) } else "axisY" === this.type && (n = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, s = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(n) || isFinite(s) ? isFinite(n) ? isFinite(s) || (s = n) : n = s : (s = "undefined" === typeof this.options.interval ? -1 / 0 : this.options.interval, n = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : 1 / 0), 0 === n && 0 === s ? (s += 9, n = 0) : 0 === s - n ? (s += i = Math.min(Math.abs(.01 * Math.abs(s)), 5), n -= i) : n > s ? (i = Math.min(.01 * Math.abs(this.getApparentDifference(s, n, null, !0)), 5), 0 <= s ? n = s - i : s = isFinite(n) ? n + i : 0) : (i = Math.min(.01 * Math.abs(this.getApparentDifference(n, s, null, !0)), .05), 0 !== s && (s += i), 0 !== n && (n -= i)), o = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < s - n ? .5 * Math.abs(s - n) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < n && (n = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > s && (s = 0)); i = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? n : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? s : this.viewportMaximum, null, !0), "axisX" === this.type && a ? (this.intervalType || (i / 1 <= t ? (this.interval = 1, this.intervalType = "millisecond") : i / 2 <= t ? (this.interval = 2, this.intervalType = "millisecond") : i / 5 <= t ? (this.interval = 5, this.intervalType = "millisecond") : i / 10 <= t ? (this.interval = 10, this.intervalType = "millisecond") : i / 20 <= t ? (this.interval = 20, this.intervalType = "millisecond") : i / 50 <= t ? (this.interval = 50, this.intervalType = "millisecond") : i / 100 <= t ? (this.interval = 100, this.intervalType = "millisecond") : i / 200 <= t ? (this.interval = 200, this.intervalType = "millisecond") : i / 250 <= t ? (this.interval = 250, this.intervalType = "millisecond") : i / 300 <= t ? (this.interval = 300, this.intervalType = "millisecond") : i / 400 <= t ? (this.interval = 400, this.intervalType = "millisecond") : i / 500 <= t ? (this.interval = 500, this.intervalType = "millisecond") : i / (1 * $.secondDuration) <= t ? (this.interval = 1, this.intervalType = "second") : i / (2 * $.secondDuration) <= t ? (this.interval = 2, this.intervalType = "second") : i / (5 * $.secondDuration) <= t ? (this.interval = 5, this.intervalType = "second") : i / (10 * $.secondDuration) <= t ? (this.interval = 10, this.intervalType = "second") : i / (15 * $.secondDuration) <= t ? (this.interval = 15, this.intervalType = "second") : i / (20 * $.secondDuration) <= t ? (this.interval = 20, this.intervalType = "second") : i / (30 * $.secondDuration) <= t ? (this.interval = 30, this.intervalType = "second") : i / (1 * $.minuteDuration) <= t ? (this.interval = 1, this.intervalType = "minute") : i / (2 * $.minuteDuration) <= t ? (this.interval = 2, this.intervalType = "minute") : i / (5 * $.minuteDuration) <= t ? (this.interval = 5, this.intervalType = "minute") : i / (10 * $.minuteDuration) <= t ? (this.interval = 10, this.intervalType = "minute") : i / (15 * $.minuteDuration) <= t ? (this.interval = 15, this.intervalType = "minute") : i / (20 * $.minuteDuration) <= t ? (this.interval = 20, this.intervalType = "minute") : i / (30 * $.minuteDuration) <= t ? (this.interval = 30, this.intervalType = "minute") : i / (1 * $.hourDuration) <= t ? (this.interval = 1, this.intervalType = "hour") : i / (2 * $.hourDuration) <= t ? (this.interval = 2, this.intervalType = "hour") : i / (3 * $.hourDuration) <= t ? (this.interval = 3, this.intervalType = "hour") : i / (6 * $.hourDuration) <= t ? (this.interval = 6, this.intervalType = "hour") : i / (1 * $.dayDuration) <= t ? (this.interval = 1, this.intervalType = "day") : i / (2 * $.dayDuration) <= t ? (this.interval = 2, this.intervalType = "day") : i / (4 * $.dayDuration) <= t ? (this.interval = 4, this.intervalType = "day") : i / (1 * $.weekDuration) <= t ? (this.interval = 1, this.intervalType = "week") : i / (2 * $.weekDuration) <= t ? (this.interval = 2, this.intervalType = "week") : i / (3 * $.weekDuration) <= t ? (this.interval = 3, this.intervalType = "week") : i / (1 * $.monthDuration) <= t ? (this.interval = 1, this.intervalType = "month") : i / (2 * $.monthDuration) <= t ? (this.interval = 2, this.intervalType = "month") : i / (3 * $.monthDuration) <= t ? (this.interval = 3, this.intervalType = "month") : i / (6 * $.monthDuration) <= t ? (this.interval = 6, this.intervalType = "month") : (this.interval = i / (1 * $.yearDuration) <= t ? 1 : i / (2 * $.yearDuration) <= t ? 2 : i / (4 * $.yearDuration) <= t ? 4 : Math.floor(W.getNiceNumber(i / (t - 1), !0) / $.yearDuration), this.intervalType = "year")), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = n - o / 2), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = s + o / 2), e ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType || "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType || "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'"), this.valueFormatString || (this.valueFormatString = this.autoValueFormatString)) : (this.intervalType = "number", i = W.getNiceNumber(i, !1), this.interval = this.options && 0 < this.options.interval ? this.options.interval : W.getNiceNumber(i / (t - 1), !0), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? n - o / 2 : Math.floor(n / this.interval) * this.interval), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? s + o / 2 : Math.ceil(s / this.interval) * this.interval), 0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval = W.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (t - 1), !0)))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (n = null !== this.minimum ? this.minimum : this.dataInfo.min, 0 === (s = null !== this.maximum ? this.maximum : this.dataInfo.max) - n && (s += i = "undefined" === typeof this.options.interval ? .4 : this.options.interval, n -= i), o = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < s - n ? .5 * Math.abs(s - n) : 1) : "axisY" === this.type && (n = null !== this.minimum ? this.minimum : this.dataInfo.min, s = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(n) || isFinite(s) ? 0 === n && 0 === s ? (s += 9, n = 0) : 0 === s - n ? (s += i = Math.min(Math.abs(.01 * Math.abs(s)), 5), n -= i) : n > s ? (i = Math.min(.01 * Math.abs(this.getApparentDifference(s, n, null, !0)), 5), 0 <= s ? n = s - i : s = isFinite(n) ? n + i : 0) : (i = Math.min(.01 * Math.abs(this.getApparentDifference(n, s, null, !0)), .05), 0 !== s && (s += i), 0 !== n && (n -= i)) : (s = "undefined" === typeof this.options.interval ? -1 / 0 : this.options.interval, n = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : 1 / 0), o = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < s - n ? .5 * Math.abs(s - n) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < n && (n = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > s && (s = 0)), Math.abs(this.getApparentDifference(n, s, null, !0)), "axisX" === this.type && a ? (this.valueType = "dateTime", (null === this.minimum || isNaN(this.minimum)) && (this.minimum = n - o / 2), (null === this.maximum || isNaN(this.maximum)) && (this.maximum = s + o / 2)) : (this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? n - o / 2 : Math.floor(n / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? 1 / 0 : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? s + o / 2 : Math.ceil(s / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -1 / 0 : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10)))), p(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)), p(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)), this.range = this.viewportMaximum - this.viewportMinimum, this.intervalStartPosition = "axisX" === this.type && a ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + .2 * this.interval) / this.interval) * this.interval, this.valueFormatString || (this.valueFormatString = W.generateValueFormatString(this.range, 2)) } }, W.prototype.calculateLogarithmicAxisParameters = function () { var t, e = this.chart.layoutManager.getFreeSpace(), a = Math.log(this.logarithmBase); "bottom" === this._position || "top" === this._position ? (this.maxWidth = e.width, this.maxHeight = e.height) : (this.maxWidth = e.height, this.maxHeight = e.width); var i, n, s, o; e = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3); if (o = 1, (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum), this.scaleBreaks) for (o = 0; o < this.scaleBreaks._appliedBreaks.length; o++)if ((!p(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[o].startValue || !p(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[o].startValue || !p(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[o].startValue) && (!p(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[o].endValue || !p(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[o].endValue || !p(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[o].endValue)) { this.scaleBreaks._appliedBreaks.splice(o, 1); break } "axisX" === this.type ? (i = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 1 === (n = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax) / i && (n *= o = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? .4 : this.options.interval), i /= o), s = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : n / i > this.logarithmBase ? n / i * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (i = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, n = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= i && !isFinite(n) ? (n = "undefined" === typeof this.options.interval ? 0 : this.options.interval, i = 1) : 0 >= i ? i = n : isFinite(n) || (n = i), 1 === i && 1 === n ? (n *= this.logarithmBase - 1 / this.logarithmBase, i = 1) : 1 === n / i ? (n *= o = Math.min(n * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), i /= o) : i > n ? (o = Math.min(i / n * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), 1 <= n ? i = n / o : n = i * o) : (o = Math.min(n / i * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== n && (n *= o), 1 !== i && (i /= o)), s = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : n / i > this.logarithmBase ? n / i * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < i && (i = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > n && (n = 1)), o = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? n : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? i : this.viewportMinimum); var r = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? n : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? i : this.viewportMinimum); if (this.intervalType = "number", o = Math.pow(this.logarithmBase, W.getNiceNumber(Math.abs(Math.log(o) / a), !1)), this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = W.getNiceExponent(Math.log(o) / a / (e - 1), !0), t = W.getNiceNumber(r / (e - 1), !0)), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? i / Math.sqrt(s) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(i) / a / this.interval))), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? n * Math.sqrt(s) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(n) / a / this.interval))), 1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = W.getNiceExponent(Math.ceil(Math.log(o) / a) / (e - 1)), t = W.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (e - 1), !0))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (i = null !== this.minimum ? this.minimum : this.dataInfo.min, 1 === (n = null !== this.maximum ? this.maximum : this.dataInfo.max) / i && (n *= o = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? .4 : this.options.interval), i /= o), s = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : n / i > this.logarithmBase ? n / i * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (i = null !== this.minimum ? this.minimum : this.dataInfo.min, n = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(i) || isFinite(n) ? 1 === i && 1 === n ? (n *= this.logarithmBase, i /= this.logarithmBase) : 1 === n / i ? (n *= o = Math.pow(this.logarithmBase, this.interval), i /= o) : i > n ? (o = Math.min(i / n * .01, 5), 1 <= n ? i = n / o : n = i * o) : (o = Math.min(n / i * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== n && (n *= o), 1 !== i && (i /= o)) : (n = "undefined" === typeof this.options.interval ? 0 : this.options.interval, i = 1), s = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : n / i > this.logarithmBase ? n / i * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < i && (i = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > n && (n = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? i / Math.sqrt(s) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(i) / a / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? 1 / 0 : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? n * Math.sqrt(s) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(n) / a / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase))), this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum), this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum), this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum), i = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (a * this.interval) + .2) * this.interval), this.range = this.viewportMaximum / this.viewportMinimum, this.noTicks = e, !this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > e ? 2 : 3)) { for (a = Math.floor(this.viewportMinimum / t + .5) * t; a < this.viewportMinimum;)a += t; this.equidistantInterval = !1, this.intervalStartPosition = a, this.interval = t } else this.options.interval || (t = Math.ceil(this.interval), this.range > this.interval && (this.interval = t, i = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (a * this.interval) + .2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = i; if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum) && (a = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2, !isNaN(a) && isFinite(a) || (a = 2), 2 < a)) for (o = 0; o < a - 2; o++)this.valueFormatString += "#" }, W.generateValueFormatString = function (t, e) { var a = "#,##0.", i = e; 1 > t && (i += Math.floor(Math.abs(Math.log(t) / Math.LN10)), isNaN(i) || !isFinite(i)) && (i = e); for (var n = 0; n < i; n++)a += "#"; return a }, W.getNiceExponent = function (t, e) { var a = Math.floor(Math.log(t) / Math.LN10), i = t / Math.pow(10, a); i = 0 > a ? 1 >= i ? 1 : 5 >= i ? 5 : 10 : Math.max(Math.floor(i), 1); return Number(-20 > a ? i * Math.pow(10, a) : (i * Math.pow(10, a)).toFixed(20)) }, W.getNiceNumber = function (t, e) { var a = Math.floor(Math.log(t) / Math.LN10), i = t / Math.pow(10, a); i = e ? 1.5 > i ? 1 : 3 > i ? 2 : 7 > i ? 5 : 10 : 1 >= i ? 1 : 2 >= i ? 2 : 5 >= i ? 5 : 10; return Number(-20 > a ? i * Math.pow(10, a) : (i * Math.pow(10, a)).toFixed(20)) }, W.prototype.getLabelStartPoint = function () { var t = $[this.intervalType + "Duration"] * this.interval; t = new Date(Math.floor(this.viewportMinimum / t) * t); return "millisecond" !== this.intervalType && ("second" === this.intervalType ? 0 < t.getMilliseconds() && (t.setSeconds(t.getSeconds() + 1), t.setMilliseconds(0)) : "minute" === this.intervalType ? (0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setMinutes(t.getMinutes() + 1), t.setSeconds(0), t.setMilliseconds(0)) : "hour" === this.intervalType ? (0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setHours(t.getHours() + 1), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "day" === this.intervalType ? (0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setDate(t.getDate() + 1), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "week" === this.intervalType ? (0 < t.getDay() || 0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setDate(t.getDate() + (7 - t.getDay())), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "month" === this.intervalType ? (1 < t.getDate() || 0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setMonth(t.getMonth() + 1), t.setDate(1), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "year" === this.intervalType && (0 < t.getMonth() || 1 < t.getDate() || 0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setFullYear(t.getFullYear() + 1), t.setMonth(0), t.setDate(1), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0))), t }, i(z, S), i(R, S), R.prototype.createUserOptions = function (t) { if ("undefined" !== typeof t || this.options._isPlaceholder) { var e = 0; this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.options._isPlaceholder || (u(this.parent[this.optionsName]), e = this.parent.options[this.optionsName].indexOf(this.options)), this.options = "undefined" === typeof t ? {} : t, this.parent.options[this.optionsName][e] = this.options } }, R.prototype.render = function (t) { if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) { var e = this.ctx, a = this.ctx.globalAlpha; this.ctx = t || this.ctx, this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(); var i, n, s, o, r, l, h = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), d = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue); this.ctx.strokeStyle = this.lineColor, this.ctx.fillStyle = this.color, this.ctx.beginPath(), this.ctx.globalAlpha = 1, c(this.id), t = Math.max(this.spacing, 3); var p = Math.max(0, this.lineThickness); if (this.ctx.lineWidth = p, this.ctx.setLineDash && this.ctx.setLineDash(g(this.lineDashType, p)), "bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position) { if (h = 1 === p % 2 ? .5 + (h.x << 0) : h.x << 0, n = 1 === p % 2 ? .5 + (d.x << 0) : d.x << 0, "top" === this.scaleBreaks.parent._position ? (d = this.chart.plotArea.y1, s = this.chart.plotArea.y2 + p / 2 + .5 << 0) : (d = this.chart.plotArea.y2, s = this.chart.plotArea.y1 - p / 2 + .5 << 0, t *= -1), this.bounds = { x1: h - p / 2, y1: d, x2: n + p / 2, y2: s }, this.ctx.moveTo(h, d), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= t || "bottom" === this.scaleBreaks.parent._position && 0 <= t) this.ctx.lineTo(h, s), this.ctx.lineTo(n, s), this.ctx.lineTo(n, d); else if ("wavy" === this.type) { o = h, i = .5, l = (s - (r = d)) / t / 3; for (var u = 0; u < l; u++)this.ctx.bezierCurveTo(o + i * t, r + t, o + i * t, r + 2 * t, o, r + 3 * t), r += 3 * t, i *= -1; for (this.ctx.bezierCurveTo(o + i * t, r + t, o + i * t, r + 2 * t, o, r + 3 * t), o = n, i *= -1, this.ctx.lineTo(o, r), u = 0; u < l; u++)this.ctx.bezierCurveTo(o + i * t, r - t, o + i * t, r - 2 * t, o, r - 3 * t), r -= 3 * t, i *= -1 } else if ("zigzag" === this.type) { for (i = -1, o = h + t, l = (s - (r = d + t)) / t / 2, u = 0; u < l; u++)this.ctx.lineTo(o, r), o += 2 * i * t, r += 2 * t, i *= -1; for (this.ctx.lineTo(o, r), o += n - h, u = 0; u < l + 1; u++)this.ctx.lineTo(o, r), o += 2 * i * t, r -= 2 * t, i *= -1; this.ctx.lineTo(o + i * t, r + t) } } else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) if (d = 1 === p % 2 ? .5 + (d.y << 0) : d.y << 0, s = 1 === p % 2 ? .5 + (h.y << 0) : h.y << 0, "left" === this.scaleBreaks.parent._position ? (h = this.chart.plotArea.x1, n = this.chart.plotArea.x2 + p / 2 + .5 << 0) : (h = this.chart.plotArea.x2, n = this.chart.plotArea.x1 - p / 2 + .5 << 0, t *= -1), this.bounds = { x1: h, y1: d - p / 2, x2: n, y2: s + p / 2 }, this.ctx.moveTo(h, d), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= t || "right" === this.scaleBreaks.parent._position && 0 <= t) this.ctx.lineTo(n, d), this.ctx.lineTo(n, s), this.ctx.lineTo(h, s); else if ("wavy" === this.type) { for (r = d, i = .5, l = (n - (o = h)) / t / 3, u = 0; u < l; u++)this.ctx.bezierCurveTo(o + t, r + i * t, o + 2 * t, r + i * t, o + 3 * t, r), o += 3 * t, i *= -1; for (this.ctx.bezierCurveTo(o + t, r + i * t, o + 2 * t, r + i * t, o + 3 * t, r), r = s, i *= -1, this.ctx.lineTo(o, r), u = 0; u < l; u++)this.ctx.bezierCurveTo(o - t, r + i * t, o - 2 * t, r + i * t, o - 3 * t, r), o -= 3 * t, i *= -1 } else if ("zigzag" === this.type) { for (i = 1, r = d - t, l = (n - (o = h + t)) / t / 2, u = 0; u < l; u++)this.ctx.lineTo(o, r), r += 2 * i * t, o += 2 * t, i *= -1; for (this.ctx.lineTo(o, r), r += s - d, u = 0; u < l + 1; u++)this.ctx.lineTo(o, r), r += 2 * i * t, o -= 2 * t, i *= -1; this.ctx.lineTo(o + t, r + i * t) } 0 < p && this.ctx.stroke(), this.ctx.closePath(), this.ctx.globalAlpha = this.fillOpacity, this.ctx.globalCompositeOperation = "destination-over", this.ctx.fill(), this.ctx.restore(), this.ctx.globalAlpha = a, this.ctx = e } }, i(j, S), j.prototype.createUserOptions = function (t) { if ("undefined" !== typeof t || this.options._isPlaceholder) { var e = 0; this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.options._isPlaceholder || (u(this.parent.stripLines), e = this.parent.options.stripLines.indexOf(this.options)), this.options = "undefined" === typeof t ? {} : t, this.parent.options.stripLines[e] = this.options } }, j.prototype.render = function () { this.ctx.save(); var t = this.parent.getPixelCoordinatesOnAxis(this.value), e = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness); if (0 < e) { var a = null === this.opacity ? 1 : this.opacity; this.ctx.strokeStyle = this.color, this.ctx.beginPath(); var i, n, s, o, r = this.ctx.globalAlpha; this.ctx.globalAlpha = a, c(this.id), this.ctx.lineWidth = e, this.ctx.setLineDash && this.ctx.setLineDash(g(this.lineDashType, e)), "bottom" === this.parent._position || "top" === this.parent._position ? (i = n = 1 === this.ctx.lineWidth % 2 ? .5 + (t.x << 0) : t.x << 0, s = this.chart.plotArea.y1, o = this.chart.plotArea.y2, this.bounds = { x1: i - e / 2, y1: s, x2: n + e / 2, y2: o }) : "left" !== this.parent._position && "right" !== this.parent._position || (s = o = 1 === this.ctx.lineWidth % 2 ? .5 + (t.y << 0) : t.y << 0, i = this.chart.plotArea.x1, n = this.chart.plotArea.x2, this.bounds = { x1: i, y1: s - e / 2, x2: n, y2: o + e / 2 }), this.ctx.moveTo(i, s), this.ctx.lineTo(n, o), this.ctx.stroke(), this.ctx.globalAlpha = r } this.ctx.restore() }, i(U, S), U.prototype.render = function (t, e) { var a, i, n, s, o = null, r = o = null, l = ""; if (!this.valueFormatString) if ("dateTime" === this.parent.valueType) this.valueFormatString = this.parent.valueFormatString; else { var h = 0; h = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0); this.valueFormatString = W.generateValueFormatString(this.parent.range, h) } r = null === this.opacity ? 1 : this.opacity, h = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness); var c = this.chart.overlaidCanvasCtx, d = c.globalAlpha; if (c.globalAlpha = r, c.beginPath(), c.strokeStyle = this.color, c.lineWidth = h, c.save(), this.labelFontSize = p(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize, "left" === this.parent._position || "right" === this.parent._position ? (this.labelMaxWidth = p(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 : this.labelMaxWidth, this.labelMaxHeight = p(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize) : "top" !== this.parent._position && "bottom" !== this.parent._position || (this.labelMaxWidth = p(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth, this.labelMaxHeight = p(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize), 0 < h && c.setLineDash && c.setLineDash(g(this.lineDashType, h)), r = new E(c, { x: 0, y: 0, padding: { top: 2, right: 3, bottom: 2, left: 4 }, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxWidth: this.labelMaxWidth, maxHeight: this.labelMaxHeight, angle: this.labelAngle, text: l, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this.snapToDataPoint) { var u = 0; o = []; if ("xySwapped" === this.chart.plotInfo.axisPlacement) { var m = null; "bottom" === this.parent._position || "top" === this.parent._position ? u = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: e }) : "left" !== this.parent._position && "right" !== this.parent._position || (u = this.parent.convertPixelToValue({ y: e })); for (var x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (m.dataSeries = this.parent.dataSeries[x], null !== m.dataPoint.y && o.push(m)); if (m = null, 0 === o.length) return; if (o.sort((function (t, e) { return t.distance - e.distance })), m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), x = 0, "rangeBar" === o[0].dataSeries.type || "error" === o[0].dataSeries.type) { m = Math.abs(t - this.parent.convertValueToPixel(o[x].dataPoint.y[0])); var b = 0; for (u = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else (b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, x = u) } else if ("stackedBar" === o[0].dataSeries.type) { m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)); var y = b = 0; for (u = x = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else y += o[u].dataPoint.y, (b = Math.abs(t - this.parent.convertValueToPixel(y))) < m && (m = b, x = u) } else if ("stackedBar100" === o[0].dataSeries.type) { m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)); var f = y = b = 0; for (u = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else y += o[u].dataPoint.y, f = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, f = y / o[u].dataSeries.plotUnit.dataPointYSums[f] * 100, (b = Math.abs(t - this.parent.convertValueToPixel(f))) < m && (m = b, x = u) } else for (m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = x = b = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else (b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, x = u); if (l = o[x], "bottom" === this.parent._position || "top" === this.parent._position) { if (a = 0, "rangeBar" === this.parent.dataSeries[x].type || "error" === this.parent.dataSeries[x].type) { for (m = Math.abs(t - this.parent.convertValueToPixel(l.dataPoint.y[0])), u = b = 0; u < l.dataPoint.y.length; u++)(b = Math.abs(t - this.parent.convertValueToPixel(l.dataPoint.y[u]))) < m && (m = b, a = u); o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataPoint.y[a]) << 0) : this.parent.convertValueToPixel(l.dataPoint.y[a]) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.y[a] }) : p(this.options.label) ? st(l.dataPoint.y[a], this.valueFormatString, this.chart._cultureInfo) : this.label } else if ("stackedBar" === this.parent.dataSeries[x].type) { for (m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), y = b = 0, u = x; 0 <= u; u--)y += o[u].dataPoint.y, (b = Math.abs(t - this.parent.convertValueToPixel(y))) < m && (m = b, a = u); o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(y) << 0) : this.parent.convertValueToPixel(y) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.y }) : p(this.options.label) ? st(l.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label } else if ("stackedBar100" === this.parent.dataSeries[x].type) { for (m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), f = y = b = 0, u = x; 0 <= u; u--)y += o[u].dataPoint.y, f = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, f = y / o[u].dataSeries.plotUnit.dataPointYSums[f] * 100, (b = Math.abs(t - this.parent.convertValueToPixel(f))) < m && (m = b, a = u); o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(f) << 0) : this.parent.convertValueToPixel(f) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f }) : p(this.options.label) ? st(f, this.valueFormatString, this.chart._cultureInfo) : this.label } else o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataPoint.y) << 0) : this.parent.convertValueToPixel(l.dataPoint.y) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.y }) : p(this.options.label) ? st(l.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label; a = i = o, n = this.chart.plotArea.y1, s = this.chart.plotArea.y2, this.bounds = { x1: a - h / 2, y1: n, x2: i + h / 2, y2: s }, r.x = a - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 ? r.x = this.chart.bounds.x2 - r.width : r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2 } else if ("left" === this.parent._position || "right" === this.parent._position) { if (n = s = o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataPoint.x) << 0) : this.parent.convertValueToPixel(l.dataPoint.x) << 0, a = this.chart.plotArea.x1, i = this.chart.plotArea.x2, this.bounds = { x1: a, y1: n - h / 2, x2: i, y2: s + h / 2 }, f = !1, this.parent.labels) for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) { if (!this.parent.labels[u]) { f = !1; break } f = !0 } if (f) { if ("axisX" === this.parent.type) for (u = this.parent.convertPixelToValue({ y: e }), m = null, x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.x }) : p(this.options.label) ? m.dataPoint.label : this.label) } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.x }) : p(this.options.label) ? nt(l.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.x }) : p(this.options.label) ? st(l.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label); r.y = s + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x2 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2) } } else if ("bottom" === this.parent._position || "top" === this.parent._position) { for (u = this.parent.convertPixelToValue({ x: t }), x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (m.dataSeries = this.parent.dataSeries[x], null !== m.dataPoint.y && o.push(m)); if (0 === o.length) return; if (o.sort((function (t, e) { return t.distance - e.distance })), l = o[0], a = i = o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataPoint.x) << 0) : this.parent.convertValueToPixel(l.dataPoint.x) << 0, n = this.chart.plotArea.y1, s = this.chart.plotArea.y2, this.bounds = { x1: a - h / 2, y1: n, x2: i + h / 2, y2: s }, f = !1, this.parent.labels) for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) { if (!this.parent.labels[u]) { f = !1; break } f = !0 } if (f) { if ("axisX" === this.parent.type) for (u = this.parent.convertPixelToValue({ x: t }), m = null, x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.x }) : p(this.options.label) ? m.dataPoint.label : this.label) } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.x }) : p(this.options.label) ? nt(l.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.x }) : p(this.options.label) ? st(l.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label); r.x = a - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 && (r.x = this.chart.bounds.x2 - r.width), r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), "bottom" === this.parent._position ? r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2 : "top" === this.parent._position && (r.y = this.parent.lineCoordinates.y1 - r.height + r.fontSize / 2 + 2) } else if ("left" === this.parent._position || "right" === this.parent._position) { for (!p(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (u = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: t })), x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (m.dataSeries = this.parent.dataSeries[x], null !== m.dataPoint.y && o.push(m)); if (0 === o.length) return; if (o.sort((function (t, e) { return t.distance - e.distance })), x = 0, "rangeColumn" === o[0].dataSeries.type || "rangeArea" === o[0].dataSeries.type || "error" === o[0].dataSeries.type || "rangeSplineArea" === o[0].dataSeries.type || "candlestick" === o[0].dataSeries.type || "ohlc" === o[0].dataSeries.type || "boxAndWhisker" === o[0].dataSeries.type) for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y[0])), u = b = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else (b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, x = u); else if ("stackedColumn" === o[0].dataSeries.type || "stackedArea" === o[0].dataSeries.type) for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = y = b = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else y += o[u].dataPoint.y, (b = Math.abs(e - this.parent.convertValueToPixel(y))) < m && (m = b, x = u); else if ("stackedColumn100" === o[0].dataSeries.type || "stackedArea100" === o[0].dataSeries.type) for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = f = y = b = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else y += o[u].dataPoint.y, f = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, f = y / o[u].dataSeries.plotUnit.dataPointYSums[f] * 100, (b = Math.abs(e - this.parent.convertValueToPixel(f))) < m && (m = b, x = u); else for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = b = 0; u < o.length; u++)if (o[u].dataPoint.y && o[u].dataPoint.y.length) for (l = 0; l < o[u].dataPoint.y.length; l++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[l]))) < m && (m = b, x = u); else (b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, x = u); if (l = o[x], a = 0, "rangeColumn" === this.parent.dataSeries[x].type || "rangeArea" === this.parent.dataSeries[x].type || "error" === this.parent.dataSeries[x].type || "rangeSplineArea" === this.parent.dataSeries[x].type || "candlestick" === this.parent.dataSeries[x].type || "ohlc" === this.parent.dataSeries[x].type || "boxAndWhisker" === this.parent.dataSeries[x].type) { for (m = Math.abs(e - this.parent.convertValueToPixel(l.dataPoint.y[0])), u = b = 0; u < l.dataPoint.y.length; u++)(b = Math.abs(e - this.parent.convertValueToPixel(l.dataPoint.y[u]))) < m && (m = b, a = u); o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataPoint.y[a]) << 0) : this.parent.convertValueToPixel(l.dataPoint.y[a]) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.y[a] }) : p(this.options.label) ? st(l.dataPoint.y[a], this.valueFormatString, this.chart._cultureInfo) : this.label } else if ("stackedColumn" === this.parent.dataSeries[x].type || "stackedArea" === this.parent.dataSeries[x].type) { for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), y = b = 0, u = x; 0 <= u; u--)y += o[u].dataPoint.y, (b = Math.abs(e - this.parent.convertValueToPixel(y))) < m && (m = b, a = u); o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(y) << 0) : this.parent.convertValueToPixel(y) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.y }) : p(this.options.label) ? st(l.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label } else if ("stackedColumn100" === this.parent.dataSeries[x].type || "stackedArea100" === this.parent.dataSeries[x].type) { for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), y = b = 0, u = x; 0 <= u; u--)y += o[u].dataPoint.y, f = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, f = y / o[u].dataSeries.plotUnit.dataPointYSums[f] * 100, (b = Math.abs(e - this.parent.convertValueToPixel(f))) < m && (m = b, a = u); o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(f) << 0) : this.parent.convertValueToPixel(f) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f }) : p(this.options.label) ? st(f, this.valueFormatString, this.chart._cultureInfo) : this.label } else "waterfall" === this.parent.dataSeries[x].type ? (o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataSeries.dataPointEOs[l.index].cumulativeSum) << 0) : this.parent.convertValueToPixel(l.dataSeries.dataPointEOs[l.index].cumulativeSum) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataSeries.dataPointEOs[l.index].cumulativeSum }) : p(this.options.label) ? st(l.dataSeries.dataPointEOs[l.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (o = 1 === c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(l.dataPoint.y) << 0) : this.parent.convertValueToPixel(l.dataPoint.y) << 0, r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l.dataPoint.y }) : p(this.options.label) ? st(l.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label); n = s = o, a = this.chart.plotArea.x1, i = this.chart.plotArea.x2, this.bounds = { x1: a, y1: n - h / 2, x2: i, y2: s + h / 2 }, r.y = s + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x2 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2) } o = null, ("bottom" === this.parent._position || "top" === this.parent._position) && a >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && i <= this.parent.convertValueToPixel(this.parent.viewportMaximum) && (0 < h && (c.moveTo(a, n), c.lineTo(i, s), c.stroke()), c.restore(), !p(r.text) && ("number" === typeof r.text.valueOf() || 0 < r.text.length) && r.render(!0)), ("left" === this.parent._position || "right" === this.parent._position) && s >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && n <= this.parent.convertValueToPixel(this.parent.viewportMinimum) && (0 < h && (c.moveTo(a, n), c.lineTo(i, s), c.stroke()), c.restore(), !p(r.text) && ("number" === typeof r.text.valueOf() || 0 < r.text.length) && r.render(!0)) } else { if ("bottom" === this.parent._position || "top" === this.parent._position ? (a = i = o = 1 === c.lineWidth % 2 ? .5 + (t << 0) : t << 0, n = this.chart.plotArea.y1, s = this.chart.plotArea.y2, this.bounds = { x1: a - h / 2, y1: n, x2: i + h / 2, y2: s }) : "left" !== this.parent._position && "right" !== this.parent._position || (n = s = o = 1 === c.lineWidth % 2 ? .5 + (e << 0) : e << 0, a = this.chart.plotArea.x1, i = this.chart.plotArea.x2, this.bounds = { x1: a, y1: n - h / 2, x2: i, y2: s + h / 2 }), "xySwapped" === this.chart.plotInfo.axisPlacement) if ("left" === this.parent._position || "right" === this.parent._position) { if (f = !1, this.parent.labels) for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) { if (!this.parent.labels[u]) { f = !1; break } f = !0 } if (f) { if ("axisX" === this.parent.type) for (u = this.parent.convertPixelToValue({ y: e }), m = null, x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(t) }) : p(this.options.label) ? m.dataPoint.label : this.label) } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(e) }) : p(this.options.label) ? nt(this.parent.convertPixelToValue(e), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(e) }) : p(this.options.label) ? st(this.parent.convertPixelToValue(e), this.valueFormatString, this.chart._cultureInfo) : this.label); r.y = e + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x1 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2) } else "bottom" !== this.parent._position && "top" !== this.parent._position || (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(t) }) : p(this.options.label) ? st(this.parent.convertPixelToValue(t), this.valueFormatString, this.chart._cultureInfo) : this.label, r.x = a - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 && (r.x = this.chart.bounds.x2 - r.width), r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), "bottom" === this.parent._position && (r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2), "top" === this.parent._position && (r.y = this.parent.lineCoordinates.y1 - r.height + r.fontSize / 2 + 2)); else if ("bottom" === this.parent._position || "top" === this.parent._position) { if (f = !1, l = "", this.parent.labels) for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) { if (!this.parent.labels[u]) { f = !1; break } f = !0 } if (f) { if ("axisX" === this.parent.type) for (u = this.parent.convertPixelToValue({ x: t }), m = null, x = 0; x < this.parent.dataSeries.length; x++)(m = this.parent.dataSeries[x].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(t) }) : p(this.options.label) ? m.dataPoint.label : this.label) } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(t) }) : p(this.options.label) ? nt(this.parent.convertPixelToValue(t), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(t) : "" }) : p(this.options.label) ? st(this.parent.convertPixelToValue(t), this.valueFormatString, this.chart._cultureInfo) : this.label); r.x = a - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 && (r.x = this.chart.bounds.x2 - r.width), r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), "bottom" === this.parent._position ? r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2 : "top" === this.parent._position && (r.y = this.parent.lineCoordinates.y1 - r.height + r.fontSize / 2 + 2) } else "left" !== this.parent._position && "right" !== this.parent._position || (r.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(e) }) : p(this.options.label) ? st(this.parent.convertPixelToValue(e), this.valueFormatString, this.chart._cultureInfo) : this.label, r.y = e + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x2 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2)); 0 < h && (c.moveTo(a, n), c.lineTo(i, s), c.stroke()), c.restore(), !p(r.text) && ("number" === typeof r.text.valueOf() || 0 < r.text.length) && r.render(!0) } c.globalAlpha = d }, i(H, S), H.prototype._initialize = function () { var t; this.enabled && (this.container = document.createElement("div"), this.container.setAttribute("class", "canvasjs-chart-tooltip"), this.container.style.position = "absolute", this.container.style.height = "auto", this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)", this.container.style.zIndex = "1000", this.container.style.pointerEvents = "none", this.container.style.display = "none", t = '<div style=" width: auto;height: auto;min-width: 50px;', t += "line-height: auto;", t += "margin: 0px 0px 0px 0px;", t += "padding: 5px;", t += "font-family: Calibri, Arial, Georgia, serif;", t += "font-weight: normal;", t += "font-style: " + (Y ? "italic;" : "normal;"), t += "font-size: 14px;", t += "color: #000000;", t += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);", t += "text-align: left;", t += "border: 2px solid gray;", t += Y ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);", t += "text-indent: 0px;", t += "white-space: nowrap;", t += "border-radius: 5px;", t += "-moz-user-select:none;", t += "-khtml-user-select: none;", t += "-webkit-user-select: none;", t += "-ms-user-select: none;", t += "user-select: none;", Y || (t += "filter: alpha(opacity = 90);", t += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');"), t += '} "> Sample Tooltip</div>', this.container.innerHTML = t, this.contentDiv = this.container.firstChild, this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.chart._canvasJSContainer.appendChild(this.container)) }, H.prototype.mouseMoveHandler = function (t, e) { this._lastUpdated && 4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(t, e)) }, H.prototype._updateToolTip = function (t, e, a) { if (a = "undefined" === typeof a || a, this.container || this._initialize(), this.enabled || this.hide(), !this.chart.disableToolTip) { if ("undefined" === typeof t || "undefined" === typeof e) { if (isNaN(this._prevX) || isNaN(this._prevY)) return; t = this._prevX, e = this._prevY } else this._prevX = t, this._prevY = e; var i = null, n = null, s = [], o = 0; if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) { if ("xySwapped" === this.chart.plotInfo.axisPlacement) { var r = []; if (this.chart.axisX) for (var l = 0; l < this.chart.axisX.length; l++) { o = this.chart.axisX[l].convertPixelToValue({ y: e }); var h = null; for (i = 0; i < this.chart.axisX[l].dataSeries.length; i++)(h = this.chart.axisX[l].dataSeries[i].getDataPointAtX(o, a)) && 0 <= h.index && (h.dataSeries = this.chart.axisX[l].dataSeries[i], null !== h.dataPoint.y && r.push(h)); h = null } if (this.chart.axisX2) for (l = 0; l < this.chart.axisX2.length; l++) { for (o = this.chart.axisX2[l].convertPixelToValue({ y: e }), h = null, i = 0; i < this.chart.axisX2[l].dataSeries.length; i++)(h = this.chart.axisX2[l].dataSeries[i].getDataPointAtX(o, a)) && 0 <= h.index && (h.dataSeries = this.chart.axisX2[l].dataSeries[i], null !== h.dataPoint.y && r.push(h)); h = null } } else { if (r = [], this.chart.axisX) for (l = 0; l < this.chart.axisX.length; l++)for (o = this.chart.axisX[l].convertPixelToValue({ x: t }), h = null, i = 0; i < this.chart.axisX[l].dataSeries.length; i++)(h = this.chart.axisX[l].dataSeries[i].getDataPointAtX(o, a)) && 0 <= h.index && (h.dataSeries = this.chart.axisX[l].dataSeries[i], null !== h.dataPoint.y && r.push(h)); if (this.chart.axisX2) for (l = 0; l < this.chart.axisX2.length; l++)for (o = this.chart.axisX2[l].convertPixelToValue({ x: t }), h = null, i = 0; i < this.chart.axisX2[l].dataSeries.length; i++)(h = this.chart.axisX2[l].dataSeries[i].getDataPointAtX(o, a)) && 0 <= h.index && (h.dataSeries = this.chart.axisX2[l].dataSeries[i], null !== h.dataPoint.y && r.push(h)) } if (0 === r.length) return; for (r.sort((function (t, e) { return t.distance - e.distance })), a = r[0], i = 0; i < r.length; i++)r[i].dataPoint.x.valueOf() === a.dataPoint.x.valueOf() && s.push(r[i]); r = null } else { if (h = this.chart.getDataPointAtXY(t, e, a)) this.currentDataPointIndex = h.dataPointIndex, this.currentSeriesIndex = h.dataSeries.index; else if (Y) if (0 < (h = y(t, e, this.chart._eventManager.ghostCtx)) && "undefined" !== typeof this.chart._eventManager.objectMap[h]) { if ("legendItem" === (h = this.chart._eventManager.objectMap[h]).objectType) return; this.currentSeriesIndex = h.dataSeriesIndex, this.currentDataPointIndex = 0 <= h.dataPointIndex ? h.dataPointIndex : -1 } else this.currentDataPointIndex = -1; else this.currentDataPointIndex = -1; if (0 <= this.currentSeriesIndex) { if (n = this.chart.data[this.currentSeriesIndex], h = {}, 0 <= this.currentDataPointIndex) i = n.dataPoints[this.currentDataPointIndex], h.dataSeries = n, h.dataPoint = i, h.index = this.currentDataPointIndex, h.distance = Math.abs(i.x - o), "waterfall" === n.type && (h.cumulativeSumYStartValue = n.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, h.cumulativeSum = n.dataPointEOs[this.currentDataPointIndex].cumulativeSum); else { if (!this.enabled || "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type && "area" !== n.type && "stepArea" !== n.type && "splineArea" !== n.type && "stackedArea" !== n.type && "stackedArea100" !== n.type && "rangeArea" !== n.type && "rangeSplineArea" !== n.type && "candlestick" !== n.type && "ohlc" !== n.type && "boxAndWhisker" !== n.type) return; o = n.axisX.convertPixelToValue({ x: t }), (h = n.getDataPointAtX(o, a)).dataSeries = n, this.currentDataPointIndex = h.index, i = h.dataPoint } if (!p(h.dataPoint.y)) if (h.dataSeries.axisY) if (0 < h.dataPoint.y.length) { for (i = a = 0; i < h.dataPoint.y.length; i++)h.dataPoint.y[i] < h.dataSeries.axisY.viewportMinimum ? a-- : h.dataPoint.y[i] > h.dataSeries.axisY.viewportMaximum && a++; a < h.dataPoint.y.length && a > -h.dataPoint.y.length && s.push(h) } else "column" === n.type || "bar" === n.type ? 0 > h.dataPoint.y ? 0 > h.dataSeries.axisY.viewportMinimum && h.dataSeries.axisY.viewportMaximum >= h.dataPoint.y && s.push(h) : h.dataSeries.axisY.viewportMinimum <= h.dataPoint.y && 0 <= h.dataSeries.axisY.viewportMaximum && s.push(h) : "bubble" === n.type ? (a = this.chart._eventManager.objectMap[n.dataPointIds[h.index]].size / 2, h.dataPoint.y >= h.dataSeries.axisY.viewportMinimum - a && h.dataPoint.y <= h.dataSeries.axisY.viewportMaximum + a && s.push(h)) : "waterfall" === n.type ? (a = 0, h.cumulativeSumYStartValue < h.dataSeries.axisY.viewportMinimum ? a-- : h.cumulativeSumYStartValue > h.dataSeries.axisY.viewportMaximum && a++, h.cumulativeSum < h.dataSeries.axisY.viewportMinimum ? a-- : h.cumulativeSum > h.dataSeries.axisY.viewportMaximum && a++, 2 > a && -2 < a && s.push(h)) : (0 <= h.dataSeries.type.indexOf("100") || "stackedColumn" === n.type || "stackedBar" === n.type || h.dataPoint.y >= h.dataSeries.axisY.viewportMinimum && h.dataPoint.y <= h.dataSeries.axisY.viewportMaximum) && s.push(h); else s.push(h) } } if (0 < s.length && (this.highlightObjects(s), this.enabled)) if (a = "", null !== (a = this.getToolTipInnerHTML({ entries: s }))) { this.contentDiv.innerHTML = a, a = !1, "none" === this.container.style.display && (a = !0, this.container.style.display = "block"); try { this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : Y ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === s[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : s[0].dataPoint.color ? s[0].dataPoint.color : 0 < s[0].dataPoint.y ? s[0].dataSeries.risingColor : s[0].dataSeries.fallingColor : "error" === s[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : s[0].dataSeries.color ? s[0].dataSeries.color : s[0].dataSeries._colorSet[n.index % s[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : s[0].dataPoint.color ? s[0].dataPoint.color : s[0].dataSeries.color ? s[0].dataSeries.color : s[0].dataSeries._colorSet[s[0].index % s[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : Y ? "italic" : "normal" } catch (c) { } "pie" === s[0].dataSeries.type || "doughnut" === s[0].dataSeries.type || "funnel" === s[0].dataSeries.type || "pyramid" === s[0].dataSeries.type || "bar" === s[0].dataSeries.type || "rangeBar" === s[0].dataSeries.type || "stackedBar" === s[0].dataSeries.type || "stackedBar100" === s[0].dataSeries.type ? t = t - 10 - this.container.clientWidth : (t = s[0].dataSeries.axisX.convertValueToPixel(s[0].dataPoint.x) - this.container.clientWidth << 0, t -= 10), 0 > t && (t += this.container.clientWidth + 20), t + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (t = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth)), 0 < (e = 10 - (e = 1 !== s.length || this.shared || "line" !== s[0].dataSeries.type && "stepLine" !== s[0].dataSeries.type && "spline" !== s[0].dataSeries.type && "area" !== s[0].dataSeries.type && "stepArea" !== s[0].dataSeries.type && "splineArea" !== s[0].dataSeries.type ? "bar" === s[0].dataSeries.type || "rangeBar" === s[0].dataSeries.type || "stackedBar" === s[0].dataSeries.type || "stackedBar100" === s[0].dataSeries.type ? s[0].dataSeries.axisX.convertValueToPixel(s[0].dataPoint.x) : e : s[0].dataSeries.axisY.convertValueToPixel(s[0].dataPoint.y))) + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0), this.fixMozTransitionDelay(t, e), !this.animationEnabled || a ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition), this.container.style.left = t + "px", this.container.style.bottom = e + "px" } else this.hide(!1) } }, H.prototype.highlightObjects = function (t) { var e = this.chart.overlaidCanvasCtx; this.chart.resetOverlayedCanvas(), e.clearRect(0, 0, this.chart.width, this.chart.height), e.save(); var a = this.chart.plotArea, i = 0; for (e.beginPath(), e.rect(a.x1, a.y1, a.x2 - a.x1, a.y2 - a.y1), e.clip(), a = 0; a < t.length; a++) { var n = t[a]; if ((n = this.chart._eventManager.objectMap[n.dataSeries.dataPointIds[n.index]]) && n.objectType && "dataPoint" === n.objectType) { var s = (i = this.chart.data[n.dataSeriesIndex]).dataPoints[n.dataPointIndex], o = n.dataPointIndex; !1 === s.highlightEnabled || !0 !== i.highlightEnabled && !0 !== s.highlightEnabled || ("line" === i.type || "stepLine" === i.type || "spline" === i.type || "scatter" === i.type || "area" === i.type || "stepArea" === i.type || "splineArea" === i.type || "stackedArea" === i.type || "stackedArea100" === i.type || "rangeArea" === i.type || "rangeSplineArea" === i.type ? ((s = i.getMarkerProperties(o, n.x1, n.y1, this.chart.overlaidCanvasCtx)).size = Math.max(1.5 * s.size << 0, 10), s.borderColor = s.borderColor || "#FFFFFF", s.borderThickness = s.borderThickness || Math.ceil(.1 * s.size), et.drawMarkers([s]), "undefined" !== typeof n.y2 && ((s = i.getMarkerProperties(o, n.x1, n.y2, this.chart.overlaidCanvasCtx)).size = Math.max(1.5 * s.size << 0, 10), s.borderColor = s.borderColor || "#FFFFFF", s.borderThickness = s.borderThickness || Math.ceil(.1 * s.size), et.drawMarkers([s]))) : "bubble" === i.type ? ((s = i.getMarkerProperties(o, n.x1, n.y1, this.chart.overlaidCanvasCtx)).size = n.size, s.color = "white", s.borderColor = "white", e.globalAlpha = .3, et.drawMarkers([s]), e.globalAlpha = 1) : "column" === i.type || "stackedColumn" === i.type || "stackedColumn100" === i.type || "bar" === i.type || "rangeBar" === i.type || "stackedBar" === i.type || "stackedBar100" === i.type || "rangeColumn" === i.type || "waterfall" === i.type ? dt(e, n.x1, n.y1, n.x2, n.y2, "white", 0, null, !1, !1, !1, !1, .3) : "pie" === i.type || "doughnut" === i.type ? J(e, n.center, n.radius, "white", i.type, n.startAngle, n.endAngle, .3, n.percentInnerRadius) : "funnel" === i.type || "pyramid" === i.type ? K(e, n.funnelSection, .3, "white") : "candlestick" === i.type ? (e.globalAlpha = 1, e.strokeStyle = n.color, e.lineWidth = 2 * n.borderThickness, i = 0 === e.lineWidth % 2 ? 0 : .5, e.beginPath(), e.moveTo(n.x3 - i, Math.min(n.y2, n.y3)), e.lineTo(n.x3 - i, Math.min(n.y1, n.y4)), e.stroke(), e.beginPath(), e.moveTo(n.x3 - i, Math.max(n.y1, n.y4)), e.lineTo(n.x3 - i, Math.max(n.y2, n.y3)), e.stroke(), dt(e, n.x1, Math.min(n.y1, n.y4), n.x2, Math.max(n.y1, n.y4), "transparent", 2 * n.borderThickness, n.color, !1, !1, !1, !1), e.globalAlpha = 1) : "ohlc" === i.type ? (e.globalAlpha = 1, e.strokeStyle = n.color, e.lineWidth = 2 * n.borderThickness, i = 0 === e.lineWidth % 2 ? 0 : .5, e.beginPath(), e.moveTo(n.x3 - i, n.y2), e.lineTo(n.x3 - i, n.y3), e.stroke(), e.beginPath(), e.moveTo(n.x3, n.y1), e.lineTo(n.x1, n.y1), e.stroke(), e.beginPath(), e.moveTo(n.x3, n.y4), e.lineTo(n.x2, n.y4), e.stroke(), e.globalAlpha = 1) : "boxAndWhisker" === i.type ? (e.save(), e.globalAlpha = 1, e.strokeStyle = n.stemColor, e.lineWidth = 2 * n.stemThickness, 0 < n.stemThickness && (e.beginPath(), e.moveTo(n.x3, n.y2 + n.borderThickness / 2), e.lineTo(n.x3, n.y1 + n.whiskerThickness / 2), e.stroke(), e.beginPath(), e.moveTo(n.x3, n.y4 - n.whiskerThickness / 2), e.lineTo(n.x3, n.y3 - n.borderThickness / 2), e.stroke()), e.beginPath(), dt(e, n.x1 - n.borderThickness / 2, Math.max(n.y2 + n.borderThickness / 2, n.y3 + n.borderThickness / 2), n.x2 + n.borderThickness / 2, Math.min(n.y2 - n.borderThickness / 2, n.y3 - n.borderThickness / 2), "transparent", n.borderThickness, n.color, !1, !1, !1, !1), e.globalAlpha = 1, e.strokeStyle = n.whiskerColor, e.lineWidth = 2 * n.whiskerThickness, 0 < n.whiskerThickness && (e.beginPath(), e.moveTo(Math.floor(n.x3 - n.whiskerLength / 2), n.y4), e.lineTo(Math.ceil(n.x3 + n.whiskerLength / 2), n.y4), e.stroke(), e.beginPath(), e.moveTo(Math.floor(n.x3 - n.whiskerLength / 2), n.y1), e.lineTo(Math.ceil(n.x3 + n.whiskerLength / 2), n.y1), e.stroke()), e.globalAlpha = 1, e.strokeStyle = n.lineColor, e.lineWidth = 2 * n.lineThickness, 0 < n.lineThickness && (e.beginPath(), e.moveTo(n.x1, n.y5), e.lineTo(n.x2, n.y5), e.stroke()), e.restore(), e.globalAlpha = 1) : "error" === i.type && d(e, n.x1, n.y1, n.x2, n.y2, "white", n.whiskerProperties, n.stemProperties, n.isXYSwapped, .3)) } } e.restore(), e.globalAlpha = 1, e.beginPath() }, H.prototype.getToolTipInnerHTML = function (t) { t = t.entries; for (var e = null, a = null, i = null, n = 0, s = "", o = !0, r = 0; r < t.length; r++)if (t[r].dataSeries.toolTipContent || t[r].dataPoint.toolTipContent) { o = !1; break } if (o && (this.content && "function" === typeof this.content || this.contentFormatter)) t = { chart: this.chart, toolTip: this.options, entries: t }, e = this.contentFormatter ? this.contentFormatter(t) : this.content(t); else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) { var l = null, h = ""; for (r = 0; r < t.length; r++)a = t[r].dataSeries, i = t[r].dataPoint, n = t[r].index, s = "", 0 === r && o && !this.content && (this.chart.axisX && 0 < this.chart.axisX.length ? h += "undefined" !== typeof this.chart.axisX[0].labels[i.x] ? this.chart.axisX[0].labels[i.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (h += "undefined" !== typeof this.chart.axisX2[0].labels[i.x] ? this.chart.axisX2[0].labels[i.x] : "{x}"), h += "</br>", h = this.chart.replaceKeywordsWithValue(h, i, a, n)), null === i.toolTipContent || "undefined" === typeof i.toolTipContent && null === a.options.toolTipContent || ("line" === a.type || "stepLine" === a.type || "spline" === a.type || "area" === a.type || "stepArea" === a.type || "splineArea" === a.type || "column" === a.type || "bar" === a.type || "scatter" === a.type || "stackedColumn" === a.type || "stackedColumn100" === a.type || "stackedBar" === a.type || "stackedBar100" === a.type || "stackedArea" === a.type || "stackedArea100" === a.type || "waterfall" === a.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (s += l != a.axisXIndex ? a.axisX.title ? a.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), s += i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}", l = a.axisXIndex) : "bubble" === a.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (s += l != a.axisXIndex ? a.axisX.title ? a.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), s += i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}") : "rangeColumn" === a.type || "rangeBar" === a.type || "rangeArea" === a.type || "rangeSplineArea" === a.type || "error" === a.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (s += l != a.axisXIndex ? a.axisX.title ? a.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), s += i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}") : "candlestick" === a.type || "ohlc" === a.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (s += l != a.axisXIndex ? a.axisX.title ? a.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), s += i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}") : "boxAndWhisker" === a.type && (this.chart.axisX && 1 < this.chart.axisX.length && (s += l != a.axisXIndex ? a.axisX.title ? a.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), s += i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"), null === e && (e = ""), !0 === this.reversed ? (e = this.chart.replaceKeywordsWithValue(s, i, a, n) + e, r < t.length - 1 && (e = "</br>" + e)) : (e += this.chart.replaceKeywordsWithValue(s, i, a, n), r < t.length - 1 && (e += "</br>"))); null !== e && (e = h + e) } else { if (a = t[0].dataSeries, i = t[0].dataPoint, n = t[0].index, null === i.toolTipContent || "undefined" === typeof i.toolTipContent && null === a.options.toolTipContent) return null; "line" === a.type || "stepLine" === a.type || "spline" === a.type || "area" === a.type || "stepArea" === a.type || "splineArea" === a.type || "column" === a.type || "bar" === a.type || "scatter" === a.type || "stackedColumn" === a.type || "stackedColumn100" === a.type || "stackedBar" === a.type || "stackedBar100" === a.type || "stackedArea" === a.type || "stackedArea100" === a.type || "waterfall" === a.type ? s = i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (i.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === a.type ? s = i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (i.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type ? s = i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (i.name ? "{name}:</span>&nbsp;&nbsp;" : i.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === a.type || "rangeBar" === a.type || "rangeArea" === a.type || "rangeSplineArea" === a.type || "error" === a.type ? s = i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (i.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === a.type || "ohlc" === a.type ? s = i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (i.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === a.type && (s = i.toolTipContent ? i.toolTipContent : a.toolTipContent ? a.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (i.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"), null === e && (e = ""), e += this.chart.replaceKeywordsWithValue(s, i, a, n) } return e }, H.prototype.enableAnimation = function () { if (!this.container.style.WebkitTransition) { var t = this.getContainerTransition(this.containerTransitionDuration); this.container.style.WebkitTransition = t, this.container.style.MsTransition = t, this.container.style.transition = t, this.container.style.MozTransition = this.mozContainerTransition } }, H.prototype.disableAnimation = function () { this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "") }, H.prototype.hide = function (t) { this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" === typeof t || t) && this.chart.resetOverlayedCanvas()) }, H.prototype.show = function (t, e, a) { this._updateToolTip(t, e, "undefined" !== typeof a && a) }, H.prototype.fixMozTransitionDelay = function (t, e) { if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0); else { var a = parseFloat(this.container.style.left), i = (a = isNaN(a) ? 0 : a, parseFloat(this.container.style.bottom)); i = isNaN(i) ? 0 : i; 10 < Math.sqrt(Math.pow(a - t, 2) + Math.pow(i - e, 2)) ? this.mozContainerTransition = this.getContainerTransition(.1) : this.mozContainerTransition = this.getContainerTransition(0) } }, H.prototype.getContainerTransition = function (t) { return "left " + t + "s ease-out 0s, bottom " + t + "s ease-out 0s" }, G.prototype.reset = function () { this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.eventObjects = [], Y && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath()) }, G.prototype.getNewObjectTrackingId = function () { return ++this.lastObjectId }, G.prototype.mouseEventHandler = function (t) { if ("mousemove" === t.type || "click" === t.type) { var e = [], a = ot(t), i = null; if ((i = this.chart.getObjectAtXY(a.x, a.y, !1)) && "undefined" !== typeof this.objectMap[i]) if ("dataPoint" === (i = this.objectMap[i]).objectType) { var n = this.chart.data[i.dataSeriesIndex], s = n.dataPoints[i.dataPointIndex], o = i.dataPointIndex; i.eventParameter = { x: a.x, y: a.y, dataPoint: s, dataSeries: n.options, dataPointIndex: o, dataSeriesIndex: n.index, chart: this.chart }, i.eventContext = { context: s, userContext: s, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }, e.push(i), (i = this.objectMap[n.id]).eventParameter = { x: a.x, y: a.y, dataPoint: s, dataSeries: n.options, dataPointIndex: o, dataSeriesIndex: n.index, chart: this.chart }, i.eventContext = { context: n, userContext: n.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }, e.push(this.objectMap[n.id]) } else "legendItem" === i.objectType && (n = this.chart.data[i.dataSeriesIndex], s = null !== i.dataPointIndex ? n.dataPoints[i.dataPointIndex] : null, i.eventParameter = { x: a.x, y: a.y, dataSeries: n.options, dataPoint: s, dataPointIndex: i.dataPointIndex, dataSeriesIndex: i.dataSeriesIndex, chart: this.chart }, i.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: "itemmouseover", mousemove: "itemmousemove", mouseout: "itemmouseout", click: "itemclick" }, e.push(i)); for (n = [], a = 0; a < this.mouseoveredObjectMaps.length; a++) { for (s = !0, i = 0; i < e.length; i++)if (e[i].id === this.mouseoveredObjectMaps[a].id) { s = !1; break } s ? this.fireEvent(this.mouseoveredObjectMaps[a], "mouseout", t) : n.push(this.mouseoveredObjectMaps[a]) } for (this.mouseoveredObjectMaps = n, a = 0; a < e.length; a++) { for (n = !1, i = 0; i < this.mouseoveredObjectMaps.length; i++)if (e[a].id === this.mouseoveredObjectMaps[i].id) { n = !0; break } n || (this.fireEvent(e[a], "mouseover", t), this.mouseoveredObjectMaps.push(e[a])), "click" === t.type ? this.fireEvent(e[a], "click", t) : "mousemove" === t.type && this.fireEvent(e[a], "mousemove", t) } } }, G.prototype.fireEvent = function (t, e, a) { if (t && e) { var i = t.eventParameter, n = t.eventContext, s = t.eventContext.userContext; s && n && s[n[e]] && s[n[e]].call(s, i), "mouseout" !== e ? s.cursor && s.cursor !== a.target.style.cursor && (a.target.style.cursor = s.cursor) : (a.target.style.cursor = this.chart._defaultCursor, delete t.eventParameter, delete t.eventContext), "click" === e && "dataPoint" === t.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[t.dataSeriesIndex], i), "click" === e && "dataPoint" === t.objectType && this.chart.funnelPyramidClickHandler && this.chart.funnelPyramidClickHandler.call(this.chart.data[t.dataSeriesIndex], i) } }, Z.prototype.animate = function (t, e, a, i, n) { var s = this; for (this.chart.isAnimating = !0, n = n || tt.easing.linear, a && this.animations.push({ startTime: (new Date).getTime() + (t || 0), duration: e, animationCallback: a, onComplete: i }), t = []; 0 < this.animations.length;)e = this.animations.shift(), a = (new Date).getTime(), i = 0, e.startTime <= a && (i = n(Math.min(a - e.startTime, e.duration), 0, 1, e.duration), i = Math.min(i, 1), isNaN(i) || !isFinite(i)) && (i = 1), 1 > i && t.push(e), e.animationCallback(i), 1 <= i && e.onComplete && e.onComplete(); this.animations = t, 0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, (function () { s.animate.call(s) })) : this.chart.isAnimating = !1 }, Z.prototype.cancelAllAnimations = function () { this.animations = [], this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId), this.animationRequestId = null, this.chart.isAnimating = !1 }; var tt = { yScaleAnimation: function (t, e) { if (0 !== t) { var a = e.dest, i = e.source.canvas, n = e.animationBase; a.drawImage(i, 0, 0, i.width, i.height, 0, n - n * t, a.canvas.width / ct, t * a.canvas.height / ct) } }, xScaleAnimation: function (t, e) { if (0 !== t) { var a = e.dest, i = e.source.canvas, n = e.animationBase; a.drawImage(i, 0, 0, i.width, i.height, n - n * t, 0, t * a.canvas.width / ct, a.canvas.height / ct) } }, xClipAnimation: function (t, e) { if (0 !== t) { var a = e.dest, i = e.source.canvas; a.save(), 0 < t && a.drawImage(i, 0, 0, i.width * t, i.height, 0, 0, i.width * t / ct, i.height / ct), a.restore() } }, fadeInAnimation: function (t, e) { if (0 !== t) { var a = e.dest, i = e.source.canvas; a.save(), a.globalAlpha = t, a.drawImage(i, 0, 0, i.width, i.height, 0, 0, a.canvas.width / ct, a.canvas.height / ct), a.restore() } }, easing: { linear: function (t, e, a, i) { return a * t / i + e }, easeOutQuad: function (t, e, a, i) { return -a * (t /= i) * (t - 2) + e }, easeOutQuart: function (t, e, a, i) { return -a * ((t = t / i - 1) * t * t * t - 1) + e }, easeInQuad: function (t, e, a, i) { return a * (t /= i) * t + e }, easeInQuart: function (t, e, a, i) { return a * (t /= i) * t * t * t + e } } }, et = { drawMarker: function (t, e, a, i, n, s, o, r) { if (a) { var l = 1; a.fillStyle = s || "#000000", a.strokeStyle = o || "#000000", a.lineWidth = r || 0, a.setLineDash && a.setLineDash(g("solid", r)), "circle" === i ? (a.moveTo(t, e), a.beginPath(), a.arc(t, e, n / 2, 0, 2 * Math.PI, !1), s && a.fill(), r && (o ? a.stroke() : (l = a.globalAlpha, a.globalAlpha = .15, a.strokeStyle = "black", a.stroke(), a.globalAlpha = l))) : "square" === i ? (a.beginPath(), a.rect(t - n / 2, e - n / 2, n, n), s && a.fill(), r && (o ? a.stroke() : (l = a.globalAlpha, a.globalAlpha = .15, a.strokeStyle = "black", a.stroke(), a.globalAlpha = l))) : "triangle" === i ? (a.beginPath(), a.moveTo(t - n / 2, e + n / 2), a.lineTo(t + n / 2, e + n / 2), a.lineTo(t, e - n / 2), a.closePath(), s && a.fill(), r && (o ? a.stroke() : (l = a.globalAlpha, a.globalAlpha = .15, a.strokeStyle = "black", a.stroke(), a.globalAlpha = l)), a.beginPath()) : "cross" === i && (a.strokeStyle = s, a.lineWidth = n / 4, a.beginPath(), a.moveTo(t - n / 2, e - n / 2), a.lineTo(t + n / 2, e + n / 2), a.stroke(), a.moveTo(t + n / 2, e - n / 2), a.lineTo(t - n / 2, e + n / 2), a.stroke()) } }, drawMarkers: function (t) { for (var e = 0; e < t.length; e++) { var a = t[e]; et.drawMarker(a.x, a.y, a.ctx, a.type, a.size, a.color, a.borderColor, a.borderThickness) } } }; return a }(), gt.Chart.version = "v2.3.1 GA" }(), document.createElement("canvas").getContext || function () { function t() { return this.context_ || (this.context_ = new d(this)) } function e(t) { return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;") } function a(t) { t.namespaces.g_vml_ || t.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), t.namespaces.g_o_ || t.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML"), t.styleSheets.ex_canvas_ || ((t = t.createStyleSheet()).owningElement.id = "ex_canvas_", t.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}") } function i(t) { var e = t.srcElement; switch (t.propertyName) { case "width": e.getContext().clearRect(), e.style.width = e.attributes.width.nodeValue + "px", e.firstChild.style.width = e.clientWidth + "px"; break; case "height": e.getContext().clearRect(), e.style.height = e.attributes.height.nodeValue + "px", e.firstChild.style.height = e.clientHeight + "px" } } function n(t) { (t = t.srcElement).firstChild && (t.firstChild.style.width = t.clientWidth + "px", t.firstChild.style.height = t.clientHeight + "px") } function s(t, e) { for (var a = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], i = 0; 3 > i; i++)for (var n = 0; 3 > n; n++) { for (var s = 0, o = 0; 3 > o; o++)s += t[i][o] * e[o][n]; a[i][n] = s } return a } function o(t, e) { e.fillStyle = t.fillStyle, e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.shadowBlur = t.shadowBlur, e.shadowColor = t.shadowColor, e.shadowOffsetX = t.shadowOffsetX, e.shadowOffsetY = t.shadowOffsetY, e.strokeStyle = t.strokeStyle, e.globalAlpha = t.globalAlpha, e.font = t.font, e.textAlign = t.textAlign, e.textBaseline = t.textBaseline, e.arcScaleX_ = t.arcScaleX_, e.arcScaleY_ = t.arcScaleY_, e.lineScale_ = t.lineScale_ } function r(t) { var e = t.indexOf("(", 3), a = t.indexOf(")", e + 1); return 4 == (e = t.substring(e + 1, a).split(",")).length && "a" == t.charAt(3) || (e[3] = 1), e } function l(t, e, a) { return Math.min(a, Math.max(e, t)) } function h(t, e, a) { return 0 > a && a++, 1 < a && a--, 1 > 6 * a ? t + 6 * (e - t) * a : 1 > 2 * a ? e : 2 > 3 * a ? t + 6 * (e - t) * (2 / 3 - a) : t } function c(t) { if (t in I) return I[t]; var e, a = 1; if ("#" == (t = String(t)).charAt(0)) e = t; else if (/^rgb/.test(t)) { a = r(t), e = "#"; for (var i, n = 0; 3 > n; n++)i = -1 != a[n].indexOf("%") ? Math.floor(parseFloat(a[n]) / 100 * 255) : +a[n], e += _[l(i, 0, 255)]; a = +a[3] } else if (/^hsl/.test(t)) { if (n = a = r(t), 0 > (e = parseFloat(n[0]) / 360 % 360) && e++, i = l(parseFloat(n[1]) / 100, 0, 1), n = l(parseFloat(n[2]) / 100, 0, 1), 0 == i) i = n = e = n; else { var s = .5 > n ? n * (1 + i) : n + i - n * i, o = 2 * n - s; i = h(o, s, e + 1 / 3), n = h(o, s, e), e = h(o, s, e - 1 / 3) } e = "#" + _[Math.floor(255 * i)] + _[Math.floor(255 * n)] + _[Math.floor(255 * e)], a = a[3] } else e = L[t] || t; return I[t] = { color: e, alpha: a } } function d(t) { this.m_ = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.fillStyle = this.strokeStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", this.miterLimit = 1 * C, this.globalAlpha = 1, this.font = "10px sans-serif", this.textAlign = "left", this.textBaseline = "alphabetic", this.canvas = t; var e = "width:" + t.clientWidth + "px;height:" + t.clientHeight + "px;overflow:hidden;position:absolute", a = t.ownerDocument.createElement("div"); a.style.cssText = e, t.appendChild(a), (e = a.cloneNode(!1)).style.backgroundColor = "red", e.style.filter = "alpha(opacity=0)", t.appendChild(e), this.element_ = a, this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1 } function p(t, e, a, i) { t.currentPath_.push({ type: "bezierCurveTo", cp1x: e.x, cp1y: e.y, cp2x: a.x, cp2y: a.y, x: i.x, y: i.y }), t.currentX_ = i.x, t.currentY_ = i.y } function u(t, e) { var a = (i = c(t.strokeStyle)).color, i = i.alpha * t.globalAlpha, n = t.lineScale_ * t.lineWidth; 1 > n && (i *= n), e.push("<g_vml_:stroke", ' opacity="', i, '"', ' joinstyle="', t.lineJoin, '"', ' miterlimit="', t.miterLimit, '"', ' endcap="', N[t.lineCap] || "square", '"', ' weight="', n, 'px"', ' color="', a, '" />') } function m(t, e, a, i) { var n = t.fillStyle, s = t.arcScaleX_, o = t.arcScaleY_, r = i.x - a.x, l = i.y - a.y; if (n instanceof b) { var h = 0, d = i = 0, p = 0, u = 1; if ("gradient" == n.type_) { h = n.x1_ / s, a = n.y1_ / o; var m = x(t, n.x0_ / s, n.y0_ / o); h = x(t, h, a); 0 > (h = 180 * Math.atan2(h.x - m.x, h.y - m.y) / Math.PI) && (h += 360), 1e-6 > h && (h = 0) } else i = ((m = x(t, n.x0_, n.y0_)).x - a.x) / r, d = (m.y - a.y) / l, r /= s * C, l /= o * C, u = v.max(r, l), p = 2 * n.r0_ / u, u = 2 * n.r1_ / u - p; (s = n.colors_).sort((function (t, e) { return t.offset - e.offset })), o = s.length, m = s[0].color, a = s[o - 1].color, r = s[0].alpha * t.globalAlpha, t = s[o - 1].alpha * t.globalAlpha; l = []; for (var g = 0; g < o; g++) { var f = s[g]; l.push(f.offset * u + p + " " + f.color) } e.push('<g_vml_:fill type="', n.type_, '"', ' method="none" focus="100%"', ' color="', m, '"', ' color2="', a, '"', ' colors="', l.join(","), '"', ' opacity="', t, '"', ' g_o_:opacity2="', r, '"', ' angle="', h, '"', ' focusposition="', i, ",", d, '" />') } else n instanceof y ? r && l && e.push("<g_vml_:fill", ' position="', -a.x / r * s * s, ",", -a.y / l * o * o, '"', ' type="tile"', ' src="', n.src_, '" />') : (n = c(t.fillStyle), e.push('<g_vml_:fill color="', n.color, '" opacity="', n.alpha * t.globalAlpha, '" />')) } function x(t, e, a) { return t = t.m_, { x: C * (e * t[0][0] + a * t[1][0] + t[2][0]) - S, y: C * (e * t[0][1] + a * t[1][1] + t[2][1]) - S } } function g(t, e, a) { isFinite(e[0][0]) && isFinite(e[0][1]) && isFinite(e[1][0]) && isFinite(e[1][1]) && isFinite(e[2][0]) && isFinite(e[2][1]) && (t.m_ = e, a && (t.lineScale_ = P(w(e[0][0] * e[1][1] - e[0][1] * e[1][0])))) } function b(t) { this.type_ = t, this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0, this.colors_ = [] } function y(t, e) { if (!t || 1 != t.nodeType || "IMG" != t.tagName) throw new f("TYPE_MISMATCH_ERR"); if ("complete" != t.readyState) throw new f("INVALID_STATE_ERR"); switch (e) { case "repeat": case null: case "": this.repetition_ = "repeat"; break; case "repeat-x": case "repeat-y": case "no-repeat": this.repetition_ = e; break; default: throw new f("SYNTAX_ERR") }this.src_ = t.src, this.width_ = t.width, this.height_ = t.height } function f(t) { this.code = this[t], this.message = t + ": DOM Exception " + this.code } var v = Math, k = v.round, M = v.sin, T = v.cos, w = v.abs, P = v.sqrt, C = 10, S = C / 2; navigator.userAgent.match(/MSIE ([\d.]+)?/); var A = Array.prototype.slice; a(document); var E = { init: function (t) { (t = t || document).createElement("canvas"), t.attachEvent("onreadystatechange", function (t, e, a) { var i = A.call(arguments, 2); return function () { return t.apply(e, i.concat(A.call(arguments))) } }(this.init_, this, t)) }, init_: function (t) { t = t.getElementsByTagName("canvas"); for (var e = 0; e < t.length; e++)this.initElement(t[e]) }, initElement: function (e) { if (!e.getContext) { e.getContext = t, a(e.ownerDocument), e.innerHTML = "", e.attachEvent("onpropertychange", i), e.attachEvent("onresize", n); var s = e.attributes; s.width && s.width.specified ? e.style.width = s.width.nodeValue + "px" : e.width = e.clientWidth, s.height && s.height.specified ? e.style.height = s.height.nodeValue + "px" : e.height = e.clientHeight } return e } }; E.init(); for (var _ = [], F = 0; 16 > F; F++)for (var B = 0; 16 > B; B++)_[16 * F + B] = F.toString(16) + B.toString(16); var L = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgreen: "#006400", darkgrey: "#A9A9A9", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", grey: "#808080", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgreen: "#90EE90", lightgrey: "#D3D3D3", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", oldlace: "#FDF5E6", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", whitesmoke: "#F5F5F5", yellowgreen: "#9ACD32" }, I = {}, D = {}, N = { butt: "flat", round: "round" }; (F = d.prototype).clearRect = function () { this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null), this.element_.innerHTML = "" }, F.beginPath = function () { this.currentPath_ = [] }, F.moveTo = function (t, e) { var a = x(this, t, e); this.currentPath_.push({ type: "moveTo", x: a.x, y: a.y }), this.currentX_ = a.x, this.currentY_ = a.y }, F.lineTo = function (t, e) { var a = x(this, t, e); this.currentPath_.push({ type: "lineTo", x: a.x, y: a.y }), this.currentX_ = a.x, this.currentY_ = a.y }, F.bezierCurveTo = function (t, e, a, i, n, s) { n = x(this, n, s), p(this, t = x(this, t, e), a = x(this, a, i), n) }, F.quadraticCurveTo = function (t, e, a, i) { t = x(this, t, e), a = x(this, a, i), p(this, i = { x: this.currentX_ + 2 / 3 * (t.x - this.currentX_), y: this.currentY_ + 2 / 3 * (t.y - this.currentY_) }, { x: i.x + (a.x - this.currentX_) / 3, y: i.y + (a.y - this.currentY_) / 3 }, a) }, F.arc = function (t, e, a, i, n, s) { a *= C; var o = s ? "at" : "wa", r = t + T(i) * a - S, l = e + M(i) * a - S; i = t + T(n) * a - S, n = e + M(n) * a - S, r != i || s || (r += .125), t = x(this, t, e), r = x(this, r, l), i = x(this, i, n), this.currentPath_.push({ type: o, x: t.x, y: t.y, radius: a, xStart: r.x, yStart: r.y, xEnd: i.x, yEnd: i.y }) }, F.rect = function (t, e, a, i) { this.moveTo(t, e), this.lineTo(t + a, e), this.lineTo(t + a, e + i), this.lineTo(t, e + i), this.closePath() }, F.strokeRect = function (t, e, a, i) { var n = this.currentPath_; this.beginPath(), this.moveTo(t, e), this.lineTo(t + a, e), this.lineTo(t + a, e + i), this.lineTo(t, e + i), this.closePath(), this.stroke(), this.currentPath_ = n }, F.fillRect = function (t, e, a, i) { var n = this.currentPath_; this.beginPath(), this.moveTo(t, e), this.lineTo(t + a, e), this.lineTo(t + a, e + i), this.lineTo(t, e + i), this.closePath(), this.fill(), this.currentPath_ = n }, F.createLinearGradient = function (t, e, a, i) { var n = new b("gradient"); return n.x0_ = t, n.y0_ = e, n.x1_ = a, n.y1_ = i, n }, F.createRadialGradient = function (t, e, a, i, n, s) { var o = new b("gradientradial"); return o.x0_ = t, o.y0_ = e, o.r0_ = a, o.x1_ = i, o.y1_ = n, o.r1_ = s, o }, F.drawImage = function (t, e) { var a, i, n, s, o, r, l, h; n = t.runtimeStyle.width, s = t.runtimeStyle.height, t.runtimeStyle.width = "auto", t.runtimeStyle.height = "auto"; var c = t.width, d = t.height; if (t.runtimeStyle.width = n, t.runtimeStyle.height = s, 3 == arguments.length) a = arguments[1], i = arguments[2], o = r = 0, l = n = c, h = s = d; else if (5 == arguments.length) a = arguments[1], i = arguments[2], n = arguments[3], s = arguments[4], o = r = 0, l = c, h = d; else { if (9 != arguments.length) throw Error("Invalid number of arguments"); o = arguments[1], r = arguments[2], l = arguments[3], h = arguments[4], a = arguments[5], i = arguments[6], n = arguments[7], s = arguments[8] } var p = x(this, a, i), u = []; if (u.push(" <g_vml_:group", ' coordsize="', 10 * C, ",", 10 * C, '"', ' coordorigin="0,0"', ' style="width:', 10, "px;height:", 10, "px;position:absolute;"), 1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) { var m = []; m.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(p.x / C), ",", "Dy=", k(p.y / C), ""); var g = x(this, a + n, i), b = x(this, a, i + s); a = x(this, a + n, i + s), p.x = v.max(p.x, g.x, b.x, a.x), p.y = v.max(p.y, g.y, b.y, a.y), u.push("padding:0 ", k(p.x / C), "px ", k(p.y / C), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", m.join(""), ", sizingmethod='clip');") } else u.push("top:", k(p.y / C), "px;left:", k(p.x / C), "px;"); u.push(' ">', '<g_vml_:image src="', t.src, '"', ' style="width:', C * n, "px;", " height:", C * s, 'px"', ' cropleft="', o / c, '"', ' croptop="', r / d, '"', ' cropright="', (c - o - l) / c, '"', ' cropbottom="', (d - r - h) / d, '"', " />", "</g_vml_:group>"), this.element_.insertAdjacentHTML("BeforeEnd", u.join("")) }, F.stroke = function (t) { var e = []; e.push("<g_vml_:shape", ' filled="', !!t, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * C, ",", 10 * C, '"', ' stroked="', !t, '"', ' path="'); for (var a = { x: null, y: null }, i = { x: null, y: null }, n = 0; n < this.currentPath_.length; n++) { var s = this.currentPath_[n]; switch (s.type) { case "moveTo": e.push(" m ", k(s.x), ",", k(s.y)); break; case "lineTo": e.push(" l ", k(s.x), ",", k(s.y)); break; case "close": e.push(" x "), s = null; break; case "bezierCurveTo": e.push(" c ", k(s.cp1x), ",", k(s.cp1y), ",", k(s.cp2x), ",", k(s.cp2y), ",", k(s.x), ",", k(s.y)); break; case "at": case "wa": e.push(" ", s.type, " ", k(s.x - this.arcScaleX_ * s.radius), ",", k(s.y - this.arcScaleY_ * s.radius), " ", k(s.x + this.arcScaleX_ * s.radius), ",", k(s.y + this.arcScaleY_ * s.radius), " ", k(s.xStart), ",", k(s.yStart), " ", k(s.xEnd), ",", k(s.yEnd)) }s && ((null == a.x || s.x < a.x) && (a.x = s.x), (null == i.x || s.x > i.x) && (i.x = s.x), (null == a.y || s.y < a.y) && (a.y = s.y), (null == i.y || s.y > i.y) && (i.y = s.y)) } e.push(' ">'), t ? m(this, e, a, i) : u(this, e), e.push("</g_vml_:shape>"), this.element_.insertAdjacentHTML("beforeEnd", e.join("")) }, F.fill = function () { this.stroke(!0) }, F.closePath = function () { this.currentPath_.push({ type: "close" }) }, F.save = function () { var t = {}; o(this, t), this.aStack_.push(t), this.mStack_.push(this.m_), this.m_ = s([[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.m_) }, F.restore = function () { this.aStack_.length && (o(this.aStack_.pop(), this), this.m_ = this.mStack_.pop()) }, F.translate = function (t, e) { g(this, s([[1, 0, 0], [0, 1, 0], [t, e, 1]], this.m_), !1) }, F.rotate = function (t) { var e = T(t); g(this, s([[e, t = M(t), 0], [-t, e, 0], [0, 0, 1]], this.m_), !1) }, F.scale = function (t, e) { this.arcScaleX_ *= t, this.arcScaleY_ *= e, g(this, s([[t, 0, 0], [0, e, 0], [0, 0, 1]], this.m_), !0) }, F.transform = function (t, e, a, i, n, o) { g(this, s([[t, e, 0], [a, i, 0], [n, o, 1]], this.m_), !0) }, F.setTransform = function (t, e, a, i, n, s) { g(this, [[t, e, 0], [a, i, 0], [n, s, 1]], !0) }, F.drawText_ = function (t, a, i, n, s) { var o = this.m_; n = 0; var r, l = 1e3, h = 0, c = []; if (r = this.font, D[r]) r = D[r]; else { var d = document.createElement("div").style; try { d.font = r } catch (b) { } r = D[r] = { style: d.fontStyle || "normal", variant: d.fontVariant || "normal", weight: d.fontWeight || "normal", size: d.fontSize || 10, family: d.fontFamily || "sans-serif" } } d = r; var p = this.element_; for (var g in r = {}, d) r[g] = d[g]; switch (g = parseFloat(p.currentStyle.fontSize), p = parseFloat(d.size), "number" == typeof d.size ? r.size = d.size : -1 != d.size.indexOf("px") ? r.size = p : -1 != d.size.indexOf("em") ? r.size = g * p : -1 != d.size.indexOf("%") ? r.size = g / 100 * p : -1 != d.size.indexOf("pt") ? r.size = p / .75 : r.size = g, r.size *= .981, g = r.style + " " + r.variant + " " + r.weight + " " + r.size + "px " + r.family, p = this.element_.currentStyle, d = this.textAlign.toLowerCase()) { case "left": case "center": case "right": break; case "end": d = "ltr" == p.direction ? "right" : "left"; break; case "start": d = "rtl" == p.direction ? "right" : "left"; break; default: d = "left" }switch (this.textBaseline) { case "hanging": case "top": h = r.size / 1.75; break; case "middle": break; default: case null: case "alphabetic": case "ideographic": case "bottom": h = -r.size / 2.25 }switch (d) { case "right": n = 1e3, l = .05; break; case "center": n = l = 500 }a = x(this, a + 0, i + h), c.push('<g_vml_:line from="', -n, ' 0" to="', l, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !s, '" stroked="', !!s, '" style="position:absolute;width:1px;height:1px;">'), s ? u(this, c) : m(this, c, { x: -n, y: 0 }, { x: l, y: r.size }), s = o[0][0].toFixed(3) + "," + o[1][0].toFixed(3) + "," + o[0][1].toFixed(3) + "," + o[1][1].toFixed(3) + ",0,0", a = k(a.x / C) + "," + k(a.y / C), c.push('<g_vml_:skew on="t" matrix="', s, '" ', ' offset="', a, '" origin="', n, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', e(t), '" style="v-text-align:', d, ";font:", e(g), '" /></g_vml_:line>'), this.element_.insertAdjacentHTML("beforeEnd", c.join("")) }, F.fillText = function (t, e, a, i) { this.drawText_(t, e, a, i, !1) }, F.strokeText = function (t, e, a, i) { this.drawText_(t, e, a, i, !0) }, F.measureText = function (t) { this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild); var e = this.element_.ownerDocument; return this.textMeasureEl_.innerHTML = "", this.textMeasureEl_.style.font = this.font, this.textMeasureEl_.appendChild(e.createTextNode(t)), { width: this.textMeasureEl_.offsetWidth } }, F.clip = function () { }, F.arcTo = function () { }, F.createPattern = function (t, e) { return new y(t, e) }, b.prototype.addColorStop = function (t, e) { e = c(e), this.colors_.push({ offset: t, color: e.color, alpha: e.alpha }) }, (F = f.prototype = Error()).INDEX_SIZE_ERR = 1, F.DOMSTRING_SIZE_ERR = 2, F.HIERARCHY_REQUEST_ERR = 3, F.WRONG_DOCUMENT_ERR = 4, F.INVALID_CHARACTER_ERR = 5, F.NO_DATA_ALLOWED_ERR = 6, F.NO_MODIFICATION_ALLOWED_ERR = 7, F.NOT_FOUND_ERR = 8, F.NOT_SUPPORTED_ERR = 9, F.INUSE_ATTRIBUTE_ERR = 10, F.INVALID_STATE_ERR = 11, F.SYNTAX_ERR = 12, F.INVALID_MODIFICATION_ERR = 13, F.NAMESPACE_ERR = 14, F.INVALID_ACCESS_ERR = 15, F.VALIDATION_ERR = 16, F.TYPE_MISMATCH_ERR = 17, G_vmlCanvasManager = E, CanvasRenderingContext2D = d, CanvasGradient = b, CanvasPattern = y, DOMException = f }() }.call(this, a(105)(t)) }, 748: function (t, e, a) { }, 749: function (t, e, a) { "use strict"; a.r(e); var i = a(18), n = a.n(i), s = a(13), o = a(0), r = a.n(o), l = a(84), h = (a(345), a(309)), c = a(8), d = a(3), p = function (t) { return function (e) { return function (a) { if ((s = a.payload) && "function" === typeof s.then) { t.dispatch({ type: d.m, subtype: a.type }); var i = t.getState().viewChangeCounter, n = a.skipTracking; a.payload.then((function (e) { var s = t.getState(); (n || s.viewChangeCounter === i) && (a.payload = e, t.dispatch({ type: d.l, promise: a.payload }), t.dispatch(a)) }), (function (e) { var s = t.getState(); (n || s.viewChangeCounter === i) && (a.error = !0, a.payload = e.response.body, a.skipTracking || t.dispatch({ type: d.l, promise: a.payload }), t.dispatch(a)) })) } else { var s; e(a) } } } }, u = function (t) { return function (t) { return function (e) { e.type === d.G || e.type === d.v ? e.error || (window.localStorage.setItem("jwt", e.payload.user.token), c.a.setToken(e.payload.user.token)) : e.type === d.x && (window.localStorage.setItem("jwt", ""), c.a.setToken(null)), t(e) } } }; var m = a(48), x = a(4), g = { appName: "Worldsty", token: null, viewChangeCounter: 0 }, b = a(83), y = Object(l.combineReducers)({ article: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.g: return Object(x.a)({}, t, { article: e.payload[0].article, comments: e.payload[1].comments, tickets: JSON.parse(JSON.stringify(e.state ? e.state.tickets : e.payload[0].article.tickets)), contact: {}, totalAmount: e.state ? e.state.totalAmount : 0, articlePageLoaded: !0 }); case d.h: return {}; case d.f: case d.k: return Object(x.a)({}, t, { article: e.payload.article }); case d.a: return Object(x.a)({}, t, { commentErrors: e.error ? e.payload.errors : null, comments: e.error ? null : (t.comments || []).concat([e.payload.comment]) }); case d.p: var a = e.commentId; return Object(x.a)({}, t, { comments: t.comments.filter((function (t) { return t.id !== a })) }); case d.R: return Object(x.a)({}, t, Object(m.a)({}, e.key, e.value)); case d.E: return Object(x.a)({}, t, { purchase: e.payload ? e.payload.purchase : null }); default: return t } }, articleList: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.e: case d.j: return Object(x.a)({}, t, { articles: t.articles.map((function (t) { return t.slug === e.payload.article.slug ? Object(x.a)({}, t, { favorited: e.payload.article.favorited, favoritesCount: e.payload.article.favoritesCount }) : t })), featuredArticles: t.featuredArticles.map((function (t) { return t.slug === e.payload.article.slug ? Object(x.a)({}, t, { favorited: e.payload.article.favorited, favoritesCount: e.payload.article.favoritesCount }) : t })) }); case d.N: return Object(x.a)({}, t, { articles: e.payload.articles, articlesCount: e.payload.articlesCount, currentPage: e.page }); case d.c: return Object(x.a)({}, t, { pager: e.pager, articles: e.payload.articles, articlesCount: e.payload.articlesCount, tab: null, tag: e.tag, currentPage: 0 }); case d.t: return Object(x.a)({}, t, { pager: e.pager, categories: e.payload[0].categories, articles: e.payload[1].articles, articlesCount: e.payload[1].articlesCount, featuredArticles: e.payload[1].featuredArticles, currentPage: 0, tab: e.tab, articleListLoaded: !0 }); case d.u: return {}; case d.n: return Object(x.a)({}, t, { pager: e.pager, articles: e.payload.articles, articlesCount: e.payload.articlesCount, tab: e.tab, currentPage: 0, tag: null }); case d.A: case d.y: return Object(x.a)({}, t, { pager: e.pager, articles: e.payload[1].articles, articlesCount: e.payload[1].articlesCount, currentPage: 0, articleListLoaded: !0 }); case d.B: case d.z: return {}; default: return t } }, auth: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.v: case d.G: return Object(x.a)({}, t, { inProgress: !1, errors: e.error ? e.payload.errors : null }); case d.H: return Object(x.a)({}, t, { categories: e.payload.categories }); case d.w: case d.I: return {}; case d.m: if (e.subtype === d.v || e.subtype === d.G) return Object(x.a)({}, t, { inProgress: !0 }); break; case d.P: return Object(x.a)({}, t, Object(m.a)({}, e.key, e.value)); default: return t }return t }, common: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : g, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.d: return Object(x.a)({}, t, { token: e.token || null, appLoaded: !0, currentUser: e.payload && e.payload[0] ? e.payload[0].user : null, categories: e.payload && e.payload[1] ? e.payload[1].categories : [] }); case d.F: return Object(x.a)({}, t, { redirectTo: null }); case d.x: return Object(x.a)({}, t, { redirectTo: "/", token: null, currentUser: null }); case d.i: var a = "/settings/event/".concat(e.payload.article.slug); return Object(x.a)({}, t, { redirectTo: a }); case d.M: return Object(x.a)({}, t, { currentUser: e.error ? null : e.payload.user }); case d.v: case d.G: return Object(x.a)({}, t, { redirectTo: e.error ? null : e.callback ? e.callback : "/", token: e.error ? null : e.payload.user.token, currentUser: e.error ? null : e.payload.user }); case d.o: return Object(x.a)({}, t, { redirectTo: "/" }); case d.h: case d.r: case d.u: case d.B: case d.z: case d.L: case d.w: case d.I: return Object(x.a)({}, t, { viewChangeCounter: t.viewChangeCounter + 1 }); case d.E: return Object(x.a)({}, t, { currentUser: e.payload.user ? e.payload.user : null, redirectTo: "/purchase/".concat(e.payload.purchase.slug) }); default: return t } }, editor: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.q: return Object(x.a)({}, t, { articleSlug: e.payload ? e.payload.article.slug : "", title: e.payload ? e.payload.article.title : "", description: e.payload ? e.payload.article.description : "", tickets: e.payload ? e.payload.article.tickets : [], category: e.payload ? e.payload.article.category : "", eventDate: e.payload ? e.payload.article.eventDate : "", eventTimeFrom: e.payload ? e.payload.article.eventTimeFrom : "", eventTimeTo: e.payload ? e.payload.article.eventTimeTo : "", photos: e.payload ? e.payload.article.photos : [], locality: e.payload ? e.payload.article.locality : "", province: e.payload ? e.payload.article.province : "", country: e.payload ? e.payload.article.country : "", address: e.payload ? e.payload.article.address : "", latitude: e.payload ? e.payload.article.latitude : "", longitude: e.payload ? e.payload.article.longitude : "", tagInput: "", tagList: e.payload ? e.payload.article.tagList : [], editorPageLoaded: !0 }); case d.r: return {}; case d.i: return Object(x.a)({}, t, { inProgress: null, errors: e.error ? e.payload.errors : null }); case d.m: if (e.subtype === d.i) return Object(x.a)({}, t, { inProgress: !0 }); break; case d.b: return Object(x.a)({}, t, { tagList: t.tagList.concat([t.tagInput]), tagInput: "" }); case d.J: return Object(x.a)({}, t, { tagList: t.tagList.filter((function (t) { return t !== e.tag })) }); case d.Q: return Object(x.a)({}, t, Object(m.a)({}, e.key, e.value)); default: return t }return t }, home: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.t: return Object(x.a)({}, t, { categories: e.payload[0].categories, homePageLoaded: !0 }); case d.u: return {}; default: return t } }, profile: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.A: return Object(x.a)({}, e.payload[0].profile); case d.B: return {}; case d.s: case d.O: return Object(x.a)({}, e.payload.profile); default: return t } }, settings: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.M: return Object(x.a)({}, t, { inProgress: !1, errors: e.error ? e.payload.errors : null }); case d.K: return Object(x.a)({}, t, { inProgress: !1, warning: e.payload.warning }); case d.L: return {}; case d.m: return Object(x.a)({}, t, { inProgress: !0 }); default: return t } }, purchase: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; switch (e.type) { case d.C: return Object(x.a)({}, t, { purchase: e.payload ? e.payload.purchase : null, purchases: e.payload ? e.payload.purchases : [] }); case d.D: return {}; default: return t } }, router: b.d }), f = a(313), v = a.n(f)()(), k = Object(b.c)(v), M = Object(l.createStore)(y, Object(h.composeWithDevTools)(Object(l.applyMiddleware)(k, p, u))), T = a(765), w = a(764), P = (a(371), a(372), a(373), a(223)), C = a(333), S = a(315), A = a(162); P.a.use(C.a).use(S.a).use(A.b).init({ fallbackLng: "en", debug: !0, interpolation: { escapeValue: !1 } }); P.a; var E = a(11), _ = a(12), F = a(15), B = a(14), L = a(334), I = a(335), D = a(22), N = a(218), V = a(319), W = a(320), z = a.n(W), O = function (t) { var e = [{ value: "english", label: r.a.createElement("div", null, r.a.createElement("img", { src: a(396) }), "English") }, { value: "spanish", label: "Spanish" }, { value: "dutch", label: "Dutch" }, { value: "italian", label: "Italian" }, { value: "french", label: "French" }, { value: "portuguese", label: "Portuguese" }, { value: "russian", label: "Russian" }]; return r.a.createElement(N.a, { styles: t.customStylesForSelect, components: { DropdownIndicator: function (t) { return r.a.createElement(D.z.DropdownIndicator, t, r.a.createElement("div", { className: "dropdown-icon" }, r.a.createElement("img", { src: a(397) }))) } }, options: e, defaultValue: [e[0]] }) }, X = function (t) { return t.currentUser ? null : r.a.createElement("ul", { className: "nav navbar-nav" }, r.a.createElement("li", { className: "language-option" }, r.a.createElement(O, { customStylesForSelect: t.customStylesForSelect })), r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { to: "/", className: "nav-link" }, "Help")), r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { to: "/register/company", className: "nav-link" }, "Company")), r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { to: "/register/user", className: "nav-link" }, "Sign in")), r.a.createElement("li", { className: "burger-menu" }, r.a.createElement(V.slide, { right: !0 }, r.a.createElement("a", { id: "help", href: "/" }, "Help"), r.a.createElement("a", { id: "company", href: "/register/company" }, "Company"), r.a.createElement("a", { id: "signin", href: "/register/user" }, "Sign in")))) }, Y = function (t) { return t.currentUser ? r.a.createElement("ul", { className: "nav navbar-nav" }, r.a.createElement("li", { className: "language-option" }, r.a.createElement(O, { customStylesForSelect: t.customStylesForSelect })), r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { to: "/", className: "nav-link" }, r.a.createElement("span", null, "Help"))), r.a.createElement("li", { className: "nav-item" }, r.a.createElement("div", { className: "dropdown" }, r.a.createElement("div", { className: "dropdown-toggle", "data-toggle": "dropdown" }, r.a.createElement("span", null, t.currentUser.fullname), r.a.createElement("img", { src: t.currentUser.image, className: "user-pic", alt: "" })), r.a.createElement("ul", { className: "dropdown-menu user-dropdown" }, r.a.createElement("li", null, "Status : online"), r.a.createElement("li", null, r.a.createElement(L.a, { to: "/settings/info" }, r.a.createElement("p", null, "Settings"))), !t.currentUser.isCompany && r.a.createElement("li", null, r.a.createElement(L.a, { to: "/purchase" }, r.a.createElement("p", null, "My Tickets"))), r.a.createElement("li", { onClick: t.onClickLogout }, "Logout"))))) : null }, R = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).state = { askey: "", customStylesForSelect: {} }, t } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { window.addEventListener("resize", this.handleResize.bind(this)), this.handleResize() } }, { key: "componentWillUnmount", value: function () { window.removeEventListener("resize", this.handleResize.bind(this)) } }, { key: "handleResize", value: function () { var t = this.state.deviceType; window.innerWidth > 1440 ? "desktop-l" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(x.a)({}, t, { border: "none" }) }, control: function (t, e) { return Object(x.a)({}, t, { fontSize: 16, border: "none", outline: "none", minHeight: 20 }) }, indicatorSeparator: function (t, e) { return Object(x.a)({}, t, { display: "none" }) }, input: function (t, e) { return Object(x.a)({}, t, { fontSize: 16 }) }, option: function (t, e) { return Object(x.a)({}, t, { fontSize: 16 }) }, singleValue: function (t, e) { return Object(x.a)({}, t, { fontSize: 16 }) } } }), this.setState({ deviceType: "desktop-l" })) : window.innerWidth > 768 ? "tablet" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(x.a)({}, t, { border: "none" }) }, control: function (t, e) { return Object(x.a)({}, t, { fontSize: 14, border: "none", outline: "none", minHeight: 20 }) }, indicatorSeparator: function (t, e) { return Object(x.a)({}, t, { display: "none" }) }, input: function (t, e) { return Object(x.a)({}, t, { fontSize: 14 }) }, option: function (t, e) { return Object(x.a)({}, t, { fontSize: 14 }) }, singleValue: function (t, e) { return Object(x.a)({}, t, { fontSize: 14 }) } } }), this.setState({ deviceType: "tablet" })) : window.innerWidth > 320 && "mobile" !== t && (this.setState({ customStylesForSelect: { container: function (t, e) { return Object(x.a)({}, t, { border: "none" }) }, control: function (t, e) { return Object(x.a)({}, t, { fontSize: 14, border: "none", outline: "none", minHeight: 20 }) }, indicatorSeparator: function (t, e) { return Object(x.a)({}, t, { display: "none" }) }, input: function (t, e) { return Object(x.a)({}, t, { fontSize: 14 }) }, option: function (t, e) { return Object(x.a)({}, t, { fontSize: 14 }) }, singleValue: function (t, e) { return Object(x.a)({}, t, { fontSize: 14 }) } } }), this.setState({ deviceType: "mobile" })) } }, { key: "render", value: function () { var t = this, e = this.state.customStylesForSelect; return r.a.createElement("nav", { className: "navbar" }, r.a.createElement("div", { className: "nav-left" }, r.a.createElement(L.a, { to: "/", className: "navbar-brand" }, r.a.createElement("img", { src: z.a }))), r.a.createElement("div", { className: "search__block" }, r.a.createElement("input", { className: "form-control advanced-search", type: "text", placeholder: "Search events", value: this.state.askey, onChange: function (e) { return t.setState({ askey: e.target.value }) }, onKeyPress: function (e) { return t.props.advancedSearch(e, t.state.askey) } }), r.a.createElement("div", { className: "search__btn" }, r.a.createElement("i", { className: "fa fa-search", "aria-hidden": "true" }))), r.a.createElement(X, { currentUser: this.props.currentUser, customStylesForSelect: e }), r.a.createElement(Y, { currentUser: this.props.currentUser, onClickLogout: this.props.onClickLogout, onClickSettting: function () { return t.props.history.push("/settings/info") }, customStylesForSelect: e })) } }]), a }(r.a.Component), j = Object(I.a)(R), U = (a(398), a(399), a(400), a(401), a(402), a(403), a(404), function (t) { Object(F.a)(i, t); var e = Object(B.a)(i); function i() { var t; return Object(E.a)(this, i), (t = e.call(this)).state = { language: "english" }, t } return Object(_.a)(i, [{ key: "render", value: function () { this.props.location.pathname; return r.a.createElement("div", { className: "footer" }, r.a.createElement("div", { className: "footer-sides" }, r.a.createElement("div", { className: "footer-side-menu" }, r.a.createElement("div", { className: "logo-img" }, r.a.createElement("img", { src: a(405), alt: "logo" })), r.a.createElement("div", { className: "footer-side-panel social" }, r.a.createElement("p", null, "Contact With Us"), r.a.createElement("ul", null, r.a.createElement("li", { className: "footer-item" }, r.a.createElement("a", { href: "mailto:info@worldsty.com", target: "blank" }, r.a.createElement("i", { className: "fa fa-envelope" }))), r.a.createElement("li", { className: "footer-item" }, r.a.createElement("a", { href: "https://facebook.com", target: "blank" }, r.a.createElement("i", { className: "fa fa-facebook-f" }))), r.a.createElement("li", { className: "footer-item" }, r.a.createElement("a", { href: "https://www.linkedin.com/company/worldsty", target: "blank" }, r.a.createElement("i", { className: "fa fa-linkedin" }))), r.a.createElement("li", { className: "footer-item" }, r.a.createElement("a", { href: "https://instagram.com", target: "blank" }, r.a.createElement("i", { className: "fa fa-instagram" }))), r.a.createElement("li", { className: "footer-item" }, r.a.createElement("a", { href: "https://twitter.com/Worldsty", target: "blank" }, r.a.createElement("i", { className: "fa fa-twitter" }))))), r.a.createElement("div", { className: "download-app" }, r.a.createElement("div", { className: "googleplay-btn" }, r.a.createElement("img", { src: a(406), alt: "googleplay" })), r.a.createElement("div", { className: "appstore-btn" }, r.a.createElement("img", { src: a(407), alt: "appstore" })))), r.a.createElement("div", { className: "footer-side-menu" }, r.a.createElement("div", { className: "footer-side-panel" }, r.a.createElement("p", null, "Use Worldsty"), r.a.createElement("ul", null, r.a.createElement("li", { className: "footer-item" }, "How it works"), r.a.createElement("li", { className: "footer-item" }, "For large and small business"), r.a.createElement("li", { className: "footer-item" }, "Pricing"), r.a.createElement("li", { className: "footer-item" }, "Advanced software"), r.a.createElement("li", { className: "footer-item" }, "Mobile app"), r.a.createElement("li", { className: "footer-item" }, "Sitemap"), r.a.createElement("li", { className: "footer-item" }, "FAQs")))), r.a.createElement("div", { className: "footer-side-menu" }, r.a.createElement("div", { className: "footer-side-panel" }, r.a.createElement("p", null, "Plan Events"), r.a.createElement("ul", null, r.a.createElement("li", { className: "footer-item" }, "Festivals"), r.a.createElement("li", { className: "footer-item" }, "Night Club"), r.a.createElement("li", { className: "footer-item" }, "Beach Club"), r.a.createElement("li", { className: "footer-item" }, "Pubs"), r.a.createElement("li", { className: "footer-item" }, "Bars"), r.a.createElement("li", { className: "footer-item" }, "Concerts"), r.a.createElement("li", { className: "footer-item" }, "Live Music")))), r.a.createElement("div", { className: "footer-side-menu" }, r.a.createElement("div", { className: "footer-side-panel" }, r.a.createElement("p", null, "Find Events"), r.a.createElement("ul", null, r.a.createElement("li", { className: "footer-item" }, "Dublin events"), r.a.createElement("li", { className: "footer-item" }, "Pricing"), r.a.createElement("li", { className: "footer-item" }, "Advanced software"), r.a.createElement("li", { className: "footer-item" }, "Mobile app"), r.a.createElement("li", { className: "footer-item" }, "Sitemap"), r.a.createElement("li", { className: "footer-item" }, "FAQs"))))), r.a.createElement("div", { className: "footer-center-menu" }, r.a.createElement("div", { className: "footer-menu" }, r.a.createElement("p", null, "@2020 Worldsty"), r.a.createElement("ul", null, r.a.createElement("li", { className: "footer-item" }, "About"), r.a.createElement("li", { className: "footer-item" }, "Blog"), r.a.createElement("li", { className: "footer-item" }, "Investors"), r.a.createElement("li", { className: "footer-item" }, "Security"), r.a.createElement("li", { className: "footer-item" }, "Careers"), r.a.createElement("li", { className: "footer-item" }, "Cookies"), r.a.createElement("li", { className: "footer-item" }, "Privacy"), r.a.createElement("li", { className: "footer-item" }, "Terms"))))) } }]), i }(r.a.Component)), H = Object(I.a)(U), q = Object(s.b)((function () { return {} }), (function (t) { return { onClickDelete: function (e) { return t({ type: d.o, payload: e }) } } }))((function (t) { var e = t.article; return t.canModify ? r.a.createElement("div", { className: "article-actions" }, r.a.createElement(L.a, { to: "/settings/event/".concat(e.slug), className: "btn btn-outline-secondary btn-sm" }, "Edit")) : r.a.createElement("span", null) })), G = a(149), Z = a.n(G), J = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).state = { body: "", rating: 0 }, t.setBody = function (e) { t.setState({ body: e.target.value }) }, t.createComment = function (e) { if (e.preventDefault(), "" != t.state.body) { var a = c.a.Comments.create(t.props.slug, { body: t.state.body, rating: t.state.rating }); t.setState({ body: "", rating: 0 }), t.props.onSubmit(a), t.props.onClose() } }, t.ratingChanged = function (e) { t.setState({ rating: e }) }, t } return Object(_.a)(a, [{ key: "render", value: function () { var t = this; return r.a.createElement("form", { className: "card comment-form", onSubmit: this.createComment }, r.a.createElement("div", { className: "card-footer" }, r.a.createElement("div", { className: "card-left" }, r.a.createElement(L.a, { to: "/@".concat(this.props.currentUser.username), className: "comment-author" }, r.a.createElement("img", { src: this.props.currentUser.image, className: "comment-author-img", alt: "" }), this.props.currentUser.username), r.a.createElement(Z.a, { value: this.state.rating, count: 5, onChange: this.ratingChanged, size: 18, half: !0, emptyIcon: r.a.createElement("i", { className: "far fa-star" }), halfIcon: r.a.createElement("i", { className: "fa fa-star-half-alt" }), fullIcon: r.a.createElement("i", { className: "fa fa-star" }), color2: "#ffd700" })), r.a.createElement("div", { className: "card-right" })), r.a.createElement("div", { className: "card-block" }, r.a.createElement("textarea", { className: "form-control", placeholder: "Write a review...", value: this.state.body, onChange: this.setBody, rows: "9" })), r.a.createElement("div", { className: "card-btns" }, r.a.createElement("button", { className: "btn", type: "button", onClick: function () { return t.props.onClose() } }, "Close"), r.a.createElement("button", { className: "btn", type: "submit" }, "Submit"))) } }]), a }(r.a.Component), K = (Object(s.b)((function () { return {} }), (function (t) { return { onSubmit: function (e) { return t({ type: d.a, payload: e }) } } }))(J), Object(s.b)((function () { return {} }), (function (t) { return { onClick: function (e, a) { return t({ type: d.p, payload: e, commentId: a }) } } }))((function (t) { return t.show ? r.a.createElement("span", { className: "mod-options" }, r.a.createElement("i", { className: "ion-trash-a", onClick: function () { var e = c.a.Comments.delete(t.slug, t.commentId); t.onClick(e, t.commentId) } })) : null })), a(322)), Q = a.n(K), $ = a(150), tt = a.n($), et = (a(410), a(151)), at = a(153), it = a(16), nt = a.n(it), st = a(27), ot = a.n(st), rt = a(168), lt = a(30), ht = a(169), ct = (a(297), a(298), a(644), Object(rt.withGoogleMap)((function (t) { return r.a.createElement(rt.GoogleMap, { defaultZoom: 8, defaultCenter: { lat: t.lat, lng: t.lng } }, r.a.createElement(rt.Marker, { position: { lat: t.lat, lng: t.lng } })) }))), dt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).state = { buy: !1, delete: !1 }, t.handleClick = function (e) { t.props.history.push("/t/" + e) }, t.onScroll = function () { ot()(window).scrollTop() > 540 ? (ot()(".article__top__ctrls__wrapper").addClass("jumper"), ot()(".article__top__ctrls__wrapper .article__ctrls__wrapper").addClass("container")) : (ot()(".article__top__ctrls__wrapper").removeClass("jumper"), ot()(".article__top__ctrls__wrapper .article__ctrls__wrapper").removeClass("container")) }, t.handleClickFavorite = function (e) { var a = t.props.article; e.preventDefault(), t.props.currentUser ? a.favorited ? t.props.unfavorite(a.slug) : t.props.favorite(a.slug) : t.props.history.push("/login") }, t.deleteArticle = function () { t.props.onClickDelete(c.a.Articles.del(t.props.article.slug)) }, t.onPaypalResponse = function (t, e) { console.log("~~~~~~~~~~`", t, e) }, t.onChangeVolumn = function (e, a) { var i = 0, n = t.props.tickets.map((function (t) { return t._id === e._id && (t.volumn = parseFloat(a)), t.volumn && "" !== t.volumn && (i += t.price * t.volumn), t })); t.props.onUpdateField("tickets", n), t.props.onUpdateField("totalAmount", i), t.setState({ pocket: !0 }) }, t.onChangeContact = function (e, a) { var i = t.props.contact; i[e] = a, t.props.onUpdateField(i, a), t.setState({ contact: !0 }) }, t.purchaseTicket = function (e) { return function (a) { a.preventDefault(); var i = { tickets: t.props.tickets, contact: t.props.currentUser || t.props.contact, amount: t.props.totalAmount }, n = !1; return i.tickets.map((function (t) { t.volumn && t.volumn > 0 && (n = !0) })), n ? i.contact == {} ? (t.props.history.push(e + "#ticket-auth"), !0) : void t.props.onPurchaseTicket(c.a.Articles.purchaseTicket(t.props.article.slug, i)) : (alert("please choose 1 ticket at least"), t.props.history.push(e + "#ticket"), !0) } }, t.viewTicket = function (e) { var a = "/purchase/" + e.slug; t.props.history.push(a) }, t.onClickContinueAsGuest = function (e) { return function (a) { a.preventDefault(), t.props.history.push(e + "#ticket-info") } }, t.onClickToAuth = function (e) { var a = !1; t.props.tickets.map((function (t) { t.volumn && t.volumn > 0 && (a = !0) })), a ? t.props.history.push(e + (t.props.currentUser ? "#ticket-info" : "#ticket-auth")) : alert("please choose 1 ticket at least") }, t.exportPdf = function () { }, t } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { var t = null; this.props.location.state && (t = this.props.location.state), this.props.onLoad(Promise.all([c.a.Articles.get(this.props.match.params.id), c.a.Comments.forArticle(this.props.match.params.id)]), t), ot()("html, body").animate({ scrollTop: 0 }, 0), window.addEventListener("scroll", this.onScroll) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload(), window.removeEventListener("scroll", this.onScroll) } }, { key: "render", value: function () { var t = this; if (!this.props.article) return null; this.props.articlePageLoaded; var e = this.props.article, a = { __html: Q()(this.props.article.description || "", { sanitize: !0 }) }, i = this.props.currentUser && (this.props.currentUser.username === this.props.article.author.username || "supergsdev101" === this.props.currentUser.username), n = this.props.article.photos && this.props.article.photos.map((function (t) { return { original: t, thumbnail: t } })), s = window.location.href, o = this.props.article.photos && this.props.article.photos.length > 0 && this.props.article.photos[0], l = e.favorited ? "fa fa-heart" : "fa fa-heart-o", h = "/event/" + this.props.article.slug, c = this.props.currentUser || this.props.contact, d = !this.props.currentUser || this.props.currentUser && !this.props.currentUser.isCompany; if (this.props.location.hash) { var p = this.props.location.hash, u = this.props.purchase; return r.a.createElement("div", { className: "article-page" }, r.a.createElement("div", { className: "article-listing-header" }, r.a.createElement("img", { src: o })), r.a.createElement("div", { className: "container" }, r.a.createElement("div", { className: "buy__ticket__wrapper" }, r.a.createElement("div", { className: "b__t__header" }, r.a.createElement("h4", null, e.title), r.a.createElement("p", null, e.eventDate, "  From ", e.eventTimeFrom, " To ", e.eventTimeTo)), "#ticket" == p && r.a.createElement("div", { className: "b__t__content" }, this.props.tickets.map((function (e) { return r.a.createElement("div", { className: "b__t__item row" }, r.a.createElement("div", { className: "b__t__desc col-md-7 col-xs-4" }, r.a.createElement("p", null, r.a.createElement("strong", null, e.name))), r.a.createElement("div", { className: "b__t__price col-md-3 col-xs-5" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Price"), " : \xa0 ", e.isFree ? "Free" : "$" + e.price)), r.a.createElement("div", { className: "b__t__quantity col-md-2 col-xs-3" }, r.a.createElement("input", { className: "form-control", type: "number", placeholder: "0", value: e.volumn, min: "0", step: "1", max: e.quantity, onChange: function (a) { return t.onChangeVolumn(e, a.target.value) } }))) })), r.a.createElement("div", { className: "b__t__item total row" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Total Price"), ": \xa0 $ ", Math.floor(this.props.totalAmount))), r.a.createElement("div", { className: "b__t__ctrls" }, r.a.createElement("button", { className: "btn btn-black", onClick: function () { return t.props.history.push(h) } }, "Back"), r.a.createElement("button", { className: "btn btn-red", onClick: function () { return t.onClickToAuth(h) } }, "Next"))), "#ticket-auth" == p && r.a.createElement("div", { className: "b__t__content" }, r.a.createElement("form", { onSubmit: this.onClickContinueAsGuest(h) }, r.a.createElement("div", { className: "b__t__item row" }, r.a.createElement("div", { className: "col-md-6 b__t__field" }, r.a.createElement("p", null, "Full name"), r.a.createElement("input", { type: "text", className: "form-control", placeholder: "", value: c.fullname, onChange: function (e) { return t.onChangeContact("fullname", e.target.value) }, required: !0 })), r.a.createElement("div", { className: "col-md-6 b__t__field" }, r.a.createElement("p", null, "Phone Number"), r.a.createElement("input", { type: "text", className: "form-control", placeholder: "", value: c.phone, onChange: function (e) { return t.onChangeContact("phone", e.target.value) }, required: !0 }))), r.a.createElement("div", { className: "b__t__item row" }, r.a.createElement("div", { className: "col-md-8 b__t__field" }, r.a.createElement("p", null, "Email"), r.a.createElement("input", { type: "email", className: "form-control", placeholder: "", value: c.email, onChange: function (e) { return t.onChangeContact("email", e.target.value) }, required: !0 })), r.a.createElement("div", { className: "col-md-4 b__t__field" }, r.a.createElement("p", null, "Date of Birth"), r.a.createElement("input", { className: "form-control", type: "date", placeholder: "Birthday", value: c.birthday, onChange: function (e) { return t.onChangeContact("birthday", e.target.value) } }))), r.a.createElement("div", { className: "b__t__item b__t__auth" }, r.a.createElement("p", { className: "b__t__login" }, "Have an account?", r.a.createElement("a", { href: "javascript:avoid(0)", onClick: function () { return t.props.history.push({ pathname: "/login", state: { callback: h + "#ticket-info", tickets: t.props.tickets, totalAmount: t.props.totalAmount } }) } }, "Log in")), r.a.createElement("p", { className: "b__t__register" }, r.a.createElement("strong", null, "Register now"), " and accumulate 523 points that you can redeem later on to enjoy amazing experiences. Accumulate points each time you buy and redeem them for free drink, free tickets and more..")), r.a.createElement("div", { className: "b__t__item total row" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Total Price"), ": \xa0 $ ", Math.floor(this.props.totalAmount))), r.a.createElement("div", { className: "b__t__ctrls" }, r.a.createElement("button", { className: "btn btn-black", type: "button", onClick: function () { return t.props.history.push(h + "#ticket") } }, "Back"), r.a.createElement("button", { className: "btn btn-red", type: "submit" }, "Continue as guest")))), "#ticket-info" === p && r.a.createElement("div", { className: "b__t__content" }, r.a.createElement("div", { className: "b__t__item" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Full name"), c.fullname)), r.a.createElement("div", { className: "b__t__item" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Email"), c.email)), r.a.createElement("div", { className: "b__t__item" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Date of Birth"), c.birthday)), r.a.createElement("div", { className: "b__t__item" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Phone Number"), c.phone)), r.a.createElement("div", { className: "b__t__item total row" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Total Price"), ": \xa0 $ ", Math.floor(this.props.totalAmount))), r.a.createElement("div", { className: "b__t__ctrls" }, r.a.createElement("button", { className: "btn btn-black", onClick: function () { return t.props.history.push(h + (t.props.currentUser ? "#ticket" : "#ticket-auth")) } }, "Back"), r.a.createElement("button", { className: "btn btn-red", onClick: function () { return t.props.history.push(h + "#ticket-pay") } }, "Pay"))), "#ticket-pay" === p && r.a.createElement("div", { className: "b__t__content" }, r.a.createElement("form", { onSubmit: this.purchaseTicket(h) }, r.a.createElement("div", { className: "credit__card" }, r.a.createElement("div", { className: "b__t__item row" }, r.a.createElement("div", { className: "b__t__field col-md-12" }, r.a.createElement("p", null, "Credit card holder name"), r.a.createElement("input", { type: "text", className: "form-control", placeholder: "Card holder name", required: !0 }))), r.a.createElement("div", { className: "b__t__item row" }, r.a.createElement(ht.Number, { masked: !0, onChange: console.log.bind(console, "Number.onChange"), cardTypes: this.state.restrictAmex ? ["americanExpress"] : [], render: function (t) { t.value, t.valid, t.type; var e = t.getInputProps; return r.a.createElement("div", { className: "b__t__field col-md-12" }, r.a.createElement("p", null, "Number"), r.a.createElement("input", Object.assign({}, e(), { className: "form-control", required: !0 }))) } })), r.a.createElement("div", { className: "b__t__item row" }, r.a.createElement(ht.Expiration, { onChange: console.log.bind(console, "Expiration.onChange"), render: function (t) { var e = t.getInputProps; t.value, t.valid, t.error, t.month, t.year; return r.a.createElement("div", { className: "b__t__field col-md-6" }, r.a.createElement("p", null, "Expiration"), r.a.createElement("input", Object.assign({}, e(), { className: "form-control", required: !0 }))) } }), r.a.createElement(ht.Cvc, { masked: this.state.maskedCvc, onChange: console.log.bind(console, "Cvc.onChange"), cardType: this.state.restrictAmex ? "americanExpress" : void 0, render: function (t) { var e = t.getInputProps; t.value, t.valid; return r.a.createElement("div", { className: "b__t__field col-md-6" }, r.a.createElement("p", null, "Cvc"), r.a.createElement("input", Object.assign({}, e(), { className: "form-control", rqeuired: !0 }))) } }))), r.a.createElement("div", { className: "b__t__item total row" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Total Price"), ": \xa0 $ ", Math.floor(this.props.totalAmount))), r.a.createElement("div", { className: "b__t__ctrls" }, r.a.createElement("button", { className: "btn btn-black", type: "button", onClick: function () { return t.props.history.push(h + "#ticket-info") } }, "Back"), r.a.createElement("button", { className: "btn btn-red", type: "submit" }, "Pay now")))), "#purchased" === p && r.a.createElement("div", { className: "b__t__content" }, u && r.a.createElement(r.a.Fragment, null, r.a.createElement("div", { className: "b__t__item purchased" }, r.a.createElement("p", null, "Thanks for your order! \xa0 #", u.slug)), r.a.createElement("div", { className: "b__t__item b__t__contact" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Tickets sent to"), u.contact.email), r.a.createElement("p", null, r.a.createElement("strong", null, "Date"), lt(u.createdAt).format("YYYY-MM-DD, H:mm:ss")), r.a.createElement("p", null, r.a.createElement("strong", null, "Category"), u.article.category), r.a.createElement("p", null, r.a.createElement("strong", null, "Location"), u.article.locality, ", ", u.article.country))), r.a.createElement("div", { className: "b__t__ctrls" }, r.a.createElement("button", { onClick: function () { return t.exportPdf() }, className: "btn btn-red" }, "Print"), r.a.createElement("button", { className: "btn", onClick: function () { return t.viewTicket(u) } }, "View tickets")))))) } return r.a.createElement("div", { className: "article-page" }, r.a.createElement("div", { className: "article-listing-header" }, r.a.createElement("img", { src: o })), r.a.createElement("div", { className: "container" }, r.a.createElement("div", { className: "banner" }, r.a.createElement("div", { className: "article__primary__info__wrapper" }, r.a.createElement("div", { className: "photos__wrapper" }, r.a.createElement(tt.a, { items: n, autoPlay: !0, slideInterval: 5e3, showPlayButton: !1, slideDuration: 500, showBullets: !0, showThumbnails: !1, showFullscreenButton: !1 })), r.a.createElement("div", { className: "article__info" }, r.a.createElement("div", null, r.a.createElement("div", { className: "p__date" }, r.a.createElement("p", { className: "p__month" }, lt(this.props.article.eventDate).format("ddd, D MMM"), ", ", this.props.article.eventTimeFrom, " - ", this.props.article.eventTimeTo, " ")), this.props.currentUser && this.props.currentUser.isCompany && r.a.createElement(q, { canModify: i, article: this.props.article, onDelete: function () { return t.setState({ delete: !0 }) } }), r.a.createElement("div", { className: "article-header" }, r.a.createElement("h1", null, this.props.article.title, " "), r.a.createElement("h3", null, "by ", this.props.article.author.fullname))))), r.a.createElement("div", { className: "article__top__ctrls__wrapper" }, r.a.createElement("div", { className: "article__ctrls__wrapper" }, r.a.createElement("div", { className: "lc__wrapper" }, r.a.createElement("div", { className: "share-block" }, r.a.createElement("span", null, "Share with friends"), r.a.createElement(et.a, { title: this.props.title, shareLink: s })), r.a.createElement("div", { className: "favorite-block" }, r.a.createElement("span", null, this.props.article.favoritesCount, " likes"), r.a.createElement("label", { onClick: this.handleClickFavorite }, r.a.createElement("i", { className: l, "aria-hidden": "true" })))), r.a.createElement("div", { className: "rc__wrapper" }, d && r.a.createElement("button", { className: "btn buy-ticket-btn", onClick: function () { return t.props.history.push(h + "#ticket") } }, "Tickets"))))), r.a.createElement("div", { className: "article-content" }, r.a.createElement("div", { className: "detail-block-wrapper" }, r.a.createElement("div", { className: "detail-block-left" }, r.a.createElement("div", { className: "desc-block block" }, r.a.createElement("h5", null, "Description"), r.a.createElement("div", { dangerouslySetInnerHTML: a, className: "company-description" })), r.a.createElement("div", { className: "tag-block block" }, r.a.createElement("h5", null, "Tags"), r.a.createElement("ul", { className: "tag-list" }, this.props.article.tagList.map((function (e) { return r.a.createElement("li", { className: "tag-default tag-pill tag-outline", key: e, onClick: function () { return t.handleClick(e) } }, e) }))))), r.a.createElement("div", { className: "detail-block-right" }, r.a.createElement("div", { className: "event-time-block block" }, r.a.createElement("h5", null, "Date of event"), r.a.createElement("p", null, this.props.article.eventDate, " From ", this.props.article.eventTimeFrom, " To ", this.props.article.eventTimeTo)), this.props.article.category && r.a.createElement("div", { className: "category-block block" }, r.a.createElement("h5", null, "Category"), r.a.createElement("p", null, this.props.article.category)))), r.a.createElement("div", { className: "google-map-block" }, r.a.createElement(ct, { containerElement: r.a.createElement("div", { style: { height: "360px" } }), mapElement: r.a.createElement("div", { style: { height: "100%" } }), lat: this.props.article.latitude || this.props.article.author.latitude || 0, lng: this.props.article.longitude || this.props.article.author.longitude || 0 })), r.a.createElement("div", { className: "contact-block block" }, r.a.createElement("h5", null, this.props.article.author.fullname), r.a.createElement("p", null, "at"), r.a.createElement("h5", null, this.props.article.address || this.props.article.author.address)))), r.a.createElement("div", { className: nt()("w__modal__wrapper", this.state.delete && "opened") }, r.a.createElement("div", { className: "w__modal delete__block" }, r.a.createElement("div", { className: "w__modal__header" }, r.a.createElement("h3", null, "Delete event"), r.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.setState({ delete: !1 }) } })), r.a.createElement("div", { className: "w__modal__content" }, r.a.createElement("p", null, "Are you sure?")), r.a.createElement("div", { className: "w__modal__footer" }, r.a.createElement("button", { className: "btn btn-outline-primary btn-sm", onClick: function () { return t.setState({ delete: !1 }) } }, "No"), r.a.createElement("button", { className: "btn btn-outline-danger btn-sm", onClick: function () { return t.deleteArticle() } }, "Yes")))), r.a.createElement("div", { className: nt()("w__modal__wrapper", this.props.location.hash && "opened") }, r.a.createElement("div", { className: "w__modal" }, r.a.createElement("div", { className: "w__modal__header" }, r.a.createElement("h3", null, "Thank you for your purchasing"), r.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.props.history.push("/event/" + e.slug) } })), r.a.createElement("div", { className: "w__modal__content" }, r.a.createElement(at.QRCode, { bgColor: "#FFFFFF", fgColor: "#000000", level: "Q", style: { width: 256 }, value: this.props.article.id + "-" + (this.props.currentUser && this.props.currentUser.id) }))))) } }]), a }(r.a.Component), pt = Object(s.b)((function (t) { return Object(x.a)({}, t.article, { currentUser: t.common.currentUser }) }), (function (t) { return { onLoad: function (e, a) { return t({ type: d.g, payload: e, state: a }) }, onUnload: function () { return t({ type: d.h }) }, onClickTag: function (e, a, i) { return t({ type: d.c, tag: e, pager: a, payload: i }) }, favorite: function (e) { return t({ type: d.f, payload: c.a.Articles.favorite(e) }) }, unfavorite: function (e) { return t({ type: d.k, payload: c.a.Articles.unfavorite(e) }) }, onClickDelete: function (e) { return t({ type: d.o, payload: e }) }, onUpdateField: function (e, a) { return t({ type: d.R, key: e, value: a }) }, onPurchaseTicket: function (e) { return t({ type: d.E, payload: e }) } } }))(dt), ut = a(61), mt = a(58), xt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { return Object(E.a)(this, a), e.apply(this, arguments) } return Object(_.a)(a, [{ key: "render", value: function () { var t = this.props.errors; return t ? r.a.createElement("ul", { className: "error-messages" }, Object.keys(t).map((function (e) { return r.a.createElement("li", { key: e }, e, " ", t[e]) }))) : null } }]), a }(r.a.Component), gt = a(154), bt = a.n(gt), yt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; Object(E.a)(this, a), t = e.call(this); var i = Object(mt.a)(t); return t.changeEmail = function (e) { return t.props.onChangeEmail(e.target.value) }, t.changePassword = function (e) { return t.props.onChangePassword(e.target.value) }, t.submitForm = function (t, e) { return function (a) { a.preventDefault(); var n = c.a.Auth.login(t, e); n.then((function (e) { e.errors ? i.props.history.push({ pathname: "/email-confirmation", state: { email: t } }) : i.props.location.state && i.props.location.state.callback ? i.props.onSubmit(n, i.props.location.state.callback) : i.props.onSubmit(n) })).catch((function (t) { i.props.onSubmit(n) })) } }, t.responseFacebook = function (e) { if (e.id) { var a = c.a.Auth.facebookAuth(e); t.props.location.state && t.props.location.state.callback ? t.props.onSubmit(a, t.props.location.state.callback) : t.props.onSubmit(a), t.props.onSubmit(a) } }, t } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { ot()("html, body").animate({ scrollTop: 0 }, 0) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "render", value: function () { this.props.currentUser && this.props.history.push({ hash: "#ticket-info", pathname: this.props.location.state && this.props.location.state.callback ? this.props.location.state.callback : "/", state: this.props.location.state }); var t = this.props.email, e = this.props.password; return r.a.createElement("div", { className: "auth-page login" }, r.a.createElement("div", { className: "container page" }, r.a.createElement("div", { className: "row" }, r.a.createElement("div", { className: "col-md-12 col-xs-12" }, r.a.createElement("h1", { className: "auth-sub-header1" }, "Let's get started"), r.a.createElement("p", { className: "text-xs-center auth-sub-header2" }, "Use Facebook or email to get started"), r.a.createElement(xt, { errors: this.props.errors }), r.a.createElement("form", { onSubmit: this.submitForm(t, e) }, r.a.createElement("fieldset", null, r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "email", placeholder: "Email", value: t, onChange: this.changeEmail })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "password", placeholder: "Password", value: e, onChange: this.changePassword })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("button", { className: "btn form-control", type: "submit", disabled: this.props.inProgress }, "Sign in")))), r.a.createElement("p", { className: "separator" }, "or"), r.a.createElement("fieldset", null, r.a.createElement(bt.a, { appId: "2136840116623024", callback: this.responseFacebook, render: function (t) { return r.a.createElement("button", { onClick: t.onClick, className: "btn facebook" }, r.a.createElement("i", { className: "fa fa-facebook-square", "aria-hidden": "true" }), r.a.createElement("span", null, "Continue with Facebook")) } })), r.a.createElement("p", { className: "text-xs-center auth-sub-header3" }, r.a.createElement(L.a, { to: "/register/user" }, "Need an account?")))))) } }]), a }(r.a.Component), ft = Object(s.b)((function (t) { return Object(x.a)({}, t.auth, { currentUser: t.common.currentUser }) }), (function (t) { return { onChangeEmail: function (e) { return t({ type: d.P, key: "email", value: e }) }, onChangePassword: function (e) { return t({ type: d.P, key: "password", value: e }) }, onSubmit: function (e, a) { return t({ type: d.v, payload: e, callback: a }) }, onUnload: function () { return t({ type: d.w }) } } }))(yt), vt = a(141), kt = function (t) { return t.isUser ? r.a.createElement(L.a, { to: "/settings", className: "btn btn-sm btn-outline-secondary action-btn" }, r.a.createElement("i", { className: "ion-gear-a" }), " Edit Profile Settings") : null }, Mt = function (t) { if (t.isUser) return null; var e = "btn btn-sm action-btn"; t.user.following ? e += " btn-secondary" : e += " btn-outline-secondary"; return r.a.createElement("button", { className: e, onClick: function (e) { e.preventDefault(), t.user.following ? t.unfollow(t.user.username) : t.follow(t.user.username) } }, r.a.createElement("i", { className: "ion-plus-round" }), "\xa0", t.user.following ? "Unfollow" : "Follow", " ", t.user.username) }, Tt = function (t) { return Object(x.a)({}, t.articleList, { currentUser: t.common.currentUser, profile: t.profile }) }, wt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { return Object(E.a)(this, a), e.apply(this, arguments) } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { this.props.onLoad(Promise.all([c.a.Profile.get(this.props.match.params.username), c.a.Articles.favoritedBy(this.props.match.params.username)])), ot()("html, body").animate({ scrollTop: 0 }, 0) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "renderTabs", value: function () { return r.a.createElement("ul", { className: "nav nav-pills outline-active" }, r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { className: "nav-link", to: "/@".concat(this.props.profile.username, "/favorites") }, "Favorited Articles"))) } }, { key: "render", value: function () { var t = this.props.profile; if (!t) return null; var e = this.props.currentUser && this.props.profile.username === this.props.currentUser.username; return r.a.createElement("div", { className: "profile-page" }, r.a.createElement("div", { className: "user-info" }, r.a.createElement("div", { className: "container" }, r.a.createElement("div", { className: "row" }, r.a.createElement("div", { className: "col-xs-12 col-md-10 offset-md-1" }, r.a.createElement("img", { src: t.image, className: "user-img", alt: "" }), r.a.createElement("h4", null, t.username), r.a.createElement("p", null, t.bio), r.a.createElement(kt, { isUser: e }), r.a.createElement(Mt, { isUser: e, user: t, follow: this.props.onFollow, unfollow: this.props.onUnfollow }))))), r.a.createElement("div", { className: "container" }, r.a.createElement("div", { className: "row" }, this.props.articleListLoaded && r.a.createElement("div", { className: "col-xs-12 col-md-12 article-list" }, r.a.createElement("h2", null, "Likes"), r.a.createElement(vt.a, { pager: this.props.pager, articles: this.props.articles, articlesCount: this.props.articlesCount, state: this.props.currentPage }))))) } }]), a }(r.a.Component), Pt = Object(s.b)(Tt, (function (t) { return { onFollow: function (e) { return t({ type: d.s, payload: c.a.Profile.follow(e) }) }, onLoad: function (e) { return t({ type: d.A, payload: e }) }, onUnfollow: function (e) { return t({ type: d.O, payload: c.a.Profile.unfollow(e) }) }, onUnload: function () { return t({ type: d.B }) } } }))(wt), Ct = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { return Object(E.a)(this, a), e.apply(this, arguments) } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { var t = this; this.props.onLoad((function (e) { return c.a.Articles.favoritedBy(t.props.match.params.username, e) }), Promise.all([c.a.Profile.get(this.props.match.params.username), c.a.Articles.favoritedBy(this.props.match.params.username)])) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "renderTabs", value: function () { return r.a.createElement("ul", { className: "nav nav-pills outline-active" }, r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { className: "nav-link", to: "/@".concat(this.props.profile.username) }, "My Articles")), r.a.createElement("li", { className: "nav-item" }, r.a.createElement(L.a, { className: "nav-link active", to: "/@".concat(this.props.profile.username, "/favorites") }, "Favorited Articles"))) } }]), a }(wt), St = Object(s.b)(Tt, (function (t) { return { onLoad: function (e, a) { return t({ type: d.A, pager: e, payload: a }) }, onUnload: function () { return t({ type: d.B }) } } }))(Ct), At = a(67), Et = (a(203), function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; Object(E.a)(this, a), t = e.call(this); var i = Object(mt.a)(t); return t.state = { startDate: "" }, t.submitForm = function () { return function (e) { e.preventDefault(); var a = { email: t.props.email, fullname: t.props.fullname, username: t.props.username, birthday: t.props.birthday, phone: t.props.phone, password: t.props.password, category: t.props.category, role: t.props.match.params.role, photos: t.props.photos, locality: t.props.locality, province: t.props.province, country: t.props.country, address: t.props.address, latitude: t.props.latitude, longitude: t.props.longitude, description: t.props.companyDescription }, n = c.a.Auth.register(a); n.then((function (e) { i.props.history.push({ pathname: "/email-confirmation", state: { email: t.props.email } }) })).catch((function (e) { t.props.onSubmit(n) })) } }, t.handleSelectedFile = function (e) { var a = new FormData, i = Object(mt.a)(t), n = e[0]; e.target && (n = e.target.files[0]), a.append("fname", "comment"), a.append("data", n), c.a.Articles.uploadPhoto(a).then((function (t) { var e = i.props.photos; void 0 === e && (e = []), e.push(t.data.photo), i.props.onUpdateField("photos", e), i.setState({ isUploadig: !1 }) })) }, t.deletePhoto = function (e) { var a = t.props.photos; a = a.filter((function (t) { return t != e })), t.props.onUpdateField("photos", a) }, t.parseLocation = function (e) { var a = "", i = "", n = ""; if (void 0 != e) { for (var s = 0; s < e.gmaps.address_components.length; s++) { var o = e.gmaps.address_components[s]; switch (o.types[0]) { case "locality": a = o.long_name; break; case "administrative_area_level_1": i = o.long_name; break; case "country": n = o.long_name } } t.props.onUpdateField("locality", a), t.props.onUpdateField("province", i), t.props.onUpdateField("country", n) } }, t.parseAddress = function (e) { void 0 != e && (t.props.onUpdateField("latitude", e ? e.location.lat : null), t.props.onUpdateField("longitude", e ? e.location.lng : null), t.props.onUpdateField("address", e ? e.description : null)) }, t.responseFacebook = function (e) { if (e.id) { var a = c.a.Auth.facebookAuth(e); t.props.onSubmit(a) } }, t } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { ot()("html, body").animate({ scrollTop: 0 }, 0) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "render", value: function () { var t = this; this.props.currentUser && this.props.history.push("/"); var e = this.props.match.params.role; return r.a.createElement("div", { className: "auth-page register" }, r.a.createElement("div", { className: "container page" }, r.a.createElement("div", { className: "auth-photos" }, r.a.createElement("div", { className: "auth-photo-1" }), r.a.createElement("div", { className: "auth-photo-2" })), r.a.createElement("div", { className: "auth-wrapper" }, r.a.createElement("div", { className: "auth-form" }, r.a.createElement("h2", { className: "auth-sub-header1" }, "worldsty"), r.a.createElement("p", { className: "auth-sub-header2" }, "Sign up to see the best disccounts, places and get your tickets."), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement(bt.a, { appId: "2136840116623024", callback: this.responseFacebook, render: function (t) { return r.a.createElement("button", { onClick: t.onClick, className: "btn facebook" }, r.a.createElement("i", { className: "fa fa-facebook-square", "aria-hidden": "true" }), r.a.createElement("span", null, "Continue with Facebook")) } })), r.a.createElement("p", { className: "separator" }, r.a.createElement("span", null, "or")), r.a.createElement("form", { onSubmit: this.submitForm() }, r.a.createElement("fieldset", { className: "input-group" }, r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "email", placeholder: "Email", value: this.props.email, onChange: function (e) { return t.props.onUpdateField("email", e.target.value) }, required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "text", placeholder: "company" === e ? "Company name" : "Full name", value: this.props.fullname, onChange: function (e) { return t.props.onUpdateField("fullname", e.target.value) }, required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "text", placeholder: "Username", value: this.props.username, onChange: function (e) { return t.props.onUpdateField("username", e.target.value) }, required: !0 })), "company" === e && r.a.createElement(o.Fragment, null, r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement(At.a, { placeholder: "City, Country", inputClassName: "form-control", skipSuggest: function (t) { return t.types.indexOf("locality") < 0 || t.types.indexOf("political") < 0 }, onSuggestSelect: function (e) { return t.parseLocation(e) } }))), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "password", placeholder: "Password", value: this.props.password, onChange: function (e) { return t.props.onUpdateField("password", e.target.value) }, required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control", type: "password", placeholder: "Re-enter password", value: this.props.rePassword, onChange: function (e) { return t.props.onUpdateField("rePassword", e.target.value) }, required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("button", { className: "btn submit-btn", type: "submit", disabled: this.props.inProgress }, "Sign up")))), r.a.createElement(xt, { errors: this.props.errors }), r.a.createElement("p", { className: "auth-sub-header3" }, "By signing up, you agree to our Terms . Learn how we collect, use and share your data in our Data Policy and how we use cookies and similar technology in our Cookies Policy.")), r.a.createElement("div", { className: "rediect-form" }, r.a.createElement("p", null, "Have an account?"), r.a.createElement(L.a, { to: "/login" }, "Login")), r.a.createElement("div", { className: "mobile-apps" }, r.a.createElement("p", null, "Get the app"), r.a.createElement("div", { className: "mobile-photos" }, r.a.createElement("div", { className: "mobile-photo1" }), r.a.createElement("div", { className: "mobile-photo2" })))))) } }]), a }(r.a.Component)), _t = Object(s.b)((function (t) { return Object(x.a)({}, t.auth, { currentUser: t.common.currentUser, categories: t.common.categories }) }), (function (t) { return { onUpdateField: function (e, a) { return t({ type: d.P, key: e, value: a }) }, onSubmit: function (e) { t({ type: d.G, payload: e }) }, onLoad: function () { var e = c.a.Articles.getAll(); t({ type: d.H, payload: e }) }, onUnload: function () { return t({ type: d.I }) } } }))(Et), Ft = function (t) { return Object(x.a)({}, t.purchase, { currentUser: t.common.currentUser }) }, Bt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).exportPdf = function () { }, t } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { this.props.match.params.slug ? this.props.onLoad(c.a.Purchases.get(this.props.match.params.slug)) : this.props.onLoad(c.a.Purchases.getAll()) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "componentWillReceiveProps", value: function (t) { t.match.params.slug && this.props.match.params.slug !== t.match.params.slug && this.props.onLoad(c.a.Purchases.get(t.match.params.slug)) } }, { key: "render", value: function () { var t = this, e = this.props.purchase, a = this.props.purchases; return a && a.length > 0 ? r.a.createElement("div", { className: "purchases-page" }, r.a.createElement("div", { className: "container" }, r.a.createElement("h2", { className: "page-title" }, "My Purchases"), r.a.createElement("table", { className: "table table-striped table-hover" }, r.a.createElement("thead", null, r.a.createElement("tr", null, r.a.createElement("th", null, "Order No"), r.a.createElement("th", null, "Date"), r.a.createElement("th", null, "Status"), r.a.createElement("th", null, "Details"))), r.a.createElement("tbody", null, a.map((function (e) { return r.a.createElement("tr", null, r.a.createElement("td", null, e.slug), r.a.createElement("td", null, e.createdAt), r.a.createElement("td", null, e.status ? "Pending" : "Accepted"), r.a.createElement("td", { className: "p__info", onClick: function () { return t.props.history.push("/purchase/".concat(e.slug)) } }, r.a.createElement("i", { className: "fa fa-info-circle", "aria-hidden": "true" }))) })))))) : r.a.createElement("div", { className: "article-page" }, r.a.createElement("div", { className: "container", id: "capture" }, e ? r.a.createElement("div", { className: "buy__ticket__wrapper" }, r.a.createElement("div", { className: "b__t__header" }, r.a.createElement("h4", null, e.article.title), r.a.createElement("p", null, e.article.eventDate, "  From ", e.article.eventTimeFrom, " To ", e.article.eventTimeTo)), r.a.createElement("div", { className: "b__t__content" }, r.a.createElement("div", { className: "b__t__item purchased" }, r.a.createElement("p", null, "Order No \xa0 #", e.slug)), r.a.createElement("div", { className: "b__t__item" }, r.a.createElement("div", { className: "b__t__contact" }, r.a.createElement("p", null, r.a.createElement("strong", null, "Tickets sent to"), r.a.createElement("span", null, e.contact.email)), r.a.createElement("p", null, r.a.createElement("strong", null, "Date"), r.a.createElement("span", null, lt(e.createdAt).format("YYYY-MM-DD, H:mm:ss"))), r.a.createElement("p", null, r.a.createElement("strong", null, "Category"), r.a.createElement("span", null, e.article.category)), r.a.createElement("p", null, r.a.createElement("strong", null, "Location"), r.a.createElement("span", null, e.article.locality, ", ", e.article.country))), r.a.createElement("div", { className: "b__t__contact" }, r.a.createElement(at.QRCode, { bgColor: "#FFFFFF", fgColor: "#000000", level: "Q", style: { width: 128 }, value: "https://worldsty.com/purchase/" + e.slug }))), r.a.createElement("div", { className: "b__t__ctrls" }, this.props.currentUser && r.a.createElement("button", { className: "btn", onClick: function () { return t.props.history.push("/purchase") } }, "My Tickets"), r.a.createElement("button", { className: "btn", onClick: function () { return t.props.history.push("/") } }, "Continue")))) : r.a.createElement("div", { className: "buy__ticket__wrapper" }, r.a.createElement("div", { className: "b__t__content" }, r.a.createElement("div", { className: "b__t__ctrls" }, r.a.createElement("button", { className: "btn", onClick: function () { return t.props.history.push("/") } }, "Continue")))))) } }]), a }(r.a.Component), Lt = Object(s.b)((function () { return Ft }), (function (t) { return { onLoad: function (e) { return t({ type: d.C, payload: e }) }, onUnload: function () { return t({ type: d.D }) } } }))(Bt), It = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).state = { image: "", username: "", fullname: "", bio: "", email: "", phone: "", password: "", birthday: "", isCompany: "", locality: "", province: "", address: "", country: "", latitude: "", longitude: "", photos: "", category: "" }, t.updateState = function (e) { return function (a) { var i = t.state, n = Object.assign({}, i, Object(m.a)({}, e, a.target.value)); t.setState(n) } }, t.submitForm = function (e) { e.preventDefault(); var a = Object.assign({}, t.state); a.password || delete a.password, t.props.onSubmitForm(a), t.props.updateSettingsStatus() }, t.changePassword = function (e) { e.preventDefault(); var a = { email: t.state.email, password: t.state.password, newPassword: t.state.newPassword, confirmPassword: t.state.confirmPassword }; t.props.onChangePassword(a) }, t.handleSelectedFile = function (e) { var a = new FormData, i = Object(mt.a)(t), n = e[0]; e.target && (n = e.target.files[0]), a.append("fname", "comment"), a.append("data", n), c.a.Auth.uploadPhoto(a).then((function (t) { i.setState({ image: t.data.photo }) })) }, t.parseLocation = function (e) { var a = "", i = "", n = ""; if (void 0 != e) { for (var s = 0; s < e.gmaps.address_components.length; s++) { var o = e.gmaps.address_components[s]; switch (o.types[0]) { case "locality": a = o.long_name; break; case "administrative_area_level_1": i = o.long_name; break; case "country": n = o.long_name } } t.setState({ locality: a, province: i, country: n }) } }, t.parseAddress = function (e) { void 0 != e && t.setState({ latitude: e ? e.location.lat : null, longitude: e ? e.location.lng : null, address: e.description }) }, t } return Object(_.a)(a, [{ key: "componentWillMount", value: function () { this.props.currentUser && Object.assign(this.state, { image: this.props.currentUser.image || "", username: this.props.currentUser.username, fullname: this.props.currentUser.fullname, birthday: this.props.currentUser.birthday, bio: this.props.currentUser.bio, email: this.props.currentUser.email, phone: this.props.currentUser.phone, isCompany: this.props.currentUser.isCompany, locality: this.props.currentUser.locality, province: this.props.currentUser.province, address: this.props.currentUser.address, country: this.props.currentUser.country, latitude: this.props.currentUser.latitude, longitude: this.props.currentUser.longitude, photos: this.props.currentUser.photos || [], category: this.props.currentUser.category }), ot()("html, body").animate({ scrollTop: 0 }, 0) } }, { key: "componentWillReceiveProps", value: function (t) { t.currentUser && this.setState(Object.assign({}, this.state, { image: t.currentUser.image || "", username: t.currentUser.username, fullname: t.currentUser.fullname, birthday: t.currentUser.birthday, bio: t.currentUser.bio, email: t.currentUser.email, phone: t.currentUser.phone, isCompany: t.currentUser.isCompany, locality: t.currentUser.locality, province: t.currentUser.province, address: t.currentUser.address, country: t.currentUser.country, latitude: t.currentUser.latitude, longitude: t.currentUser.longitude, photos: t.currentUser.photos || [], category: t.currentUser.category })) } }, { key: "render", value: function () { var t = this, e = (this.state.locality || "") + ", " + (this.state.country || ""); return ", " === e && (e = ""), "overview" === this.props.tab ? r.a.createElement("form", { onSubmit: this.submitForm }, r.a.createElement(xt, { errors: this.props.errors }), r.a.createElement("div", { className: "user-photo" }, r.a.createElement("img", { src: this.state.image, alt: "" }), r.a.createElement("label", { htmlFor: "add-user-photo", className: nt()("add-user-photo", this.state.image && "hide") }, r.a.createElement("input", { type: "file", id: "add-user-photo", accept: "image/*", onChange: function (e) { return t.handleSelectedFile(e) } }))), r.a.createElement("div", { className: "user-form" }, r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "text", placeholder: "Full name", value: this.state.fullname, onChange: this.updateState("fullname"), required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "text", placeholder: "Username", value: this.state.username, onChange: this.updateState("username"), required: !0 })), r.a.createElement("fieldset", { className: "form-group calendar-field" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "date", placeholder: "Birthday", value: this.state.birthday, onChange: this.updateState("birthday") })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "text", placeholder: "Phone number", value: this.state.phone, onChange: this.updateState("phone") })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "email", placeholder: "Email", value: this.state.email, onChange: this.updateState("email"), required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("textarea", { className: "form-control form-control-lg", rows: "8", placeholder: "Short bio about you", value: this.state.bio, onChange: this.updateState("bio") })), this.props.currentUser && this.props.currentUser.isCompany && r.a.createElement(o.Fragment, null, r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement(At.a, { placeholder: "In which city your company located ?", inputClassName: "form-control form-control-lg", initialValue: e, skipSuggest: function (t) { return t.types.indexOf("locality") < 0 || t.types.indexOf("political") < 0 }, onSuggestSelect: function (e) { return t.parseLocation(e) } })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement(At.a, { placeholder: "Enter your company's full address", inputClassName: "form-control form-control-lg", initialValue: this.state.address, onChange: function (e) { return t.setState({ address: e }) }, onSuggestSelect: function (e) { return t.parseAddress(e) } })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("select", { className: "form-control form-control-lg", onChange: this.updateState("category") }, r.a.createElement("option", { value: "" }, "Category"), this.props.categories && this.props.categories.map((function (e) { return r.a.createElement("option", { value: e.name, selected: t.state.category === e.name }, e.name) }))))), r.a.createElement("button", { className: "btn pull-xs-right", type: "submit", disabled: this.state.inProgress }, "Save"))) : "changePassword" === this.props.tab ? r.a.createElement("form", { onSubmit: this.changePassword, className: "change-password" }, r.a.createElement("div", null, r.a.createElement(xt, { errors: this.props.warning }), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "password", placeholder: "Current password", value: this.state.password, onChange: this.updateState("password"), required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "password", placeholder: "New password", value: this.state.newPassword, onChange: this.updateState("newPassword"), required: !0 })), r.a.createElement("fieldset", { className: "form-group" }, r.a.createElement("input", { className: "form-control form-control-lg", type: "password", placeholder: "Comfirm password", value: this.state.confirmPassword, onChange: this.updateState("confirmPassword"), required: !0 })), r.a.createElement("button", { className: "btn pull-xs-right", type: "submit", disabled: this.state.inProgress }, "Save"))) : r.a.createElement("form", null, r.a.createElement("h6", null, "Not available yet.")) } }]), a }(r.a.Component), Dt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).state = { tab: "overview", save: !1 }, t.updateSettingsStatus = function () { t.setState({ save: !0 }) }, t } return Object(_.a)(a, [{ key: "render", value: function () { var t = this; return this.props.currentUser || this.props.history.push("/"), this.props.currentUser && this.props.currentUser.isCompany ? r.a.createElement("div", { className: "settings-page" }, r.a.createElement("div", { className: "" }, r.a.createElement("div", { className: "c__h__header" }, r.a.createElement("h4", null, "Settings")), r.a.createElement("div", { className: "c__h__content container page" }, r.a.createElement("div", { className: "settings-sidebar" }, r.a.createElement("div", { className: nt()("settings-sidebar-item", "overview" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "overview" }) } }, "Overview"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "changePassword" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "changePassword" }) } }, "Password")), r.a.createElement("div", { className: "settings-content" }, r.a.createElement(It, { currentUser: this.props.currentUser, onSubmitForm: this.props.onSubmitForm, onChangePassword: this.props.onChangePassword, warning: this.props.warning, errors: this.props.errors, categories: this.props.categories, tab: this.state.tab, updateSettingsStatus: this.updateSettingsStatus })))), r.a.createElement("div", { className: nt()("w__modal__wrapper", this.state.save && "opened") }, r.a.createElement("div", { className: "w__modal delete__block" }, r.a.createElement("div", { className: "w__modal__header" }, r.a.createElement("h3", null, "Alert"), r.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.setState({ save: !1 }) } })), r.a.createElement("div", { className: "w__modal__content" }, r.a.createElement("p", null, "Saved successfully.")), r.a.createElement("div", { className: "w__modal__footer" }, r.a.createElement("button", { className: "btn", onClick: function () { return t.setState({ save: !1 }) } }, "Ok"))))) : r.a.createElement("div", { className: "settings-page" }, r.a.createElement("div", { className: "container page" }, r.a.createElement("div", { className: "settings-sidebar" }, r.a.createElement("div", { className: nt()("settings-sidebar-item", "overview" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "overview" }) } }, "Overview"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "changePassword" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "changePassword" }) } }, "Password"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "paymentMethod" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "paymentMethod" }) } }, "Payment method"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "notifications" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "notifications" }) } }, "Notifications"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "history" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "history" }) } }, "History"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "followedCompanies" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "followedCompanies" }) } }, "Followed companies"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "savedEvents" === this.state.tab && "active"), onClick: function () { return t.setState({ tab: "savedEvents" }) } }, "Saved events"), r.a.createElement("div", { className: nt()("settings-sidebar-item", "logout" === this.state.tab && "active"), onClick: this.props.onClickLogout }, "Logout")), r.a.createElement("div", { className: "settings-content" }, r.a.createElement("div", { className: "rewards-block" }, r.a.createElement("h4", null, "Rewards ", r.a.createElement("strong", null, "$", this.props.currentUser && Math.floor(this.props.currentUser.rewards)))), r.a.createElement(It, { currentUser: this.props.currentUser, onSubmitForm: this.props.onSubmitForm, onChangePassword: this.props.onChangePassword, warning: this.props.warning, errors: this.props.errors, categories: this.props.categories, tab: this.state.tab, updateSettingsStatus: this.updateSettingsStatus })), r.a.createElement("div", { className: nt()("w__modal__wrapper", this.state.save && "opened") }, r.a.createElement("div", { className: "w__modal delete__block" }, r.a.createElement("div", { className: "w__modal__header" }, r.a.createElement("h3", null, "Alert"), r.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.setState({ save: !1 }) } })), r.a.createElement("div", { className: "w__modal__content" }, r.a.createElement("p", null, "Saved successfully.")), r.a.createElement("div", { className: "w__modal__footer" }, r.a.createElement("button", { className: "btn", onClick: function () { return t.setState({ save: !1 }) } }, "Ok")))))) } }]), a }(r.a.Component), Nt = Object(s.b)((function (t) { return Object(x.a)({}, t.settings, { currentUser: t.common.currentUser, categories: t.common.categories }) }), (function (t) { return { onClickLogout: function () { return t({ type: d.x }) }, onSubmitForm: function (e) { return t({ type: d.M, payload: c.a.Auth.save(e) }) }, onChangePassword: function (e) { return t({ type: d.K, payload: c.a.Auth.resetPassword(e) }) }, onUnload: function () { return t({ type: d.L }) } } }))(Dt), Vt = a(222), Wt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { return Object(E.a)(this, a), e.call(this) } return Object(_.a)(a, [{ key: "render", value: function () { var t = this.props.location.pathname; return r.a.createElement("div", { className: "company-board-sidebar" }, r.a.createElement("ul", null, r.a.createElement(L.a, { to: "/settings/home" }, r.a.createElement("li", { className: (t.indexOf("/home") > -1 || t.indexOf("/event") > -1) && "active" }, r.a.createElement("i", { className: "fa fa-home", "aria-hidden": "true" }), r.a.createElement("span", null, "Home"))), r.a.createElement(L.a, { to: "/settings/dashboard" }, r.a.createElement("li", { className: "/settings/dashboard" == t && "active" }, r.a.createElement("i", { className: "fa fa-bar-chart", "aria-hidden": "true" }), r.a.createElement("span", null, "Dashboard"))), r.a.createElement(L.a, { to: "/settings/calendar" }, r.a.createElement("li", { className: "/settings/calendar" == t && "active" }, r.a.createElement("i", { className: "fa fa-calendar", "aria-hidden": "true" }), r.a.createElement("span", null, "Calendar"))), r.a.createElement(L.a, { to: "/settings/inbox" }, r.a.createElement("li", { className: "/settings/inbox" == t && "active" }, r.a.createElement("i", { className: "fa fa-envelope", "aria-hidden": "true" }), r.a.createElement("span", null, "Inbox"))), r.a.createElement(L.a, { to: "/settings/products" }, r.a.createElement("li", { className: "/settings/products" == t && "active" }, r.a.createElement("i", { className: "fa fa-ticket", "aria-hidden": "true" }), r.a.createElement("span", null, "Products"))), r.a.createElement(L.a, { to: "/settings/invoices" }, r.a.createElement("li", { className: "/settings/invoices" == t && "active" }, r.a.createElement("i", { className: "fa fa-bookmark", "aria-hidden": "true" }), r.a.createElement("span", null, "Invoices"))), r.a.createElement(L.a, { to: "/settings/customers" }, r.a.createElement("li", { className: "/settings/customers" == t && "active" }, r.a.createElement("i", { className: "fa fa-user", "aria-hidden": "true" }), r.a.createElement("span", null, "Customers"))), r.a.createElement(L.a, { to: "/settings/chatroom" }, r.a.createElement("li", { className: "/settings/chatroom" == t && "active" }, r.a.createElement("i", { className: "fa fa-comments-o", "aria-hidden": "true" }), r.a.createElement("span", null, "Chat Room"))), r.a.createElement(L.a, { to: "/settings/helpcenter" }, r.a.createElement("li", { className: "/settings/helpcenter" == t && "active" }, r.a.createElement("i", { className: "fa fa-question-circle", "aria-hidden": "true" }), r.a.createElement("span", null, "Help Center"))), r.a.createElement(L.a, { to: "/settings/info" }, r.a.createElement("li", { className: "/settings/info" == t && "active" }, r.a.createElement("i", { className: "fa fa-cogs", "aria-hidden": "true" }), r.a.createElement("span", null, "Settings"))))) } }]), a }(r.a.Component), zt = Object(I.a)(Wt), Ot = a(328), Xt = a(329), Yt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; Object(E.a)(this, a), (t = e.call(this)).state = { stage: 1, save: !1, delete: !1 }; var i = function (e) { return function (a) { return t.props.onUpdateField(e, a.target.value) } }; return t.changeTitle = i("title"), t.changeDescription = i("description"), t.changeCategory = i("category"), t.changeTagInput = i("tagInput"), t.changeEventDate = i("eventDate"), t.changeEventTimeFrom = i("eventTimeFrom"), t.changeEventTimeTo = i("eventTimeTo"), t.watchForEnter = function (e) { 13 === e.keyCode && "" !== e.target.value && (e.preventDefault(), t.props.onAddTag()) }, t.removeTagHandler = function (e) { return function () { t.props.onRemoveTag(e) } }, t.submitForm = function (e) { return function (a) { if (a.preventDefault(), "previous" == e) 1 == t.state.stage ? t.setState({ stage: 1 }) : t.setState({ stage: t.state.stage - 1 }); else { if (1 == t.state.stage && ("" === t.props.title || "" === t.props.eventDate)) return alert("You should fill the forms."), !0; if (2 == t.state.stage && 0 === t.props.tickets.length) return alert("You should add 1 ticket at least."), !0; if (3 == t.state.stage) { var i = { title: t.props.title, description: t.props.description, eventDate: t.props.eventDate, eventTimeFrom: t.props.eventTimeFrom, eventTimeTo: t.props.eventTimeTo, category: t.props.category, tickets: t.props.tickets, tagList: t.props.tagList, photos: t.props.photos, locality: t.props.locality, province: t.props.province, country: t.props.country, address: t.props.address, latitude: t.props.latitude, longitude: t.props.longitude }; if (0 === t.props.tickets.length) alert("You should add 1 ticket at least."); else { var n = { slug: t.props.articleSlug }, s = t.props.articleSlug ? c.a.Articles.update(Object.assign(i, n)) : c.a.Articles.create(i); t.props.onSubmit(s), t.setState({ save: !0 }) } } else t.setState({ stage: t.state.stage + 1 }) } } }, t.deletePhoto = function (e) { var a = t.props.photos; a = a.filter((function (t) { return t != e })), t.props.onUpdateField("photos", a) }, t.handleSelectedFileCompany = function (e) { var a = new FormData, i = Object(mt.a)(t), n = e[0]; e.target && (n = e.target.files[0]), a.append("fname", "comment"), a.append("data", n), c.a.Articles.uploadPhoto(a).then((function (t) { var e = i.props.photos || []; e.push(t.data.photo), i.props.onUpdateField("photos", e), i.setState({ pending: !0 }) })) }, t.addMoreTicket = function () { var e = t.props.tickets; e.push({ name: "", price: 0, quantity: 0, isFree: !1 }), t.props.onUpdateField("tickets", e), t.setState({ tk: !0 }) }, t.removeTicket = function (e) { var a = t.props.tickets.filter((function (t, a) { return e !== a })); t.props.onUpdateField("tickets", a), t.setState({ tk: !0 }) }, t.updateTickets = function (e, a, i) { var n = t.props.tickets.map((function (t, n) { return e == n && (t[a] = i), t })); t.props.onUpdateField("tickets", n), t.setState({ tk: !0 }) }, t.onClickDelete = function (e) { t.props.onClickDelete(c.a.Articles.del(e)) }, t.parseLocation = function (e) { var a = "", i = "", n = ""; if (void 0 != e) { for (var s = 0; s < e.gmaps.address_components.length; s++) { var o = e.gmaps.address_components[s]; switch (o.types[0]) { case "locality": a = o.long_name; break; case "administrative_area_level_1": i = o.long_name; break; case "country": n = o.long_name } } t.props.onUpdateField("locality", a), t.props.onUpdateField("province", i), t.props.onUpdateField("country", n) } }, t.parseAddress = function (e) { void 0 != e && (t.props.onUpdateField("latitude", e ? e.location.lat : null), t.props.onUpdateField("longitude", e ? e.location.lng : null), t.props.onUpdateField("address", e ? e.description : null)) }, t } return Object(_.a)(a, [{ key: "componentWillReceiveProps", value: function (t) { this.props.match.params.slug !== t.match.params.slug && t.match.params.slug && this.props.onLoad(c.a.Articles.get(t.match.params.slug)) } }, { key: "componentWillMount", value: function () { if (this.props.match.params.slug) return this.props.onLoad(c.a.Articles.get(this.props.match.params.slug)); this.props.onLoad(null), ot()("html, body").animate({ scrollTop: 0 }, 0) } }, { key: "componentWillUnmount", value: function () { this.props.onUnload() } }, { key: "render", value: function () { var t = this, e = this.props.photos && this.props.photos.map((function (t) { return { original: t, thumbnail: t } })), a = (this.props.locality || "") + ", " + (this.props.country || ""); return ", " === a && (a = ""), this.props.editorPageLoaded ? r.a.createElement("div", { className: "company-editor-page" }, r.a.createElement("div", { className: "c__h__header" }, r.a.createElement("i", { className: "fa fa-chevron-left page__back", "aria-hidden": "true", onClick: function () { return t.props.history.push("/settings/home") } }), r.a.createElement("div", null, this.props.articleSlug && r.a.createElement(r.a.Fragment, null, r.a.createElement(L.a, { to: "/event/".concat(this.props.articleSlug), className: "btn btn-black" }, r.a.createElement("i", { className: "fa fa-eye", "aria-hidden": "true" }), "View"), r.a.createElement("button", { className: "btn btn-danger", onClick: function () { return t.setState({ delete: !0 }) } }, r.a.createElement("i", { className: "fa fa-minus-circle", "aria-hidden": "true" }), "Delete")))), r.a.createElement("div", { className: "c__h__content container page" }, r.a.createElement(xt, { errors: this.props.errors }), 1 == this.state.stage && r.a.createElement("div", { className: "row event_stage" }, r.a.createElement("div", { className: "col-md-7 col-xs-12" }, r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Name of the Event *"), r.a.createElement("input", { id: "title", className: "form-control", type: "text", placeholder: "Event name", value: this.props.title, onChange: this.changeTitle, required: !0 })), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Description"), r.a.createElement("textarea", { className: "form-control", rows: "8", placeholder: "Description", value: this.props.description, onChange: this.changeDescription })), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "City and Country"), r.a.createElement(At.a, { placeholder: "Location", inputClassName: "form-control", initialValue: a, skipSuggest: function (t) { return t.types.indexOf("locality") < 0 || t.types.indexOf("political") < 0 }, onSuggestSelect: function (e) { return t.parseLocation(e) } })), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Full Address"), r.a.createElement(At.a, { placeholder: "Address", inputClassName: "form-control", initialValue: this.props.address, onChange: function (e) { return t.props.onUpdateField("address", e) }, onSuggestSelect: function (e) { return t.parseAddress(e) } })), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Date of the Event *"), r.a.createElement("input", { className: "form-control", type: "date", placeholder: "Event hours", value: this.props.eventDate, onChange: this.changeEventDate, required: !0 })), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Time Range"), r.a.createElement("div", { className: "event__time" }, r.a.createElement("span", null, "From"), r.a.createElement("input", { className: "form-control time-picker", type: "time", placeholder: "", value: this.props.eventTimeFrom, onChange: this.changeEventTimeFrom, required: !0 })), r.a.createElement("div", { className: "event__time" }, r.a.createElement("span", null, "To"), r.a.createElement("input", { className: "form-control time-picker", type: "time", placeholder: "", value: this.props.eventTimeTo, onChange: this.changeEventTimeTo, required: !0 })))), r.a.createElement("div", { className: "col-md-4 col-xs-12" }, r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Photos")), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("div", { className: "company-photo-group row" }, this.props.photos && this.props.photos.map((function (e) { return r.a.createElement("div", { className: "company-photo col-md-6" }, r.a.createElement("img", { src: e, alt: "" }), r.a.createElement("label", { type: "button", className: "delete-photo", name: "button", onClick: function () { return t.deletePhoto(e) } })) })), r.a.createElement("div", { className: "add-company-photo-wrapper col-md-6" }, r.a.createElement("label", { htmlFor: "add-company-photo", className: "add-company-photo" }, r.a.createElement("input", { type: "file", id: "add-company-photo", accept: "image/*", onChange: function (e) { return t.handleSelectedFileCompany(e) } }))))), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Category"), r.a.createElement("select", { className: "form-control", onChange: this.changeCategory }, r.a.createElement("option", { value: "" }), this.props.categories && this.props.categories.map((function (e) { return r.a.createElement("option", { value: e.name, selected: t.props.category === e.name }, e.name) })))), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("label", { for: "title" }, "Tags"), r.a.createElement("input", { className: "form-control", type: "text", placeholder: "Enter tags", value: this.props.tagInput, onChange: this.changeTagInput, onKeyUp: this.watchForEnter })), r.a.createElement("div", { className: "form-group e__s__item" }, r.a.createElement("div", { className: "tag-list" }, (this.props.tagList || []).map((function (e) { return r.a.createElement("span", { className: "tag-default tag-pill tag-outline", key: e }, r.a.createElement("i", { className: "ion-close-round", onClick: t.removeTagHandler(e) }), e) })))))), 2 == this.state.stage && r.a.createElement("div", { className: "ticket_stage" }, r.a.createElement("div", { className: "row t__s__header" }, r.a.createElement("div", { className: "col-md-6 col-xs-12" }, "Ticket list and prices"), r.a.createElement("div", { className: "col-md-1 col-xs-2" }, "Free"), r.a.createElement("div", { className: "col-md-2 col-xs-4" }, "Price"), r.a.createElement("div", { className: "col-md-2 col-xs-4" }, "Quantity"), r.a.createElement("div", { className: "col-md-1 col-xs-2" }, "Action")), r.a.createElement("div", { className: "t__s__content" }, this.props.tickets && this.props.tickets.map((function (e, a) { return r.a.createElement("div", { className: "row t__s__item", key: "event".concat(a) }, r.a.createElement("div", { className: "col-md-2 col-xs-4" }, r.a.createElement("span", null, "Ticket ", a + 1)), r.a.createElement("div", { className: "col-md-4 col-xs-8" }, r.a.createElement("input", { type: "text", className: "form-control", placeholder: "Ticket name", value: e.name, onChange: function (e) { return t.updateTickets(a, "name", e.target.value) } })), r.a.createElement("div", { className: "col-md-1 col-xs-2" }, r.a.createElement("input", { type: "checkbox", id: "free_checkbox", className: "form-control", name: "free", value: "free", onChange: function (i) { return t.updateTickets(a, "isFree", !e.isFree) }, checked: e.isFree })), r.a.createElement("div", { className: "col-md-2 col-xs-4" }, r.a.createElement("input", { className: "form-control", type: "number", placeholder: "Price ($)", value: e.price, min: "0", step: "1", max: "1000", disabled: e.isFree, onChange: function (e) { return t.updateTickets(a, "price", e.target.value) } })), r.a.createElement("div", { className: "col-md-2 col-xs-4" }, r.a.createElement("input", { className: "form-control", type: "number", placeholder: "quantity", value: e.quantity, min: "0", step: "1", max: "1000", onChange: function (e) { return t.updateTickets(a, "quantity", e.target.value) } })), r.a.createElement("div", { className: "remove-ctrl col-md-1 col-xs-2" }, r.a.createElement("i", { className: "fa fa-minus-circle", "aria-hidden": "true", onClick: function () { return t.removeTicket(a) } }))) })), r.a.createElement("div", { className: "row t__s__item" }, r.a.createElement("button", { type: "button", className: "btn add-more-ticket", onClick: function () { return t.addMoreTicket() } }, "Add tickets")))), 3 == this.state.stage && r.a.createElement("div", { className: "row event_stage" }, r.a.createElement("div", { className: "col-md-7 col-xs-12" }, r.a.createElement("div", { className: "e__s__item e__h" }, r.a.createElement("label", null, "Name of the Event"), r.a.createElement("p", null, this.props.title)), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Description"), r.a.createElement("p", null, this.props.description)), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Date of Event"), r.a.createElement("p", null, this.props.eventDate)), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Time Range"), r.a.createElement("p", null, "From ", this.props.eventTimeFrom, " To ", this.props.eventTimeTo)), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Tickets list"), this.props.tickets && this.props.tickets.length > 0 ? r.a.createElement("ul", null, this.props.tickets.map((function (t) { return r.a.createElement("li", null, t.name, " ( ", t.isFree ? "Free" : "$" + t.price, " )") }))) : r.a.createElement("p", null, "no tickets yet"))), r.a.createElement("div", { className: "col-md-4 col-xs-12" }, r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Photos")), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement(tt.a, { items: e, autoPlay: !0, slideInterval: 5e3, showPlayButton: !1, slideDuration: 500, showBullets: !0, showThumbnails: !1, showFullscreenButton: !1 })), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Category"), r.a.createElement("p", null, " ", this.props.category)), r.a.createElement("div", { className: "e__s__item" }, r.a.createElement("label", null, "Tags"), r.a.createElement("div", { className: "tag-list" }, (this.props.tagList || []).map((function (t) { return r.a.createElement("span", { className: "tag-default tag-pill tag-outline", key: t }, t) })))))), r.a.createElement("div", { className: "stage_btn_wrapper" }, r.a.createElement("ul", { className: "stage_markers" }, r.a.createElement("li", { className: nt()(this.state.stage >= 1 && "passed") }, r.a.createElement("label", null, r.a.createElement("i", { className: "fa fa-check", "aria-hidden": "true" }), r.a.createElement("span", null, "1")), r.a.createElement("p", null, "Step1")), r.a.createElement("li", { className: nt()(this.state.stage >= 2 && "passed") }, r.a.createElement("label", null, r.a.createElement("i", { className: "fa fa-check", "aria-hidden": "true" }), r.a.createElement("span", null, "2")), r.a.createElement("p", null, "Step2")), r.a.createElement("li", { className: nt()(this.state.stage >= 3 && "passed") }, r.a.createElement("label", null, r.a.createElement("i", { className: "fa fa-check", "aria-hidden": "true" }), r.a.createElement("span", null, "3")), r.a.createElement("p", null, "Step3"))), r.a.createElement("div", { className: "stage_btns" }, r.a.createElement("button", { type: "button", className: "btn", onClick: this.submitForm("previous") }, "Previous"), r.a.createElement("button", { type: "button", className: nt()("btn", 3 == this.state.stage && "submit_ticket"), onClick: this.submitForm("next") }, 3 == this.state.stage ? "Save" : "Next")))), r.a.createElement("div", { className: nt()("w__modal__wrapper", this.state.save && "opened") }, r.a.createElement("div", { className: "w__modal delete__block" }, r.a.createElement("div", { className: "w__modal__header" }, r.a.createElement("h3", null, "Alert"), r.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.setState({ save: !1 }) } })), r.a.createElement("div", { className: "w__modal__content" }, r.a.createElement("p", null, "Event has been ", this.props.articleSlug ? "updated" : "created", " successfully.")), r.a.createElement("div", { className: "w__modal__footer" }, r.a.createElement("button", { className: "btn", onClick: function () { return t.setState({ save: !1 }) } }, "Ok")))), r.a.createElement("div", { className: nt()("w__modal__wrapper", this.state.delete && "opened") }, r.a.createElement("div", { className: "w__modal delete__block" }, r.a.createElement("div", { className: "w__modal__header" }, r.a.createElement("h3", null, "Delete event"), r.a.createElement("i", { className: "fa fa-times", "aria-hidden": "true", onClick: function () { return t.setState({ delete: !1 }) } })), r.a.createElement("div", { className: "w__modal__content" }, r.a.createElement("p", null, "Are you sure?")), r.a.createElement("div", { className: "w__modal__footer" }, r.a.createElement("button", { className: "btn btn-sm", onClick: function () { return t.setState({ delete: !1 }) } }, "No"), r.a.createElement("button", { className: "btn btn-danger btn-sm", onClick: function () { return t.onClickDelete(t.props.articleSlug) } }, "Yes"))))) : null } }]), a }(r.a.Component), Rt = Object(s.b)((function (t) { return Object(x.a)({}, t.editor, { categories: t.common.categories }) }), (function (t) { return { onAddTag: function () { return t({ type: d.b }) }, onLoad: function (e) { return t({ type: d.q, payload: e }) }, onRemoveTag: function (e) { return t({ type: d.J, tag: e }) }, onSubmit: function (e) { return t({ type: d.i, payload: e }) }, onClickDelete: function (e) { return t({ type: d.o, payload: e }) }, onUnload: function (e) { return t({ type: d.r }) }, onUpdateField: function (e, a) { return t({ type: d.Q, key: e, value: a }) } } }))(Yt), jt = function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).state = { resend: "" }, t.resend = function () { c.a.Auth.resend(t.props.location.state.email), t.setState({ resend: "Resent at " + (new Date).toString() }) }, t } return Object(_.a)(a, [{ key: "componentDidMount", value: function () { var t = this; if (this.props.location.search.indexOf("?token=") > -1) { var e = this.props.location.search.replace("?token=", ""); c.a.Auth.confirmation(e).then((function (e) { t.props.history.push("/login") })) } } }, { key: "componentWillUnmount", value: function () { } }, { key: "render", value: function () { return r.a.createElement("div", { className: "auth-page confirmation" }, r.a.createElement("div", { className: "container page" }, r.a.createElement("div", { className: "row" }, r.a.createElement("div", { className: "col-md-12 col-xs-12 text-xs-center" }, r.a.createElement("h1", { className: "auth-sub-header1" }, "Verify email"), r.a.createElement("p", { className: "auth-sub-header2" }, "We have sent an e-mail to you for verification."), this.props.location.state && r.a.createElement(r.a.Fragment, null, r.a.createElement("button", { onClick: this.resend, className: "btn btn-black" }, "Resend"), r.a.createElement("p", { className: "auth-sub-header3" }, this.state.resend && this.state.resend)))))) } }]), a }(r.a.Component), Ut = Object(s.b)((function (t) { return Object(x.a)({}, t.auth) }), (function (t) { return { onChangeConfirmation: function (e) { return t({ type: d.P, key: "confirmation", value: e }) } } }))(jt), Ht = (a(748), function (t) { Object(F.a)(a, t); var e = Object(B.a)(a); function a() { var t; return Object(E.a)(this, a), (t = e.call(this)).advancedSearch = function (e, a) { "Enter" === e.key && ("" !== a ? t.props.history.push("/a/" + a) : t.props.history.push("/")) }, t } return Object(_.a)(a, [{ key: "componentWillReceiveProps", value: function (t) { t.redirectTo && (M.dispatch(Object(b.b)(t.redirectTo)), this.props.onRedirect()) } }, { key: "componentWillMount", value: function () { var t = window.localStorage.getItem("jwt"); t && c.a.setToken(t), this.props.onLoad(Promise.all([t ? c.a.Auth.current() : null, c.a.Articles.getAllCategories()]), t) } }, { key: "render", value: function () { var t = this.props.location.pathname.indexOf("/settings") > -1; return this.props.appLoaded ? this.props.currentUser && this.props.currentUser.isCompany ? r.a.createElement("div", null, r.a.createElement(j, { appName: this.props.appName, currentUser: this.props.currentUser, onClickLogout: this.props.onClickLogout, advancedSearch: this.advancedSearch }), r.a.createElement("div", { className: t && "company-board-container" }, t && r.a.createElement(zt, null), r.a.createElement("div", { className: "content" }, r.a.createElement(T.a, null, r.a.createElement(w.a, { exact: !0, path: "/", component: ut.a, key: "home" }), r.a.createElement(w.a, { path: "/a/:askey", component: ut.a, key: "advancedSearch" }), r.a.createElement(w.a, { path: "/s/:search", component: ut.a, key: "search" }), r.a.createElement(w.a, { path: "/t/:tag", component: ut.a, key: "tag" }), r.a.createElement(w.a, { path: "/c/:category", component: ut.a, key: "category" }), r.a.createElement(w.a, { path: "/event/:id/", component: pt }), r.a.createElement(w.a, { path: "/login", component: ft }), r.a.createElement(w.a, { path: "/register/:role?", component: _t }), r.a.createElement(w.a, { path: "/settings/event/:slug?", component: Rt, key: "event" }), r.a.createElement(w.a, { path: "/settings/calendar", component: Xt.a, key: "calendar" }), r.a.createElement(w.a, { path: "/settings/dashboard", component: Ot.a, key: "dashboard" }), r.a.createElement(w.a, { path: "/settings/home", component: Vt.a, key: "shome" }), r.a.createElement(w.a, { path: "/settings/info", component: Nt })))), !t && r.a.createElement(H, { onClickCategory: this.props.onClickCategory })) : r.a.createElement("div", null, r.a.createElement(j, { appName: this.props.appName, currentUser: this.props.currentUser, onClickLogout: this.props.onClickLogout, advancedSearch: this.advancedSearch }), r.a.createElement("div", { className: "content" }, r.a.createElement(T.a, null, r.a.createElement(w.a, { exact: !0, path: "/", component: ut.a, key: "home" }), r.a.createElement(w.a, { path: "/a/:askey", component: ut.a, key: "advancedSearch" }), r.a.createElement(w.a, { path: "/s/:search", component: ut.a, key: "search" }), r.a.createElement(w.a, { path: "/t/:tag", component: ut.a, key: "tag" }), r.a.createElement(w.a, { path: "/c/:category", component: ut.a, key: "category" }), r.a.createElement(w.a, { path: "/login", component: ft }), r.a.createElement(w.a, { path: "/register/:role?", component: _t }), r.a.createElement(w.a, { path: "/editor/:slug", component: Rt }), r.a.createElement(w.a, { path: "/editor", component: Rt }), r.a.createElement(w.a, { path: "/purchase/:slug", component: Lt, key: "purchase" }), r.a.createElement(w.a, { path: "/purchase", component: Lt, key: "purchases" }), r.a.createElement(w.a, { path: "/event/:id/", component: pt }), r.a.createElement(w.a, { path: "/settings/info", component: Nt }), r.a.createElement(w.a, { path: "/@:username/favorites", component: St }), r.a.createElement(w.a, { path: "/@:username", component: Pt }), r.a.createElement(w.a, { path: "/company", component: Vt.a }), r.a.createElement(w.a, { path: "/email-confirmation", component: Ut }))), r.a.createElement(H, { onClickCategory: this.props.onClickCategory })) : r.a.createElement("div", null) } }]), a }(r.a.Component)), qt = Object(s.b)((function (t) { return { appLoaded: t.common.appLoaded, appName: t.common.appName, currentUser: t.common.currentUser, redirectTo: t.common.redirectTo, categories: t.common.categories } }), (function (t) { return { onLoad: function (e, a) { return t({ type: d.d, payload: e, token: a, skipTracking: !0 }) }, onRedirect: function () { return t({ type: d.F }) }, onClickCategory: function (e, a, i) { return t({ type: d.c, tag: e, pager: a, payload: i }) }, onClickLogout: function () { return t({ type: d.x }) } } }))(Ht); n.a.render(r.a.createElement(s.a, { store: M }, r.a.createElement(b.a, { history: v }, r.a.createElement(T.a, null, r.a.createElement(w.a, { path: "/", component: qt })))), document.getElementById("root")) }, 8: function (t, e, a) { "use strict"; (function (t) { var i = a(310), n = a.n(i), s = a(311), o = a.n(s), r = a(219), l = a.n(r), h = n()(o.a, t.Promise), c = "https://worldsty.com/api", d = encodeURIComponent, p = function (t) { return t.body }, u = null, m = function (t) { u && t.set("authorization", "Token ".concat(u)) }, x = function (t) { return h.del("".concat(c).concat(t)).use(m).then(p) }, g = function (t) { return h.get("".concat(c).concat(t)).use(m).then(p) }, b = function (t, e) { return h.put("".concat(c).concat(t), e).use(m).then(p) }, y = function (t, e) { return h.post("".concat(c).concat(t), e).use(m).then(p) }, f = { current: function () { return g("/user") }, login: function (t, e) { return y("/users/login", { user: { email: t, password: e } }) }, register: function (t) { return y("/users", { user: t }) }, resetPassword: function (t) { return y("/users/resetPassword", { user: t }) }, facebookAuth: function (t) { return y("/users/facebookAuth", { user: t }) }, save: function (t) { return b("/user", { user: t }) }, uploadPhoto: function (t) { return l.a.post(c + "/users/uploadPhoto", t) }, confirmation: function (t) { return y("/users/confirmation", { token: t }) }, resend: function (t) { return b("/users/confirmation", { email: t }) } }, v = { getAll: function () { return g("/tags") } }, k = function (t, e) { return "limit=".concat(t, "&offset=").concat(e ? e * t : 0) }, M = function (t) { return Object.assign({}, t, { slug: void 0 }) }, T = { all: function (t) { return g("/articles?".concat(k(10, t))) }, byAuthor: function (t, e) { return g("/articles?author=".concat(d(t), "&").concat(k(5, e))) }, byTag: function (t, e) { return g("/articles?tag=".concat(d(t), "&").concat(k(10, e))) }, byCategory: function (t, e) { return g("/articles?category=".concat(d(t), "&").concat(k(10, e))) }, bySearch: function (t, e) { return g("/articles?".concat(t, "&").concat(k(10, e))) }, advancedSearch: function (t, e) { return g("/articles?askey=".concat(t, "&").concat(k(10, e))) }, del: function (t) { return x("/articles/".concat(t)) }, favorite: function (t) { return y("/articles/".concat(t, "/favorite")) }, favoritedBy: function (t, e) { return g("/articles?favorited=".concat(d(t), "&").concat(k(5, e))) }, feed: function () { return g("/articles/feed?limit=10&offset=0") }, get: function (t) { return g("/articles/".concat(t)) }, unfavorite: function (t) { return x("/articles/".concat(t, "/favorite")) }, update: function (t) { return b("/articles/".concat(t.slug), { article: M(t) }) }, create: function (t) { return y("/articles", { article: t }) }, uploadPhoto: function (t) { return l.a.post(c + "/articles/uploadPhoto", t) }, getAllCategories: function () { return g("/articles/categories") }, purchaseTicket: function (t, e) { return y("/articles/".concat(t, "/purchase"), { purchase: e }) } }, w = { get: function (t) { return g("/purchases/".concat(t)) }, getAll: function (t) { return g("/purchases") } }, P = { create: function (t, e) { return y("/articles/".concat(t, "/comments"), { comment: e }) }, delete: function (t, e) { return x("/articles/".concat(t, "/comments/").concat(e)) }, forArticle: function (t) { return g("/articles/".concat(t, "/comments")) } }, C = { follow: function (t) { return y("/profiles/".concat(t, "/follow")) }, get: function (t) { return g("/profiles/".concat(t)) }, unfollow: function (t) { return x("/profiles/".concat(t, "/follow")) } }; e.a = { Articles: T, Auth: f, Comments: P, Profile: C, Tags: v, Purchases: w, setToken: function (t) { u = t } } }).call(this, a(31)) } }, [[337, 1, 2]]]);
//# sourceMappingURL=main.e7c592dd.chunk.js.map